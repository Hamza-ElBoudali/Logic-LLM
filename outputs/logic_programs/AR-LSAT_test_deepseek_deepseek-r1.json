[
  {
    "id": "ar_lsat_200010_3-G_1_1",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "Which one of the following could be the schedule of the students' reports?",
    "options": [
      "A) Mon. morning: Helen; Mon. afternoon: Robert Tues. morning: Olivia; Tues. afternoon: Irving Wed. morning: Lenore; Wed. afternoon: Kyle",
      "B) Mon. morning: Irving; Mon. afternoon: Olivia Tues. morning: Helen; Tues. afternoon: Kyle Wed. morning: Nina; Wed. afternoon: Lenore",
      "C) Mon. morning: Lenore; Mon. afternoon: Helen Tues. morning: George; Tues. afternoon: Kyle Wed. morning: Robert; Wed. afternoon: Irving",
      "D) Mon. morning: Nina; Mon. afternoon: Helen Tues. morning: Robert; Tues. afternoon: Irving Wed. morning: Olivia; Wed. afternoon: Lenore",
      "E) Mon. morning: Olivia; Mon. afternoon: Nina Tues. morning: Irving; Tues. afternoon: Helen Wed. morning: Kyle; Wed. afternoon: George"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\nreport = Function([students] -> [tuple([days, times])])\nscheduled = Function([students] -> [bool])\n\n# Constraints\nForAll([s:students], Implies(scheduled(s), report(s) != None)) ::: Exactly six students give reports\nCount([s:students], scheduled(s)) == 6 ::: Exactly six students give reports\nForAll([s:students], Implies(s == George, report(s)[0] == Tuesday)) ::: Tuesday is the only day George can give a report\nForAll([s:students], Implies(Or(s == Olivia, s == Robert), report(s)[1] == morning)) ::: Neither Olivia nor Robert can give an afternoon report\nForAll([s:students], Implies(And(s == Nina, report(s)[0] != Wednesday), \n  And(scheduled(Helen), scheduled(Irving), \n    report(Helen)[0] == NextDay(report(Nina)[0]), \n    report(Irving)[0] == NextDay(report(Nina)[0])))) ::: If Nina gives a report not on Wednesday, next day has Helen and Irving\n\n# Options\nQuestion ::: Which one of the following could be the schedule of the students' reports?\nis_sat(And(\n  report(Helen) == (Monday, morning),\n  report(Robert) == (Monday, afternoon),\n  report(Olivia) == (Tuesday, morning),\n  report(Irving) == (Tuesday, afternoon),\n  report(Lenore) == (Wednesday, morning),\n  report(Kyle) == (Wednesday, afternoon),\n  Not(scheduled(George)), Not(scheduled(Nina))\n)) ::: (A)\nis_sat(And(\n  report(Irving) == (Monday, morning),\n  report(Olivia) == (Monday, afternoon),\n  report(Helen) == (Tuesday, morning),\n  report(Kyle) == (Tuesday, afternoon),\n  report(Nina) == (Wednesday, morning),\n  report(Lenore) == (Wednesday, afternoon),\n  Not(scheduled(George)), Not(scheduled(Robert))\n)) ::: (B)\nis_sat(And(\n  report(Lenore) == (Monday, morning),\n  report(Helen) == (Monday, afternoon),\n  report(George) == (Tuesday, morning),\n  report(Kyle) == (Tuesday, afternoon),\n  report(Robert) == (Wednesday, morning),\n  report(Irving) == (Wednesday, afternoon),\n  Not(scheduled(Nina)), Not(scheduled(Olivia))\n)) ::: (C)\nis_sat(And(\n  report(Nina) == (Monday, morning),\n  report(Helen) == (Monday, afternoon),\n  report(Robert) == (Tuesday, morning),\n  report(Irving) == (Tuesday, afternoon),\n  report(Olivia) == (Wednesday, morning),\n  report(Lenore) == (Wednesday, afternoon),\n  Not(scheduled(George)), Not(scheduled(Kyle))\n)) ::: (D)\nis_sat(And(\n  report(Olivia) == (Monday, morning),\n  report(Nina) == (Monday, afternoon),\n  report(Irving) == (Tuesday, morning),\n  report(Helen) == (Tuesday, afternoon),\n  report(Kyle) == (Wednesday, morning),\n  report(George) == (Wednesday, afternoon),\n  Not(scheduled(Lenore)), Not(scheduled(Robert))\n)) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_200010_3-G_1_2",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Kyle and Lenore do not give reports, then the morning reports on Monday, Tuesday, and Wednesday, respectively, could be given by",
    "options": [
      "A) Helen, George, and Nina",
      "B) Irving, Robert, and Helen",
      "C) Nina, Helen, and Olivia",
      "D) Olivia, Robert, and Irving",
      "E) Robert, George, and Helen"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\nslots = EnumSort([morning, afternoon])\nreport = Function([students] -> [days, slots])\nexcluded = [Kyle, Lenore]\n\n# Constraints\nForAll([s:students], Implies(Not(Member(s, excluded)), Exists([d:days, sl:slots], report(s) == (d, sl)))) ::: All six active students give exactly one report\nForAll([s:students], Implies(Member(s, excluded), ForAll([d:days, sl:slots], report(s) != (d, sl)))) ::: Kyle and Lenore don't report\nForAll([d:days, sl:slots], Count([s:students], report(s) == (d, sl)) == 1) ::: Exactly two reports per day (morning and afternoon)\nreport(George) == (Tuesday, _) ::: George only reports on Tuesday\nForAll([s:students], Implies(Or(s == Olivia, s == Robert), report(s)[2] == morning)) ::: Olivia/Robert only in morning\nForAll([s:students, d:days], Implies(And(s == Nina, report(s)[1] != Wednesday), ForAll([next_day:days], (next_day == NextDay(d) -> And(Exists([sl:slots], report(Helen) == (next_day, sl)), Exists([sl:slots], report(Irving) == (next_day, sl))))))) ::: Nina's report triggers Helen+Irving next day unless on Wednesday\n\n# Options\nQuestion ::: If Kyle and Lenore do not give reports, then the morning reports on Monday, Tuesday, and Wednesday, respectively, could be given by\nis_sat(And(\n    report(Helen) == (Monday, morning),\n    report(George) == (Tuesday, morning),\n    report(Nina) == (Wednesday, morning)\n)) ::: (A)\nis_sat(And(\n    report(Irving) == (Monday, morning),\n    report(Robert) == (Tuesday, morning),\n    report(Helen) == (Wednesday, morning)\n)) ::: (B)\nis_sat(And(\n    report(Nina) == (Monday, morning),\n    report(Helen) == (Tuesday, morning),\n    report(Olivia) == (Wednesday, morning)\n)) ::: (C)\nis_sat(And(\n    report(Olivia) == (Monday, morning),\n    report(Robert) == (Tuesday, morning),\n    report(Irving) == (Wednesday, morning)\n)) ::: (D)\nis_sat(And(\n    report(Robert) == (Monday, morning),\n    report(George) == (Tuesday, morning),\n    report(Helen) == (Wednesday, morning)\n)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_200010_3-G_1_3",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "Which one of the following is a pair of students who, if they give reports on the same day as each other, must give reports on Wednesday?",
    "options": [
      "A) George and Lenore",
      "B) Helen and Nina",
      "C) Irving and Robert",
      "D) Kyle and Nina",
      "E) Olivia and Kyle"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\nreport = Function([days, times] -> students)\n\n# Constraints\nDistinct([d:days, t:times], report(d, t)) ::: Each slot is assigned to a distinct student (exactly six students)\nForAll([d:days, t:times], Implies(report(d, t) == George, d == Tuesday)) ::: George only on Tuesday\nForAll([d:days], report(d, afternoon) != Olivia) ::: Olivia not in afternoon\nForAll([d:days], report(d, afternoon) != Robert) ::: Robert not in afternoon\nAnd(\n    ForAll([t:times], Implies(report(Monday, t) == Nina, \n        And(Exists([t1:times], report(Tuesday, t1) == Helen), Exists([t2:times], report(Tuesday, t2) == Irving)))),\n    ForAll([t:times], Implies(report(Tuesday, t) == Nina, \n        And(Exists([t1:times], report(Wednesday, t1) == Helen), Exists([t2:times], report(Wednesday, t2) == Irving))))\n) ::: If Nina gives a report not on Wednesday, next day has Helen and Irving\n\n# Options\nQuestion ::: Which one of the following pairs of students who, if they give reports on the same day as each other, must give reports on Wednesday?\nis_valid(ForAll([d:days], Implies(Exists([t1:times, t2:times], And(report(d, t1) == George, report(d, t2) == Lenore)), d == Wednesday))) ::: (A)\nis_valid(ForAll([d:days], Implies(Exists([t1:times, t2:times], And(report(d, t1) == Helen, report(d, t2) == Nina)), d == Wednesday))) ::: (B)\nis_valid(ForAll([d:days], Implies(Exists([t1:times, t2:times], And(report(d, t1) == Irving, report(d, t2) == Robert)), d == Wednesday))) ::: (C)\nis_valid(ForAll([d:days], Implies(Exists([t1:times, t2:times], And(report(d, t1) == Kyle, report(d, t2) == Nina)), d == Wednesday))) ::: (D)\nis_valid(ForAll([d:days], Implies(Exists([t1:times, t2:times], And(report(d, t1) == Olivia, report(d, t2) == Kyle)), d == Wednesday))) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_1_4",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If George, Nina, and Robert give reports and they do so on different days from one another, which one of the following could be true?",
    "options": [
      "A) Helen gives a report on Wednesday.",
      "B) Nina gives a report on Monday.",
      "C) Nina gives a report on Tuesday.",
      "D) Olivia gives a report on Monday.",
      "E) Robert gives a report on Wednesday."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\nslots = EnumSort([morning, afternoon])\nreports = Function([students] -> [days, slots])\nexcluded = Function([students] -> [bool])\n\n# Constraints\nCount([s:students], Not(excluded(s))) == 6 ::: exactly six will give reports\nForAll([d:days], Count([s:students], And(Not(excluded(s)), reports(s) == (d, morning))) == 1) ::: exactly one morning report per day\nForAll([d:days], Count([s:students], And(Not(excluded(s)), reports(s) == (d, afternoon))) == 1) ::: exactly one afternoon report per day\nreports(George) == (Tuesday, _) ::: George only on Tuesday\nForAll([s:students], Implies(Or(s == Olivia, s == Robert), reports(s)[2] == morning)) ::: Olivia/Robert only in morning\nForAll([s:students], Implies(And(s == Nina, Not(excluded(s)), reports(s)[1] != Wednesday), \n  And(NextDay(reports(s)[1], d_next), \n      reports(Helen) == (d_next, _), \n      reports(Irving) == (d_next, _)))) ::: Nina's report implies Helen & Irving next day unless on Wednesday\nNot(excluded(George)) ::: George gives report\nNot(excluded(Nina)) ::: Nina gives report\nNot(excluded(Robert)) ::: Robert gives report\nForAll([s1,s2:students], Implies(And(s1 != s2, Or(s1 == George, s1 == Nina, s1 == Robert), Or(s2 == George, s2 == Nina, s2 == Robert)), \n  reports(s1)[1] != reports(s2)[1])) ::: George, Nina, Robert on different days\n\n# Options\nQuestion ::: If George, Nina, and Robert give reports and they do so on different days from one another, which one of the following could be true?\nis_sat(And(Not(excluded(Helen)), reports(Helen) == (Wednesday, _))) ::: (A)\nis_sat(And(Not(excluded(Nina)), reports(Nina) == (Monday, _))) ::: (B)\nis_sat(And(Not(excluded(Nina)), reports(Nina) == (Tuesday, _))) ::: (C)\nis_sat(And(Not(excluded(Olivia)), reports(Olivia) == (Monday, morning))) ::: (D)\nis_sat(And(Not(excluded(Robert)), reports(Robert) == (Wednesday, morning))) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_1_5",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Kyle gives the afternoon report on Tuesday, and Helen gives the afternoon report on Wednesday, which one of the following could be the list of the students who give the morning reports on Monday, Tuesday, and Wednesday, respectively?",
    "options": [
      "A) Irving, Lenore, and Nina",
      "B) Lenore, George, and Irving",
      "C) Nina, Irving, and Lenore",
      "D) Robert, George, and Irving",
      "E) Robert, Irving, and Lenore"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\nsessions = EnumSort([morning, afternoon])\nreports = Function([students] -> [days, sessions])\nreported = Function([students] -> [bool])\n\n# Constraints\nExactlySix([s:students], reported(s)) ::: exactly six will give individual oral reports\nForAll([d:days], ExactlyTwo([s:students], And(reported(s), reports(s) == (d, morning))) && ExactlyTwo([s:students], And(reported(s), reports(s) == (d, afternoon)))) ::: exactly two reports each day, one morning and one afternoon\nreports(George) == (Tuesday, _) ::: Tuesday is the only day on which George can give a report\nForAll([s:students], Implies(Or(s == Olivia, s == Robert), reports(s)[2] != afternoon)) ::: Neither Olivia nor Robert can give an afternoon report\nForAll([s:students], Implies(And(reported(s) && s == Nina, reports(s)[1] != Wednesday), NextDay(reports(s)[1]) == reports(Helen)[1] && NextDay(reports(s)[1]) == reports(Irving)[1])) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is on Wednesday\n\n# Scenario Constraints\nreports(Kyle) == (Tuesday, afternoon) ::: Kyle gives the afternoon report on Tuesday\nreports(Helen) == (Wednesday, afternoon) ::: Helen gives the afternoon report on Wednesday\n\n# Options\nQuestion ::: Which one of the following could be the list of the students who give the morning reports on Monday, Tuesday, and Wednesday, respectively?\nis_sat(And(\n    reports(Monday, morning) == Irving,\n    reports(Tuesday, morning) == Lenore,\n    reports(Wednesday, morning) == Nina\n)) ::: (A)\nis_sat(And(\n    reports(Monday, morning) == Lenore,\n    reports(Tuesday, morning) == George,\n    reports(Wednesday, morning) == Irving\n)) ::: (B)\nis_sat(And(\n    reports(Monday, morning) == Nina,\n    reports(Tuesday, morning) == Irving,\n    reports(Wednesday, morning) == Lenore\n)) ::: (C)\nis_sat(And(\n    reports(Monday, morning) == Robert,\n    reports(Tuesday, morning) == George,\n    reports(Wednesday, morning) == Irving\n)) ::: (D)\nis_sat(And(\n    reports(Monday, morning) == Robert,\n    reports(Tuesday, morning) == Irving,\n    reports(Wednesday, morning) == Lenore\n)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_200010_3-G_1_6",
    "context": "Of the eight students\u00e2\u20ac\u201dGeorge, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert\u00e2\u20ac\u201din a seminar, exactly six will give individual oral reports during three consecutive days\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Exactly two reports will be given each day\u00e2\u20ac\u201done in the morning and one in the afternoon\u00e2\u20ac\u201daccording to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Helen, Kyle, and Lenore, not necessarily in that order, give the three morning reports, which one of the following must be true?",
    "options": [
      "A) Helen gives a report on Monday.",
      "B) Irving gives a report on Monday.",
      "C) Irving gives a report on Wednesday.",
      "D) Kyle gives a report on Tuesday.",
      "E) Kyle gives a report on Wednesday."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\nreports = Function([students, days, times] -> [bool])\nselected = Function([students] -> [bool])\n\n# Constraints\nExactlySixSelected ::: Exactly six students are selected to give reports.\nForAll([s:students], selected(s) == Or(Exists([d:days, t:times], reports(s, d, t)))) ::: selected is true for exactly six students\nForAll([d:days, t:times], ExactlyOne([s:students], reports(s, d, t))) ::: Each time slot has exactly one report\nForAll([s:students], Implies(selected(s), Count([d:days, t:times], reports(s, d, t)) == 1)) ::: Each selected student reports once\nForAll([d:days], Count([t:times], reports(George, d, t)) == If(d == Tuesday, 1, 0)) ::: George only on Tuesday\nForAll([d:days], Implies(reports(Olivia, d, afternoon), False)) ::: Olivia no afternoon\nForAll([d:days], Implies(reports(Robert, d, afternoon), False)) ::: Robert no afternoon\nForAll([d:days, t:times], Implies(reports(Nina, d, t), Or(d == Wednesday, And(d != Wednesday, reports(Helen, NextDay(d), morning), reports(Irving, NextDay(d), afternoon))))) ::: Nina's report implies next day Helen and Irving unless on Wednesday\nHelenMorning ::: Helen, Kyle, Lenore are the three morning reports\nAnd(ForAll([d:days], reports(Helen, d, morning) == (selected(Helen) And reports(Helen, d, morning))), ForAll([d:days], reports(Kyle, d, morning) == (selected(Kyle) And reports(Kyle, d, morning))), ForAll([d:days], reports(Lenore, d, morning) == (selected(Lenore) And reports(Lenore, d, morning))), Count([s:students], Exists([d:days], reports(s, d, morning))) == 3)\n\n# Options\nQuestion ::: If Helen, Kyle, and Lenore give the three morning reports, which must be true?\nis_valid(reports(Irving, Monday, afternoon)) ::: (B)"
  },
  {
    "id": "ar_lsat_200010_3-G_2_7",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Which one of the following could be the organizer's selection of works?",
    "options": [
      "A) one French novel, two Russian novels, one French play, one Russian play",
      "B) two French novels, one Russian novel, two French plays, one Russian play",
      "C) two French novels, two Russian novels, two French plays",
      "D) three French novels, one Russian novel, two French plays",
      "E) three French novels, two Russian novels, one Russian play"
    ],
    "answer": "C",
    "logic_program": "# Declarations  \nworks = EnumSort([french_novel, russian_novel, french_play, russian_play])  \nselected = Function([works] -> [int])  \n\n# Constraints  \nAnd(5 <= Sum([w:works], selected(w)), Sum([w:works], selected(w)) <= 6) ::: Select at least five and at most six works  \nselected(french_novel) <= 3 ::: Maximum 3 French novels available  \nselected(russian_novel) <= 3 ::: Maximum 3 Russian novels available  \nselected(french_play) <= 2 ::: Maximum 2 French plays available  \nselected(russian_play) <= 1 ::: Maximum 1 Russian play available  \nselected(french_novel) + selected(french_play) <= 4 ::: No more than four French works  \nAnd(3 <= selected(french_novel) + selected(russian_novel), selected(french_novel) + selected(russian_novel) <= 4) ::: At least three but no more than four novels  \nselected(french_novel) >= selected(russian_novel) ::: At least as many French novels as Russian novels  \nImplies(selected(french_play) == 2, selected(russian_play) == 0) ::: If both French plays are selected, Russian play is not  \n\n# Options  \nQuestion ::: Which one of the following could be the organizer's selection of works?  \nis_sat(And(selected(french_novel) == 1, selected(russian_novel) == 2, selected(french_play) == 1, selected(russian_play) == 1)) ::: (A)  \nis_sat(And(selected(french_novel) == 2, selected(russian_novel) == 1, selected(french_play) == 2, selected(russian_play) == 1)) ::: (B)  \nis_sat(And(selected(french_novel) == 2, selected(russian_novel) == 2, selected(french_play) == 2, selected(russian_play) == 0)) ::: (C)  \nis_sat(And(selected(french_novel) == 3, selected(russian_novel) == 1, selected(french_play) == 2, selected(russian_play) == 0)) ::: (D)  \nis_sat(And(selected(french_novel) == 3, selected(russian_novel) == 2, selected(french_play) == 0, selected(russian_play) == 1)) ::: (E)  \n\n**Answer**  \n(C)"
  },
  {
    "id": "ar_lsat_200010_3-G_2_8",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Which one of the following could be true about the organizer's selection of works?",
    "options": [
      "A) No Russian novels are selected.",
      "B) Exactly one French novel is selected.",
      "C) All three plays are selected.",
      "D) All three Russian novels are selected.",
      "E) All five French works are selected."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \nworks = EnumSort([F_novel1, F_novel2, F_novel3, R_novel1, R_novel2, R_novel3, F_play1, F_play2, R_play])  \ncategories = EnumSort([French_novels, Russian_novels, French_plays, Russian_play])  \nselected = Function([works] -> [bool])  \nfrench_works = Function([works] -> [bool])  \nnovels = Function([works] -> [bool])  \n\n# Constraints  \nAtLeast(5, [w:works], selected(w)) ::: select at least five works  \nAtMost(6, [w:works], selected(w)) ::: select at most six works  \n\nForAll([w:works], french_works(w) == Or(w == F_novel1, w == F_novel2, w == F_novel3, w == F_play1, w == F_play2)) ::: define French works  \nAtMost(4, [w:works], And(selected(w), french_works(w))) ::: no more than four French works selected  \n\nForAll([w:works], novels(w) == Or(w == F_novel1, w == F_novel2, w == F_novel3, w == R_novel1, w == R_novel2, w == R_novel3)) ::: define novels  \nAtLeast(3, [w:works], And(selected(w), novels(w))) ::: at least three novels selected  \nAtMost(4, [w:works], And(selected(w), novels(w))) ::: no more than four novels selected  \n\nAtLeast(Count([w:works], And(selected(w), french_works(w), novels(w))) >=  \n       Count([w:works], And(selected(w), Not(french_works(w)), novels(w)))) ::: at least as many French novels as Russian novels  \n\nImplies(And(selected(F_play1), selected(F_play2)), Not(selected(R_play))) ::: if both French plays selected, Russian play not selected  \n\n# Options  \nQuestion ::: Which one of the following could be true about the organizer's selection of works?  \nis_sat(And(  \n    Count([w:works], And(selected(w), Not(french_works(w)), novels(w))) == 0,  \n    AtLeast(3, [w:works], And(selected(w), novels(w)))  \n)) ::: (A) No Russian novels are selected.  \nis_sat(And(  \n    Count([w:works], And(selected(w), french_works(w), novels(w))) == 1,  \n    AtLeast(3, [w:works], And(selected(w), novels(w)))  \n)) ::: (B) Exactly one French novel is selected.  \nis_sat(And(selected(F_play1), selected(F_play2), selected(R_play))) ::: (C) All three plays are selected.  \nis_sat(And(  \n    Count([w:works], And(selected(w), Not(french_works(w)), novels(w))) == 3,  \n    AtMost(4, [w:works], And(selected(w), novels(w)))  \n)) ::: (D) All three Russian novels are selected.  \nis_sat(And(  \n    Count([w:works], And(selected(w), french_works(w))) == 5,  \n    AtMost(4, [w:works], And(selected(w), french_works(w)))  \n)) ::: (E) All five French works are selected.  \n\n**Answer**  \n(A) No Russian novels are selected."
  },
  {
    "id": "ar_lsat_200010_3-G_2_9",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "If the works selected include three French novels, which one of the following could be a complete and accurate list of the remaining works selected?",
    "options": [
      "A) one Russian novel",
      "B) two French plays",
      "C) one Russian novel, one Russian play",
      "D) one Russian novel, two French plays",
      "E) two Russian novels, one French play"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nworks = EnumSort([FN1, FN2, FN3, RN1, RN2, RN3, FP1, FP2, RP])\ncategories = EnumSort([french_novel, russian_novel, french_play, russian_play])\nselected = Function([works] -> [bool])\nInCategory = Function([works] -> [categories])\n\n# Constraints\nForAll([w:works], Implies(selected(w), Or(InCategory(w) == french_novel, InCategory(w) == russian_novel, InCategory(w) == french_play, InCategory(w) == russian_play))) ::: Each work is categorized\nAnd(Count([w:works], And(selected(w), InCategory(w) == french_novel)) == 3, Count([w:works], And(selected(w), InCategory(w) == russian_novel)) >= 0, Count([w:works], And(selected(w), InCategory(w) == french_play)) >= 0, Count([w:works], And(selected(w), InCategory(w) == russian_play)) >= 0) ::: Three French novels are selected\nAnd(Count([w:works], selected(w)) >= 5, Count([w:works], selected(w)) <= 6) ::: At least five and at most six works selected\nCount([w:works], And(selected(w), Or(InCategory(w) == french_novel, InCategory(w) == french_play))) <= 4 ::: No more than four French works\nAnd(Count([w:works], And(selected(w), Or(InCategory(w) == french_novel, InCategory(w) == russian_novel))) >= 3, Count([w:works], And(selected(w), Or(InCategory(w) == french_novel, InCategory(w) == russian_novel))) <= 4) ::: At least three but no more than four novels\nCount([w:works], And(selected(w), InCategory(w) == french_novel)) >= Count([w:works], And(selected(w), InCategory(w) == russian_novel)) ::: At least as many French novels as Russian novels\nImplies(And(selected(FP1), selected(FP2)), Not(selected(RP))) ::: If both French plays selected, Russian play not selected\n\n# Options\nQuestion ::: If the works selected include three French novels, which one of the following could be a complete and accurate list of the remaining works selected?\nis_sat(And(Count([w:works], And(selected(w), InCategory(w) == russian_novel)) == 1, Count([w:works], And(selected(w), Not(InCategory(w) == french_novel))) == 1)) ::: (A)\nis_sat(And(Count([w:works], And(selected(w), InCategory(w) == french_play)) == 2, Count([w:works], And(selected(w), Not(InCategory(w) == french_novel))) == 2)) ::: (B)\nis_sat(And(Count([w:works], And(selected(w), InCategory(w) == russian_novel)) == 1, selected(RP), Count([w:works], And(selected(w), Not(InCategory(w) == french_novel))) == 2)) ::: (C)\nis_sat(And(Count([w:works], And(selected(w), InCategory(w) == russian_novel)) == 1, Count([w:works], And(selected(w), InCategory(w) == french_play)) == 2, Count([w:works], And(selected(w), Not(InCategory(w) == french_novel))) == 3)) ::: (D)\nis_sat(And(Count([w:works], And(selected(w), InCategory(w) == russian_novel)) == 2, Count([w:works], And(selected(w), InCategory(w) == french_play)) == 1, Count([w:works], And(selected(w), Not(InCategory(w) == french_novel))) == 3)) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_2_10",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "The organizer must at least select",
    "options": [
      "A) one French novel and one French play",
      "B) one French novel and one Russian play",
      "C) one Russian novel and one French play",
      "D) two French novels",
      "E) two Russian novels"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nworks = EnumSort([FN1, FN2, FN3, RN1, RN2, RN3, FP1, FP2, RP])\nselected = Function([works] -> [bool])\nfrench_works = Count([w:works], And(Or(w == FN1, w == FN2, w == FN3, w == FP1, w == FP2), selected(w)))\nnovels = Count([w:works], Or(w == FN1, w == FN2, w == FN3, w == RN1, w == RN2, w == RN3))\nfrench_novels = Count([w:works], Or(w == FN1, w == FN2, w == FN3, selected(w)))\nrussian_novels = Count([w:works], Or(w == RN1, w == RN2, w == RN3, selected(w)))\nfrench_plays = Count([w:works], Or(w == FP1, w == FP2, selected(w)))\nrussian_play = Count([w:works], w == RP, selected(w))\n\n# Constraints\nAnd(5 <= Count([w:works], selected(w)), Count([w:works], selected(w)) <= 6) ::: select at least five and at most six works\nfrench_works <= 4 ::: No more than four French works are selected\nAnd(3 <= novels, novels <= 4) ::: At least three but no more than four novels are selected\nfrench_novels >= russian_novels ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(FP1), selected(FP2)), Not(selected(RP))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: The organizer must at least select\nis_valid(And(Exists([w:works], Or(w == FN1, w == FN2, w == FN3, selected(w)) >= 1), Exists([w:works], Or(w == FP1, w == FP2, selected(w)) >= 1))) ::: (A)\nis_valid(And(Exists([w:works], Or(w == FN1, w == FN2, w == FN3, selected(w)) >= 1), selected(RP))) ::: (B)\nis_valid(And(Exists([w:works], Or(w == RN1, w == RN2, w == RN3, selected(w)) >= 1), Exists([w:works], Or(w == FP1, w == FP2, selected(w)) >= 1))) ::: (C)\nis_valid(Count([w:works], Or(w == FN1, w == FN2, w == FN3, selected(w))) >= 2) ::: (D)\nis_valid(Count([w:works], Or(w == RN1, w == RN2, w == RN3, selected(w))) >= 2) ::: (E)\n\n**Answer:** (D) two French novels"
  },
  {
    "id": "ar_lsat_200010_3-G_2_11",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Any one of the following could be true about the organizer's selections of works EXCEPT:",
    "options": [
      "A) No Russian novels and exactly one play are selected.",
      "B) Exactly one Russian novel and both French plays are selected.",
      "C) Exactly two French novels and the Russian play are selected.",
      "D) Exactly two French novels and exactly two plays are selected.",
      "E) Exactly two Russian novels and exactly one play are selected."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nworks = EnumSort([french_novel1, french_novel2, french_novel3, russian_novel1, russian_novel2, russian_novel3, french_play1, french_play2, russian_play])\nselected = Function([works] -> [bool])\nfrench_works = [french_novel1, french_novel2, french_novel3, french_play1, french_play2]\nrussian_works = [russian_novel1, russian_novel2, russian_novel3, russian_play]\n\n# Constraints\nAnd(5 <= Count([w:works], selected(w)), Count([w:works], selected(w)) <= 6) ::: select at least five and at most six works\nCount([w:french_works], selected(w)) <= 4 ::: No more than four French works\nAnd(3 <= Count([n:works], And(Or(n == french_novel1, n == french_novel2, n == french_novel3, n == russian_novel1, n == russian_novel2, n == russian_novel3), selected(n))), Count([n:works], And(Or(n == french_novel1, n == french_novel2, n == french_novel3, n == russian_novel1, n == russian_novel2, n == russian_novel3), selected(n))) <= 4) ::: At least three but no more than four novels\nCount([fn: [french_novel1, french_novel2, french_novel3]], selected(fn)) >= Count([rn: [russian_novel1, russian_novel2, russian_novel3]], selected(rn)) ::: At least as many French novels as Russian novels\nImplies(And(selected(french_play1), selected(french_play2)), Not(selected(russian_play))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: Any one of the following could be true about the organizer's selections of works EXCEPT:\nis_exception(is_sat(And(Count([rn: [russian_novel1, russian_novel2, russian_novel3]], selected(rn)) == 0, Count([p: [french_play1, french_play2, russian_play]], selected(p)) == 1))) ::: (A)\nis_exception(is_sat(And(Count([rn: [russian_novel1, russian_novel2, russian_novel3]], selected(rn)) == 1, And(selected(french_play1), selected(french_play2))))) ::: (B)\nis_exception(is_sat(And(Count([fn: [french_novel1, french_novel2, french_novel3]], selected(fn)) == 2, selected(russian_play)))) ::: (C)\nis_exception(is_sat(And(Count([fn: [french_novel1, french_novel2, french_novel3]], selected(fn)) == 2, Count([p: [french_play1, french_play2, russian_play]], selected(p)) == 2))) ::: (D)\nis_exception(is_sat(And(Count([rn: [russian_novel1, russian_novel2, russian_novel3]], selected(rn)) == 2, Count([p: [french_play1, french_play2, russian_play]], selected(p)) == 1))) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_3_12",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "Which one of the following lists the compositions in an order in which they could be performed during the concert, from first through eighth?",
    "options": [
      "A) L, P, S, R, O, T, F, H",
      "B) O, T, P, F, S, H, R, L",
      "C) P, T, F, S, L, R, O, H",
      "D) P, T, F, S, O, R, L, H",
      "E) T, F, P, R, O, L, S, H"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nposition = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= position(c), position(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], position(c)) ::: each composition performed exactly once\nOr(And(position(T) + 1 == position(F)), And(position(R) + 1 == position(T))) ::: T is performed either immediately before F or immediately after R\nOr(And(position(F) < position(R), position(R) - position(F) >= 3), And(position(R) < position(F), position(F) - position(R) >= 3)) ::: At least two compositions between F and R\nOr(position(O) == 1, position(O) == 5) ::: O is performed either first or fifth\nOr(position(8) == L, position(8) == H) ::: The eighth composition is either L or H\nposition(P) < position(S) ::: P is performed before S\nOr(And(position(O) < position(S), position(S) - position(O) >= 2), And(position(S) < position(O), position(O) - position(S) >= 2)) ::: At least one composition between O and S\n\n# Options\nQuestion ::: Which one of the following lists the compositions in an order in which they could be performed during the concert, from first through eighth?\nis_valid(And(\n    position(L) == 1, position(P) == 2, position(S) == 3, position(R) == 4,\n    position(O) == 5, position(T) == 6, position(F) == 7, position(H) == 8\n)) ::: (A)\nis_valid(And(\n    position(O) == 1, position(T) == 2, position(P) == 3, position(F) == 4,\n    position(S) == 5, position(H) == 6, position(R) == 7, position(L) == 8\n)) ::: (B)\nis_valid(And(\n    position(P) == 1, position(T) == 2, position(F) == 3, position(S) == 4,\n    position(L) == 5, position(R) == 6, position(O) == 7, position(H) == 8\n)) ::: (C)\nis_valid(And(\n    position(P) == 1, position(T) == 2, position(F) == 3, position(S) == 4,\n    position(O) == 5, position(R) == 6, position(L) == 7, position(H) == 8\n)) ::: (D)\nis_valid(And(\n    position(T) == 1, position(F) == 2, position(P) == 3, position(R) == 4,\n    position(O) == 5, position(L) == 6, position(S) == 7, position(H) == 8\n)) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_200010_3-G_3_13",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "P CANNOT be performed",
    "options": [
      "A) second",
      "B) third",
      "C) fourth",
      "D) sixth",
      "E) seventh"
    ],
    "answer": "E",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nposition = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= position(c), position(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], position(c)) ::: each composition is performed exactly once\nOr(position(T) + 1 == position(F), position(R) + 1 == position(T)) ::: T is performed either immediately before F or immediately after R\nOr(And(position(F) < position(R), position(R) - position(F) >= 3), And(position(R) < position(F), position(F) - position(R) >= 3)) ::: At least two compositions between F and R\nOr(position(O) == 1, position(O) == 5) ::: O is performed either first or fifth\nOr(position(8) == L, position(8) == H) ::: The eighth composition is either L or H\nposition(P) < position(S) ::: P is performed before S\nOr(And(position(O) < position(S), position(S) - position(O) >= 2), And(position(S) < position(O), position(O) - position(S) >= 2)) ::: At least one composition between O and S\n\n# Options\nQuestion ::: P CANNOT be performed\nis_exception(is_sat(position(P) == 2)) ::: (A)\nis_exception(is_sat(position(P) == 3)) ::: (B)\nis_exception(is_sat(position(P) == 4)) ::: (C)\nis_exception(is_sat(position(P) == 6)) ::: (D)\nis_exception(is_sat(position(P) == 7)) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_3_14",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If T is performed fifth and F is performed sixth, then S must be performed either",
    "options": [
      "A) fourth or seventh",
      "B) third or sixth",
      "C) third or fourth",
      "D) second or seventh",
      "E) first or fourth"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\npositions = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\nperformed = Function([compositions] -> [positions])\n\n# Constraints\nDistinct([c:compositions], performed(c)) ::: each composition is performed exactly once\nperformed(T) == 5 ::: T is performed fifth\nperformed(F) == 6 ::: F is performed sixth\nOr(performed(T) == performed(F) - 1, performed(T) == performed(R) + 1) ::: T is either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), performed(R) - performed(F) >= 3), And(performed(R) < performed(F), performed(F) - performed(R) >= 3)) ::: At least two compositions between F and R\nOr(performed(O) == 1, performed(O) == 5) ::: O is first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: Eighth composition is L or H\nperformed(P) < performed(S) ::: P is before S\nOr(And(performed(O) < performed(S), performed(S) - performed(O) >= 2), And(performed(S) < performed(O), performed(O) - performed(S) >= 2)) ::: At least one composition between O and S\n\n# Options\nQuestion ::: If T is performed fifth and F is performed sixth, then S must be performed either\nis_valid(Or(performed(S) == 4, performed(S) == 7)) ::: (A) fourth or seventh\nis_valid(Or(performed(S) == 3, performed(S) == 6)) ::: (B) third or sixth\nis_valid(Or(performed(S) == 3, performed(S) == 4)) ::: (C) third or fourth\nis_valid(Or(performed(S) == 2, performed(S) == 7)) ::: (D) second or seventh\nis_valid(Or(performed(S) == 1, performed(S) == 4)) ::: (E) first or fourth\n\n**Answer:** (A) fourth or seventh"
  },
  {
    "id": "ar_lsat_200010_3-G_3_15",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If O is performed immediately after T, then F must be performed either",
    "options": [
      "A) first or second",
      "B) second or third",
      "C) fourth or sixth",
      "D) fourth or seventh",
      "E) sixth or seventh"
    ],
    "answer": "E",
    "logic_program": "# Declarations  \ncompositions = EnumSort([F, H, L, O, P, R, S, T])  \nposition = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])  \nperform = Function([compositions] -> [position])  \n\n# Constraints  \nDistinct([c:compositions], perform(c)) ::: each composition is performed exactly once  \nAnd(Or(perform(T) + 1 == perform(F), perform(R) + 1 == perform(T))) ::: T is either immediately before F or after R  \nOr(And(perform(F) > perform(R) + 2), And(perform(R) > perform(F) + 2)) ::: at least two compositions between F and R  \nOr(perform(O) == 1, perform(O) == 5) ::: O is first or fifth  \nOr(perform(L) == 8, perform(H) == 8) ::: eighth composition is L or H  \nperform(P) < perform(S) ::: P is before S  \nOr(And(perform(S) > perform(O) + 1), And(perform(S) < perform(O) - 1)) ::: at least one composition between O and S  \nperform(O) == perform(T) + 1 ::: O is immediately after T  \n\n# Options  \nQuestion ::: If O is performed immediately after T, then F must be performed either  \nis_valid(ForAll([perform(F)], Or(perform(F) == 6, perform(F) == 7))) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_3_16",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If S is performed fourth, which one of the following could be an accurate list of the compositions performed first, second, and third, respectively?",
    "options": [
      "A) F, H, P",
      "B) H, P. L",
      "C) O, P, R",
      "D) O, P, T",
      "E) P, R, T"
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nposition = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= position(c), position(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], position(c)) ::: each composition is performed exactly once\nOr(position(T) + 1 == position(F), position(R) + 1 == position(T)) ::: T is performed either immediately before F or immediately after R\nOr(And(position(F) < position(R), position(R) - position(F) >= 3), And(position(R) < position(F), position(F) - position(R) >= 3)) ::: At least two compositions between F and R\nOr(position(O) == 1, position(O) == 5) ::: O is performed either first or fifth\nOr(position(L) == 8, position(H) == 8) ::: The eighth composition is either L or H\nposition(P) < position(S) ::: P is performed before S\nOr(And(position(O) < position(S), position(S) - position(O) >= 2), And(position(S) < position(O), position(O) - position(S) >= 2)) ::: At least one composition between O and S\nposition(S) == 4 ::: S is performed fourth\n\n# Options\nQuestion ::: If S is performed fourth, which one of the following could be an accurate list of the compositions performed first, second, and third, respectively?\nis_sat(And(position(F) == 1, position(H) == 2, position(P) == 3)) ::: (A)\nis_sat(And(position(H) == 1, position(P) == 2, position(L) == 3)) ::: (B)\nis_sat(And(position(O) == 1, position(P) == 2, position(R) == 3)) ::: (C)\nis_sat(And(position(O) == 1, position(P) == 2, position(T) == 3)) ::: (D)\nis_sat(And(position(P) == 1, position(R) == 2, position(T) == 3)) ::: (E)\n\n**Answer:** (C) O, P, R"
  },
  {
    "id": "ar_lsat_200010_3-G_3_17",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If P is performed third and S is performed sixth, the composition performed fifth must be either",
    "options": [
      "A) F or H",
      "B) F or O",
      "C) F or T",
      "D) H or L",
      "E) O or R"
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nposition = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= position(c), position(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], position(c)) ::: each composition is performed exactly once\nOr(position(T) + 1 == position(F), position(R) - 1 == position(T)) ::: T is immediately before F or immediately after R\nOr(And(position(F) < position(R), position(R) - position(F) >= 3), And(position(R) < position(F), position(F) - position(R) >= 3)) ::: At least two compositions between F and R\nOr(position(O) == 1, position(O) == 5) ::: O is first or fifth\nOr(position(8) == L, position(8) == H) ::: Eighth composition is L or H\nposition(P) < position(S) ::: P is before S\nOr(And(position(O) < position(S), position(S) - position(O) >= 2), And(position(S) < position(O), position(O) - position(S) >= 2)) ::: At least one composition between O and S\nAnd(position(P) == position position position(S) == 6) ::: P is third and S is sixth\n\n# Options\nQuestion ::: The composition performed fifth must be either\nis_valid(Or(position(F) == 5, position(T) == 5)) ::: (C) F or T"
  },
  {
    "id": "ar_lsat_200010_3-G_3_18",
    "context": "At a concert, exactly eight compositions\u00e2\u20ac\u201dF, H, L, O, P, R, S, and T\u00e2\u20ac\u201dare to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If exactly two compositions are performed after F but before O, then R must be performed",
    "options": [
      "A) first",
      "B) third",
      "C) fourth",
      "D) sixth",
      "E) seventh"
    ],
    "answer": "D",
    "logic_program": "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nposition = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= position(c), position(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], position(c)) ::: each composition is performed exactly once\nOr(position(T) == position(F) - 1, position(T) == position(R) + 1) ::: T is performed either immediately before F or immediately after R\nOr(And(position(F) < position(R), position(R) - position(F) >= 3), And(position(R) < position(F), position(F) - position(R) >= 3)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(position(O) == 1, position(O) == 5) ::: O is performed either first or fifth\nOr(position(8) == L, position(8) == H) ::: The eighth composition performed is either L or H\nposition(P) < position(S) ::: P is performed at some time before S\nOr(And(position(O) < position(S), position(S) - position(O) >= 2), And(position(S) < position(O), position(O) - position(S) >= 2)) ::: At least one composition is performed either after O and before S, or after S and before O\nposition(F) + 3 == position(O) ::: Exactly two compositions are performed after F but before O (i.e., F is at position x, O at x+3)\n\n# Options\nQuestion ::: If exactly two compositions are performed after F but before O, then R must be performed\nis_valid(position(R) == 1) ::: (A)\nis_valid(position(R) == 3) ::: (B)\nis_valid(position(R) == 4) ::: (C)\nis_valid(position(R) == 6) ::: (D)\nis_valid(position(R) == 7) ::: (E)\n\n**Answer:** (D) sixth"
  },
  {
    "id": "ar_lsat_200010_3-G_4_19",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be the order in which the breeds of kitten are featured in the pet shop, from day 1 though day 7?",
    "options": [
      "A) Himalayan, Manx, Siamese, Himalayan, Manx, Himalayan, Siamese",
      "B) Manx, Himalayan, Siamese, Himalayan, Manx Himalayan, Manx",
      "C) Manx, Himalayan, Manx, Himalayan, Siamese, Manx, Siamese",
      "D) Siamese, Himalayan, Manx, Himalayan, Siamese, Siamese, Himalayan",
      "E) Siamese, Himalayan, Siamese, Himalayan, Manx, Siamese, Himalayan"
    ],
    "answer": "E",
    "logic_program": "# Declarations\ndays = EnumSort([d1, d2, d3, d4, d5, d6, d7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nkitten = Function([days] -> [kitten_breeds])\npuppy = Function([days] -> [puppy_breeds])\n\n# Constraints\nForAll([d:days], And(kitten(d) != kitten(d+1), puppy(d) != puppy(d+1))) ::: No breed is featured on any two consecutive days\npuppy(d1) == Greyhound ::: Greyhounds are featured on day 1\nForAll([d:days], Implies(d == d1, And(kitten(d) != Himalayan, kitten(d7) != kitten(d1), puppy(d7) != Greyhound))) ::: Any breed featured on day 1 is not featured on day 7\nCount([d:days], kitten(d) == Himalayan) == 3 ::: Himalayans are featured on exactly three days, but not on day 1\nForAll([d:days], Implies(kitten(d) == Himalayan, puppy(d) != Rottweiler)) ::: Rottweilers are not featured on any day that features Himalayans\npuppy(d7) != Rottweiler ::: Rottweilers are not featured on day 7\n\n# Options\nQuestion ::: Which one of the following could be the order in which the breeds of kitten are featured in the pet shop, from day 1 though day 7?\nis_sat(And(\n    kitten(d1) == Siamese, kitten(d2) == Himalayan, kitten(d3) == Siamese,\n    kitten(d4) == Himalayan, kitten(d5) == Manx, kitten(d6) == Siamese,\n    kitten(d7) == Himalayan\n)) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_4_20",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 2, which one of the following could be true?",
    "options": [
      "A) Manx are featured on day 3.",
      "B) Siamese are featured on day 4.",
      "C) Rottweilers are featured on day 5.",
      "D) Himalayans are featured on day 6.",
      "E) Greyhounds are featured on day 7."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nkitten_day = Function([days] -> [kitten_breeds])\npuppy_day = Function([days] -> [puppy_breeds])\n\n# Constraints\npuppy_day(1) == Greyhound ::: Greyhounds are featured on day 1\nForAll([d:days], Implies(d < 7, And(kitten_day(d) != kitten_day(d+1), puppy_day(d) != puppy_day(d+1)))) ::: No breed is featured on any two consecutive days\nAnd(kitten_day(1) != kitten_day(7), puppy_day(7) != Greyhound) ::: Any breed featured on day 1 is not featured on day 7\nAnd(Count([d:days], kitten_day(d) == Himalayan) == 3, kitten_day(1) != Himalayan) ::: Himalayans are featured exactly three days, not on day 1\nAnd(ForAll([d:days], Implies(kitten_day(d) == Himalayan, puppy_day(d) != Rottweiler)), puppy_day(7) != Rottweiler) ::: Rottweilers are not featured on day 7 or days with Himalayans\nkitten_day(2) != Himalayan ::: Himalayans are not featured on day 2\n\n# Options\nQuestion ::: If Himalayans are not featured on day 2, which one of the following could be true?\nis_sat(kitten_day(3) == Manx) ::: (A)\nis_sat(kitten_day(4) == Siamese) ::: (B)\nis_sat(puppy_day(5) == Rottweiler) ::: (C)\nis_sat(kitten_day(6) == Himalayan) ::: (D)\nis_sat(puppy_day(7) == Greyhound) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_4_21",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) Greyhounds and Siamese are both featured on day 2.",
      "B) Greyhounds and Himalayans are both featured on day 7.",
      "C) Rottweilers and Himalayans are both featured on day 4.",
      "D) Rottweilers and Manx are both featured on day 5.",
      "E) Newfoundlands and Manx are both featured on day 6."
    ],
    "answer": "D",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200010_3-G_4_22",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 7, then which one of the following pairs of days CANNOT feature both the same breed of kitten and the same breed of puppy?",
    "options": [
      "A) day 1 and day 3",
      "B) day 2 and day 6",
      "C) day 3 and day 5",
      "D) day 4 and day 6",
      "E) day 5 and day 7"
    ],
    "answer": "B",
    "logic_program": "# Declarations\ndays = Function([int] -> bool)  // Days are integers 1 to 7\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nkitten = Function([int] -> kitten_breeds)\npuppy = Function([int] -> puppy_breeds)\n\n# Constraints\npuppy(1) == Greyhound ::: Greyhounds are featured on day 1\nForAll([d:int], Implies(And(1 <= d, d <= 6), And(kitten(d) != kitten(d+1), puppy(d) != puppy(d+1)))) ::: No breed is featured on any two consecutive days\nAnd(kitten(1) != kitten(7), puppy(1) != puppy(7)) ::: Any breed featured on day 1 is not featured on day 7\nAnd(Count([d:int], And(1 <= d, d <= 7, kitten(d) == Himalayan)) == 3, kitten(1) != Himalayan) ::: Himalayans are featured on exactly three days, but not on day 1\nAnd(ForAll([d:int], Implies(And(1 <= d, d <= 7, kitten(d) == Himalayan), puppy(d) != Rottweiler)), puppy(7) != Rottweiler) ::: Rottweilers are not featured on day 7, nor on any day that features Himalayans\nkitten(7) != Himalayan ::: Himalayans are not featured on day 7 (additional premise)\n\n# Options\nQuestion ::: If Himalayans are not featured on day 7, then which one of the following pairs of days CANNOT feature both the same breed of kitten and the same breed of puppy?\nis_exception(is_sat(And(kitten(1) == kitten(3), puppy(1) == puppy(3)))) ::: (A)\nis_exception(is_sat(And(kitten(2) == kitten(6), puppy(2) == puppy(6)))) ::: (B)\nis_exception(is_sat(And(kitten(3) == kitten(5), puppy(3) == puppy(5)))) ::: (C)\nis_exception(is_sat(And(kitten(4) == kitten(6), puppy(4) == puppy(6)))) ::: (D)\nis_exception(is_sat(And(kitten(5) == kitten(7), puppy(5) == puppy(7)))) ::: (E)"
  },
  {
    "id": "ar_lsat_200010_3-G_4_23",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) There are exactly four breeds that are each featured on three days.",
      "B) Greyhounds are featured on every day that Himalayans are.",
      "C) Himalayans are featured on every day that Greyhounds are.",
      "D) Himalayans are featured on every day that Rottweilers are not.",
      "E) Rottweilers are featured on every day that Himalayans are not."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \nbreeds_kitten = EnumSort([Himalayan, Manx, Siamese])  \nbreeds_puppy = EnumSort([Greyhound, Newfoundland, Rottweiler])  \ndays = EnumSort([d1, d2, d3, d4, d5, d6, d7])  \nkitten = Function([days] -> [breeds_kitten])  \npuppy = Function([days] -> [breeds_puppy])  \n\n# Constraints  \npuppy(d1) == Greyhound ::: Greyhounds are featured on day 1  \nForAll([d:days], And(  \n    ForAll([b:breeds_kitten], Implies(kitten(d) == b, kitten(Next(d)) != b)),  \n    ForAll([b:breeds_puppy], Implies(puppy(d) == b, puppy(Next(d)) != b))  \n)) ::: No breed is featured on two consecutive days  \nForAll([d:days], Implies(d == d1, And(kitten(d) != Himalayan, puppy(d) != puppy(d7)))) ::: Day 1 breeds not on day 7  \nCount([d:days], kitten(d) == Himalayan) == 3 ::: Himalayans featured exactly three days  \nkitten(d1) != Himalayan ::: Himalayans not on day 1  \nForAll([d:days], Implies(Or(d == d7, kitten(d) == Himalayan), puppy(d) != Rottweiler)) ::: Rottweilers not on day 7 or Himalayan days  \n\n# Options  \nQuestion ::: Which one of the following could be true?  \nis_sat(  \n    Count([b:breeds_kitten + breeds_puppy], Count([d:days], Or(kitten(d) == b, puppy(d) == b)) == 3) == 4  \n) ::: (A)  \nis_sat(  \n    ForAll([d:days], Implies(kitten(d) == Himalayan, puppy(d) == Greyhound))  \n) ::: (B)  \nis_sat(  \n    ForAll([d:days], Implies(puppy(d) == Greyhound, kitten(d) == Himalayan))  \n) ::: (C)  \nis_sat(  \n    ForAll([d:days], Implies(puppy(d) != Rottweiler, kitten(d) == Himalayan))  \n) ::: (D)  \nis_sat(  \n    ForAll([d:days], Implies(kitten(d) != Himalayan, puppy(d) == Rottweiler))  \n) ::: (E)  \n\n**Answer**  \n(E) Rottweilers are featured on every day that Himalayans are not.  \n\n**Explanation**  \nThe constraints eliminate options B, C, D due to conflicts with day 1/7 restrictions and consecutive-day rules. Option A requires 4 breeds each appearing 3 times, which is structurally impossible given the 14 total slots and no-consecutive-day constraints. Option E is validated through scenarios where Rottweilers occupy non-Himalayan days except day 7 (which must have Himalayans to avoid Rottweiler there), aligning with all constraints."
  },
  {
    "id": "ar_lsat_200010_3-G_4_24",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten\u00e2\u20ac\u201dHimalayan, Manx, Siamese\u00e2\u20ac\u201dand exactly one of three breeds of puppy\u00e2\u20ac\u201dGreyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 7, which one of the following could be true?",
    "options": [
      "A) Greyhounds are featured on days 3 and 5.",
      "B) Newfoundlands are featured on day 3.",
      "C) Rottweilers are featured on day 6.",
      "D) Rottweilers are featured only on day 3.",
      "E) Rottweilers are featured on exactly three days."
    ],
    "answer": "D",
    "logic_program": "# Declarations  \ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])  \npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])  \nkitten = Function([days] -> [kitten_breeds])  \npuppy = Function([days] -> [puppy_breeds])  \n\n# Constraints  \npuppy(1) == Greyhound ::: Greyhounds are featured on day 1  \nForAll([d:days], And(  \n    ForAll([m:kitten_breeds], Implies(kitten(d) == m, kitten(d+1) != m)),  \n    ForAll([p:puppy_breeds], Implies(puppy(d) == p, puppy(d+1) != p))  \n)) ::: No breed is featured on consecutive days  \nAnd(kitten(7) != kitten(1), puppy(7) != Greyhound) ::: Day 1 breeds not on day 7  \nCount([d:days], kitten(d) == Himalayan) == 3 ::: Himalayans featured exactly three days  \nkitten(1) != Himalayan ::: Himalayans not on day 1  \nForAll([d:days], Implies(kitten(d) == Himalayan, puppy(d) != Rottweiler)) ::: Rottweilers not on H-days  \npuppy(7) != Rottweiler ::: Rottweilers not on day 7  \nkitten(7) != Himalayan ::: Additional constraint from question  \n\n# Options  \nQuestion ::: If Himalayans are not featured on day 7, which could be true?  \nis_sat(And(puppy(3) == Greyhound, puppy(5) == Greyhound)) ::: (A)  \nis_sat(puppy(3) == Newfoundland) ::: (B)  \nis_sat(puppy(6) == Rottweiler) ::: (C)  \nis_sat(And(ForAll([d:days], Implies(d != 3, puppy(d) != Rottweiler)), puppy(3) == Rottweiler)) ::: (D)  \nis_sat(Count([d:days], puppy(d) == Rottweiler) == 3) ::: (E)  \n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_200312_1-G_1_1",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists\u00e2\u20ac\u201dF, G, and H\u00e2\u20ac\u201dthree chemists\u00e2\u20ac\u201dK, L, and M\u00e2\u20ac\u201dand three zoologists\u00e2\u20ac\u201dP, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "Which one of the following is an acceptable selection of scientists for the panel?",
    "options": [
      "A) F, G, K, P, Q",
      "B) G, H, K, L, M",
      "C) G, H, K, L, R",
      "D) H, K, M, P, R",
      "E) H, L, M, P, Q"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\ntypes = EnumSort([botanist, chemist, zoologist])\nspecialty = Function([scientists] -> [types])\nselected = Function([scientists] -> [bool])\n\n# Assign specialties\nspecialty(F) = botanist\nspecialty(G) = botanist\nspecialty(H) = botanist\nspecialty(K) = chemist\nspecialty(L) = chemist\nspecialty(M) = chemist\nspecialty(P) = zoologist\nspecialty(Q) = zoologist\nspecialty(R) = zoologist\n\n# Constraints\nCount([s:scientists], selected(s)) == 5 ::: Panel has five members\nCount([s:scientists], And(selected(s), specialty(s) == botanist)) >= 1 ::: At least one botanist\nCount([s:scientists], And(selected(s), specialty(s) == chemist)) >= 1 ::: At least one chemist\nCount([s:scientists], And(selected(s), specialty(s) == zoologist)) >= 1 ::: At least one zoologist\nImplies(Count([s:scientists], And(selected(s), specialty(s) == botanist)) > 1, Count([s:scientists], And(selected(s), specialty(s) == zoologist)) <= 1) ::: If >1 botanist, \u22641 zoologist\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M selected, include P and R\n\n# Options\nQuestion ::: Which one of the following is an acceptable selection of scientists for the panel?\nis_sat(And(selected(F), selected(G), selected(K), selected(P), selected(Q))) ::: (A)\nis_sat(And(selected(G), selected(H), selected(K), selected(L), selected(M))) ::: (B)\nis_sat(And(selected(G), selected(H), selected(K), selected(L), selected(R))) ::: (C)\nis_sat(And(selected(H), selected(K), selected(M), selected(P), selected(R))) ::: (D)\nis_sat(And(selected(H), selected(L), selected(M), selected(P), selected(Q))) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_200312_1-G_1_2",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists\u00e2\u20ac\u201dF, G, and H\u00e2\u20ac\u201dthree chemists\u00e2\u20ac\u201dK, L, and M\u00e2\u20ac\u201dand three zoologists\u00e2\u20ac\u201dP, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If M is the only chemist selected for the panel, which one of the following must be true?",
    "options": [
      "A) F and G are both selected.",
      "B) G and H are both selected.",
      "C) H and P are both selected.",
      "D) F, G, and H are all selected.",
      "E) P, Q, and R are all selected."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\ntypes = EnumSort([botanist, chemist, zoologist])\nspecialty = Function([scientists] -> [types])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nForAll([s:scientists], Implies(selected(s), specialty(s) == botanist | specialty(s) == chemist | specialty(s) == zoologist)) ::: Each scientist has one type\nAnd(selected(M), ForAll([s:scientists], Implies(specialty(s) == chemist, selected(s) == (s == M)))) ::: M is the only chemist selected\nCount([s:scientists], selected(s)) == 5 ::: Panel has exactly five members\nCount([s:scientists], selected(s) & specialty(s) == botanist) >= 1 ::: At least one botanist\nCount([s:scientists], selected(s) & specialty(s) == zoologist) >= 1 ::: At least one zoologist\nForAll([s1:scientists, s2:scientists], Implies(And(selected(s1), selected(s2), s1 != s2), specialty(s1) != specialty(s2) | s1 == s2)) ::: Correct type assignments (botanist/chemist/zoologist)\nImplies(Count([s:scientists], selected(s) & specialty(s) == botanist) > 1, Count([s:scientists], selected(s) & specialty(s) == zoologist) <= 1) ::: If >1 botanist, \u22641 zoologist\nImplies(selected(F), Not(selected(K))) ::: F and K cannot both be selected\nImplies(selected(K), Not(selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M selected, P and R must be selected\n\n# Options\nQuestion ::: If M is the only chemist selected for the panel, which one of the following must be true?\nis_valid(And(selected(F), selected(G))) ::: (A)\nis_valid(And(selected(G), selected(H))) ::: (B)\nis_valid(And(selected(H), selected(P))) ::: (C)\nis_valid(And(selected(F), selected(G), selected(H))) ::: (D)\nis_valid(And(selected(P), selected(Q), selected(R))) ::: (E)"
  },
  {
    "id": "ar_lsat_200312_1-G_1_3",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists\u00e2\u20ac\u201dF, G, and H\u00e2\u20ac\u201dthree chemists\u00e2\u20ac\u201dK, L, and M\u00e2\u20ac\u201dand three zoologists\u00e2\u20ac\u201dP, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If four of the scientists selected are F, L, Q, and R, which one of the following must be the fifth scientist selected?",
    "options": [
      "A) G",
      "B) H",
      "C) K",
      "D) M",
      "E) P"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\ntypes = EnumSort([botanist, chemist, zoologist])\nselected = Function([scientists] -> [bool])\nspecializes = Function([scientists] -> [types])\n\n# Assign specializations\nForAll([s:scientists], \n    If(s == F | s == G | s == H, specializes(s) == botanist,\n    If(s == K | s == L | s == M, specializes(s) == chemist,\n    specializes(s) == zoologist)))\n    \n# Constraints\nCount([s:scientists], selected(s)) == 5 ::: Panel has five scientists\nForAll([t:types], Exists([s:scientists], selected(s) & specializes(s) == t)) ::: At least one of each type\nImplies(Count([s:scientists], selected(s) & specializes(s) == botanist) > 1, \n        Count([s:scientists], selected(s) & specializes(s) == zoologist) <= 1) ::: If >1 botanist, \u22641 zoologist\nNot(selected(F) & selected(K)) ::: F and K cannot both be selected\nNot(selected(K) & selected(M)) ::: K and M cannot both be selected\nImplies(selected(M), selected(P) & selected(R)) ::: If M selected, both P and R must be selected\n\n# Additional constraints for the specific scenario\nAnd(selected(F), selected(L), selected(Q), selected(R)) ::: Four selected are F, L, Q, R\n\n# Options\nQuestion ::: Which one must be the fifth?\nis_valid(selected(G)) ::: (A)\nis_valid(selected(H)) ::: (B)\nis_valid(selected(K)) ::: (C)\nis_valid(selected(M)) ::: (D)\nis_valid(selected(P)) ::: (E)"
  },
  {
    "id": "ar_lsat_200312_1-G_1_4",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists\u00e2\u20ac\u201dF, G, and H\u00e2\u20ac\u201dthree chemists\u00e2\u20ac\u201dK, L, and M\u00e2\u20ac\u201dand three zoologists\u00e2\u20ac\u201dP, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If P is the only zoologist selected, which one of the following must be true?",
    "options": [
      "A) If K is selected, G cannot be selected.",
      "B) If L is selected, F cannot be selected.",
      "C) If exactly one chemist is selected, it must be K.",
      "D) If exactly two chemists are selected, F cannot be selected.",
      "E) If exactly two chemists are selected, G cannot be selected."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\ntypes = EnumSort([botanist, chemist, zoologist])\nspecialty = Function([scientists] -> [types])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nForAll([s:scientists], Or(\n    And(s == F, specialty(s) == botanist),\n    And(s == G, specialty(s) == botanist),\n    And(s == H, specialty(s) == botanist),\n    And(s == K, specialty(s) == chemist),\n    And(s == L, specialty(s) == chemist),\n    And(s == M, specialty(s) == chemist),\n    And(s == P, specialty(s) == zoologist),\n    And(s == Q, specialty(s) == zoologist),\n    And(s == R, specialty(s) == zoologist)\n)) ::: Define specialties\nCount([s:scientists], selected(s)) == 5 ::: Panel has five scientists\nAnd(\n    Exists([s:scientists], And(selected(s), specialty(s) == botanist)),\n    Exists([s:scientists], And(selected(s), specialty(s) == chemist)),\n    Exists([s:scientists], And(selected(s), specialty(s) == zoologist))\n) ::: At least one of each type\nImplies(\n    Count([s:scientists], And(selected(s), specialty(s) == botanist)) > 1,\n    Count([s:scientists], And(selected(s), specialty(s) == zoologist)) <= 1\n) ::: If more than one botanist, at most one zoologist\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M selected, P and R must be selected\nselected(P) ::: P is the only zoologist selected\nNot(selected(Q)) ::: Q not selected\nNot(selected(R)) ::: R not selected\n\n# Options\nQuestion ::: If P is the only zoologist selected, which one of the following must be true?\nis_valid(Implies(selected(K), Not(selected(G)))) ::: (A)\nis_valid(Implies(selected(L), Not(selected(F)))) ::: (B)\nis_valid(Implies(\n    Count([s:scientists], And(selected(s), specialty(s) == chemist)) == 1,\n    selected(K)\n)) ::: (C)\nis_valid(Implies(\n    Count([s:scientists], And(selected(s), specialty(s) == chemist)) == 2,\n    Not(selected(F))\n)) ::: (D)\nis_valid(Implies(\n    Count([s:scientists], And(selected(s), specialty(s) == chemist)) == 2,\n    Not(selected(G))\n)) ::: (E)"
  },
  {
    "id": "ar_lsat_200312_1-G_1_5",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists\u00e2\u20ac\u201dF, G, and H\u00e2\u20ac\u201dthree chemists\u00e2\u20ac\u201dK, L, and M\u00e2\u20ac\u201dand three zoologists\u00e2\u20ac\u201dP, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If both G and H are among the scientists selected, then the panel must include either",
    "options": [
      "A) F or else K",
      "B) F or else M",
      "C) K or else M",
      "D) M or else Q",
      "E) P or else Q"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\ntypes = EnumSort([botanist, chemist, zoologist])\nspecialty = Function([scientists] -> [types])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nForAll([s:scientists], Implies(selected(s), Or(specialty(s) == botanist, specialty(s) == chemist, specialty(s) == zoologist))) ::: Each scientist is one of the three types\nCount([s:scientists], selected(s)) == 5 ::: Panel has five members\nAnd(selected(G), selected(H)) ::: Both G and H are selected\nCount([s:scientists], And(selected(s), specialty(s) == botanist)) >= 1 ::: At least one botanist\nCount([s:scientists], And(selected(s), specialty(s) == chemist)) >= 1 ::: At least one chemist\nCount([s:scientists], And(selected(s), specialty(s) == zoologist)) >= 1 ::: At least one zoologist\nImplies(Count([s:scientists], And(selected(s), specialty(s) == botanist)) > 1, Count([s:scientists], And(selected(s), specialty(s) == zoologist)) <= 1) ::: If more than one botanist, at most one zoologist\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\n\n# Options\nQuestion ::: If both G and H are among the scientists selected, then the panel must include either\nis_valid(Or(selected(F), selected(K))) ::: (A)\nis_valid(Or(selected(F), selected(M))) ::: (B)\nis_valid(Or(selected(K), selected(M))) ::: (C)\nis_valid(Or(selected(M), selected(Q))) ::: (D)\nis_valid(Or(selected(P), selected(Q))) ::: (E)\n\n**Answer:** (A) F or else K"
  },
  {
    "id": "ar_lsat_200312_1-G_2_6",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following lists could accurately identify the cargo held in each of the loading dock's first three bays, listed in order from bay 1 to bay 3?",
    "options": [
      "A) fuel, machinery, textiles",
      "B) grain, machinery, fuel",
      "C) machinery, livestock, fuel",
      "D) machinery, textiles, fuel",
      "E) machinery, textiles, produce"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\ncargo_assigned = Function([bays] -> [cargos])\n\n# Constraints\nDistinct([b:bays], cargo_assigned(b)) ::: Each bay holds a different type of cargo\ncargo_assigned(grain) > cargo_assigned(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\ncargo_assigned(livestock) > cargo_assigned(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\ncargo_assigned(produce) > cargo_assigned(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nOr(cargo_assigned(textiles) == cargo_assigned(produce) + 1, cargo_assigned(textiles) == cargo_assigned(produce) - 1) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: Which one of the following lists could accurately identify the cargo held in each of the loading dock's first three bays, listed in order from bay 1 to bay 3?\nis_sat(And(cargo_assigned(1) == fuel, cargo_assigned(2) == machinery, cargo_assigned(3) == textiles)) ::: (A)\nis_sat(And(cargo_assigned(1) == grain, cargo_assigned(2) == machinery, cargo_assigned(3) == fuel)) ::: (B)\nis_sat(And(cargo_assigned(1) == machinery, cargo_assigned(2) == livestock, cargo_assigned(3) == fuel)) ::: (C)\nis_sat(And(cargo_assigned(1) == machinery, cargo_assigned(2) == textiles, cargo_assigned(3) == fuel)) ::: (D)\nis_sat(And(cargo_assigned(1) == machinery, cargo_assigned(2) == textiles, cargo_assigned(3) == produce)) ::: (E)"
  },
  {
    "id": "ar_lsat_200312_1-G_2_7",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following CANNOT be the type of cargo held in bay 4?",
    "options": [
      "A) grain",
      "B) livestock",
      "C) machinery",
      "D) produce",
      "E) textiles"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargos])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargos], holds(b) == c)) ::: Each bay holds a different cargo\ngrain > livestock ::: The bay holding grain has a higher number than the bay holding livestock\nlivestock > textiles ::: The bay holding livestock has a higher number than the bay holding textiles\nproduce > fuel ::: The bay holding produce has a higher number than the bay holding fuel\nOr(And(textiles == 1, produce == 2), And(textiles == 2, produce == 3), And(textiles == 3, produce == 4), And(textiles == 4, produce == 5), And(textiles == 5, produce == 6), And(produce == 1, textiles == 2), And(produce == 2, textiles == 3), And(produce == 3, textiles == 4), And(produce == 4, textiles == 5), And(produce == 5, textiles == 6)) ::: Textiles is next to produce\n\n# Options\nQuestion ::: Which one of the following CANNOT be the type of cargo held in bay 4?\nis_invalid(holds(4) == grain) ::: (A)\nis_invalid(holds(4) == livestock) ::: (B)\nis_invalid(holds(4) == machinery) ::: (C)\nis_invalid(holds(4) == produce) ::: (D)\nis_invalid(holds(4) == textiles) ::: (E)\n\n**Answer:** (A) grain"
  },
  {
    "id": "ar_lsat_200312_1-G_2_8",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If there is exactly one bay between the bay holding machinery and the bay holding grain, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "answer": "C",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_2_9",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following could be the bay holding livestock?",
    "options": [
      "A) bay 1",
      "B) bay 2",
      "C) bay 3",
      "D) bay 5",
      "E) bay 6"
    ],
    "answer": "D",
    "logic_program": "# Declarations  \nbays = EnumSort([1, 2, 3, 4, 5, 6])  \ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])  \nassigned = Function([bays] -> [cargos])  \n\n# Constraints  \nDistinct([b: bays], assigned(b)) ::: Each bay holds a different cargo  \nassigned(grain) > assigned(livestock) ::: Grain has higher bay than livestock  \nassigned(livestock) > assigned(textiles) ::: Livestock has higher bay than textiles  \nassigned(produce) > assigned(fuel) ::: Produce has higher bay than fuel  \nOr(assigned(textiles) == assigned(produce) + 1, assigned(textiles) == assigned(produce) - 1) ::: Textiles is next to produce  \n\n# Options  \nQuestion ::: Which one of the following could be the bay holding livestock?  \nis_sat(assigned(livestock) == 1) ::: (A)  \nis_sat(assigned(livestock) == 2) ::: (B)  \nis_sat(assigned(livestock) == 3) ::: (C)  \nis_sat(assigned(livestock) == 5) ::: (D)  \nis_sat(assigned(livestock) == 6) ::: (E)  \n\n**Answer:** (D) bay 5  \n\n**Explanation:**  \n- **Constraints Analysis:**  \n  1. **Grain > Livestock > Textiles** creates a descending order chain.  \n  2. **Produce > Fuel** and **Textiles adjacent to Produce** link these cargos.  \n  3. Testing each option:  \n    - **Bay 1/2/3/6** for livestock violate constraints (e.g., no higher bay for grain if livestock is in 6).  \n    - **Bay 5** works: Assign Grain=6, Livestock=5, Textiles=4, Produce=3 (adjacent to Textiles), Fuel=1, Machinery=2. All constraints are satisfied."
  },
  {
    "id": "ar_lsat_200312_1-G_2_10",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following must be false?",
    "options": [
      "A) The bay holding fuel is next to the bay holding machinery.",
      "B) The bay holding grain is next to the bay holding machinery.",
      "C) The bay holding livestock is next to the bay holding fuel.",
      "D) The bay holding produce is next to the bay holding livestock.",
      "E) The bay holding textiles is next to the bay holding fuel."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nassign = Function([bays] -> [cargos])\n\n# Constraints\nDistinct([b:bays], assign(b)) ::: Each bay holds a different cargo\nForAll([b1:bays, b2:bays], Implies(assign(b1) == grain, assign(b2) == livestock, b1 > b2)) ::: Grain bay > Livestock bay\nForAll([b1:bays, b2:bays], Implies(assign(b1) == livestock, assign(b2) == textiles, b1 > b2)) ::: Livestock bay > Textiles bay\nForAll([b1:bays, b2:bays], Implies(assign(b1) == produce, assign(b2) == fuel, b1 > b2)) ::: Produce bay > Fuel bay\nExists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == textiles, assign(b2) == produce)) ::: Textiles is next to Produce\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_invalid(Exists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == fuel, assign(b2) == machinery))) ::: (A)\nis_invalid(Exists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == grain, assign(b2) == machinery))) ::: (B)\nis_invalid(Exists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == livestock, assign(b2) == fuel))) ::: (C)\nis_invalid(Exists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == produce, assign(b2) == livestock))) ::: (D)\nis_invalid(Exists([b1:bays, b2:bays], And(Or(b2 == b1 + 1, b2 == b1 - 1), assign(b1) == textiles, assign(b2) == fuel))) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_200312_1-G_2_11",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If the bay holding produce is next to the bay holding livestock, then each of the following could be true EXCEPT:",
    "options": [
      "A) Bay 2 is holding fuel.",
      "B) Bay 4 is holding produce.",
      "C) Bay 4 is holding textiles.",
      "D) Bay 5 is holding grain.",
      "E) Bay 5 is holding machinery."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargos])\n\n# Constraints\nDistinct([b:bays], holds(b)) ::: Each bay holds a different type of cargo\nholds(grain_bay) > holds(livestock_bay) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock_bay) > holds(textiles_bay) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce_bay) > holds(fuel_bay) ::: The bay holding produce has a higher number than the bay holding fuel\nAbs(holds(textiles_bay) - holds(produce_bay)) == 1 ::: The bay holding textiles is next to the bay holding produce\nAbs(holds(produce_bay) - holds(livestock_bay)) == 1 ::: Additional condition: produce is next to livestock\n\n# Options\nQuestion ::: Each of the following could be true EXCEPT:\nis_exception(is_sat(holds(2) == fuel)) ::: (A)\nis_exception(is_sat(holds(4) == produce)) ::: (B)\nis_exception(is_sat(holds(4) == textiles)) ::: (C)\nis_exception(is_sat(holds(5) == grain)) ::: (D)\nis_exception(is_sat(holds(5) == machinery)) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_200312_1-G_2_12",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo\u00e2\u20ac\u201dfuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If bay 4 is holding produce, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargos = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\ncargo = Function([bays] -> [cargos])\n\n# Constraints\nDistinct([b:bays], cargo(b)) ::: Each bay holds a different type of cargo\ncargo(4) == produce ::: Bay 4 is holding produce\nAnd(cargo(grain) > cargo(livestock), cargo(livestock) > cargo(textiles)) ::: Grain > Livestock > Textiles\ncargo(produce) > cargo(fuel) ::: Produce > Fuel\nOr(cargo(textiles) == cargo(produce) - 1, cargo(textiles) == cargo(produce) + 1) ::: Textiles is next to Produce\n\n# Options\nQuestion ::: If bay 4 is holding produce, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?\nis_count(4) ::: (C) four"
  },
  {
    "id": "ar_lsat_200312_1-G_3_13",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "Which one of the following could be a complete and accurate list of the days on which the batches of each kind of cookie are made?",
    "options": [
      "A) oatmeal: Monday, Wednesday, Thursday peanut butter: Wednesday, Thursday, Friday sugar: Monday, Thursday, Friday",
      "B) oatmeal: Monday, Tuesday, Thursday peanut butter: Tuesday, Wednesday, Thursday sugar: Monday, Wednesday, Thursday",
      "C) oatmeal: Tuesday, Wednesday, Thursday peanut butter: Wednesday, Thursday, Friday sugar: Tuesday, Thursday, Friday",
      "D) oatmeal: Monday, Tuesday, Thursday peanut butter: Monday, Wednesday, Thursday sugar: Monday, Thursday, Friday",
      "E) oatmeal: Monday, Thursday, Friday peanut butter: Tuesday, Wednesday, Thursday sugar: Monday, Thursday, Friday"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatch = Function([cookies, int] -> [days])\n\n# Constraints\nForAll([c:cookies, d:days], Count([b:int], batch(c, b) == d) <= 1) ::: No two batches of the same kind on the same day\nExists([c:cookies], batch(c, 1) == Monday) ::: At least one batch on Monday\nbatch(oatmeal, 2) == batch(peanut_butter, 1) ::: Second oatmeal batch same day as first peanut butter batch\nbatch(sugar, 2) == Thursday ::: Second sugar batch on Thursday\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the days on which the batches of each kind of cookie are made?\nis_sat(\n    And(\n        ForAll([b:int], batch(oatmeal, b) == [Monday, Wednesday, Thursday][b-1]),\n        ForAll([b:int], batch(peanut_butter, b) == [Wednesday, Thursday, Friday][b-1]),\n        ForAll([b:int], batch(sugar, b) == [Monday, Thursday, Friday][b-1])\n    )\n) ::: (A)\nis_sat(\n    And(\n        ForAll([b:int], batch(oatmeal, b) == [Monday, Tuesday, Thursday][b-1]),\n        ForAll([b:int], batch(peanut_butter, b) == [Tuesday, Wednesday, Thursday][b-1]),\n        ForAll([b:int], batch(sugar, b) == [Monday, Wednesday, Thursday][b-1])\n    )\n) ::: (B)\nis_sat(\n    And(\n        ForAll([b:int], batch(oatmeal, b) == [Tuesday, Wednesday, Thursday][b-1]),\n        ForAll([b:int], batch(peanut_butter, b) == [Wednesday, Thursday, Friday][b-1]),\n        ForAll([b:int], batch(sugar, b) == [Tuesday, Thursday, Friday][b-1])\n    )\n) ::: (C)\nis_sat(\n    And(\n        ForAll([b:int], batch(oatmeal, b) == [Monday, Tuesday, Thursday][b-1]),\n        ForAll([b:int], batch(peanut_butter, b) == [Monday, Wednesday, Thursday][b-1]),\n        ForAll([b:int], batch(sugar, b) == [Monday, Thursday, Friday][b-1])\n    )\n) ::: (D)\nis_sat(\n    And(\n        ForAll([b:int], batch(oatmeal, b) == [Monday, Thursday, Friday][b-1]),\n        ForAll([b:int], batch(peanut_butter, b) == [Tuesday, Wednesday, Thursday][b-1]),\n        ForAll([b:int], batch(sugar, b) == [Monday, Thursday, Friday][b-1])\n    )\n) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_200312_1-G_3_14",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "How many of the days, Monday through Friday, are such that at most two batches of cookies could be made on that day?",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_3_15",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If the first batch of peanut butter cookies is made on Tuesday, then each of the following could be true EXCEPT:",
    "options": [
      "A) Two different kinds of cookie have their first batch made on Monday.",
      "B) Two different kinds of cookie have their first batch made on Tuesday.",
      "C) Two different kinds of cookie have their second batch made on Wednesday.",
      "D) Two different kinds of cookie have their second batch made on Thursday.",
      "E) Two different kinds of cookie have their third batch made on Friday."
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([monday, tuesday, wednesday, thursday, friday])\nbatch = Function([cookies, int] -> [days])\nForAll([c:cookies, n:1..3], And(batch(c, n) >= monday, batch(c, n) <= friday))\n\n# Constraints\nForAll([c:cookies, d:days], Count([n:1..3], batch(c, n) == d) <= 1) ::: No two batches of the same kind on the same day\nExists([c:cookies], batch(c, 1) == monday) ::: At least one batch on Monday\nbatch(oatmeal, 2) == batch(peanut_butter, 1) ::: Second oatmeal batch same day as first peanut butter\nbatch(sugar, 2) == thursday ::: Second sugar batch on Thursday\nbatch(peanut_butter, 1) == tuesday ::: First peanut butter batch on Tuesday (given condition)\n\n# Options\nQuestion ::: If the first batch of peanut butter cookies is made on Tuesday, then each of the following could be true EXCEPT:\nis_exception(is_sat(Exists([c1:cookies, c2:cookies], And(c1 != c2, batch(c1, 1) == monday, batch(c2, 1) == monday)))) ::: (A)\nis_exception(is_sat(Exists([c1:cookies, c2:cookies], And(c1 != c2, batch(c1, 1) == tuesday, batch(c2, 1) == tuesday)))) ::: (B)\nis_exception(is_sat(Exists([c1:cookies, c2:cookies], And(c1 != c2, batch(c1, 2) == wednesday, batch(c2, 2) == wednesday)))) ::: (C)\nis_exception(is_sat(Exists([c1:cookies, c2:cookies], And(c1 != c2, batch(c1, 2) == thursday, batch(c2, 2) == thursday)))) ::: (D)\nis_exception(is_sat(Exists([c1:cookies, c2:cookies], And(c1 != c2, batch(c1, 3) == friday, batch(c2, 3) == friday)))) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_200312_1-G_3_16",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If no batch of cookies is made on Wednesday, then which one of the following must be true?",
    "options": [
      "A) Exactly three batches of cookies are made on Tuesday.",
      "B) Exactly three batches of cookies are made on Friday.",
      "C) At least two batches of cookies are made on Monday.",
      "D) At least two batches of cookies are made on Thursday.",
      "E) Fewer batches of cookies are made on Monday than on Tuesday."
    ],
    "answer": "D",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_3_17",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If the number of batches made on Friday is exactly one, then which one of the following could be true?",
    "options": [
      "A) The first batch of sugar cookies is made on Monday.",
      "B) The first batch of oatmeal cookies is made on Tuesday.",
      "C) The third batch of oatmeal cookies is made on Friday.",
      "D) The first batch of peanut butter cookies is made on Wednesday.",
      "E) The second batch of peanut butter cookies is made on Tuesday."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_3_18",
    "context": "A bakery makes exactly three kinds of cookie\u00e2\u20ac\u201doatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If one kind of cookie's first batch is made on the same day as another kind of cookie's third batch, then which one of the following could be false?",
    "options": [
      "A) At least one batch of cookies is made on each of the five days.",
      "B) At least two batches of cookies are made on Wednesday.",
      "C) Exactly one batch of cookies is made on Monday.",
      "D) Exactly two batches of cookies are made on Tuesday.",
      "E) Exactly one batch of cookies is made on Friday."
    ],
    "answer": "E",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy"
  },
  {
    "id": "ar_lsat_200312_1-G_4_19",
    "context": "For the school paper, five students\u00e2\u20ac\u201dJiang, Kramer, Lopez, Megregian, and O'Neill\u00e2\u20ac\u201deach review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following could be an accurate and complete list of the students who review only Sunset?",
    "options": [
      "A) Lopez",
      "B) O'Neill",
      "C) Jiang, Lopez",
      "D) Kramer, O'Neill",
      "E) Lopez, Megregian"
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_4_20",
    "context": "For the school paper, five students\u00e2\u20ac\u201dJiang, Kramer, Lopez, Megregian, and O'Neill\u00e2\u20ac\u201deach review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) Jiang reviews more of the plays than Lopez does.",
      "B) Megregian reviews more of the plays than Jiang does.",
      "C) Megregian reviews more of the plays than O'Neill does.",
      "D) O'Neill reviews more of the plays than Jiang does.",
      "E) O'Neill reviews more of the plays than Kramer does."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, ONiell])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(Or(reviews(Lopez, p), reviews(Megregian, p))))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nAnd(reviews(Kramer, Tamerlane), reviews(ONiell, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nExistsPair([s1:students, s2:students], s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p))) ::: Exactly two students review the same plays\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Count([p:plays], reviews(Jiang, p)) > Count([p:plays], reviews(Lopez, p))) ::: (A)\nis_valid(Count([p:plays], reviews(Megregian, p)) > Count([p:plays], reviews(Jiang, p))) ::: (B)\nis_valid(Count([p:plays], reviews(Megregian, p)) > Count([p:plays], reviews(ONiell, p))) ::: (C)\nis_valid(Count([p:plays], reviews(ONiell, p)) > Count([p:plays], reviews(Jiang, p))) ::: (D)\nis_valid(Count([p:plays], reviews(ONiell, p)) > Count([p:plays], reviews(Kramer, p))) ::: (E)"
  },
  {
    "id": "ar_lsat_200312_1-G_4_21",
    "context": "For the school paper, five students\u00e2\u20ac\u201dJiang, Kramer, Lopez, Megregian, and O'Neill\u00e2\u20ac\u201deach review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "If exactly three of the students review Undulation, which one of the following could be true?",
    "options": [
      "A) Megregian does not review Undulation.",
      "B) O'Neill does not review Undulation.",
      "C) Jiang reviews Undulation.",
      "D) Lopez reviews Tamerlane.",
      "E) O'Neill reviews Sunset."
    ],
    "answer": "E",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_200312_1-G_4_22",
    "context": "For the school paper, five students\u00e2\u20ac\u201dJiang, Kramer, Lopez, Megregian, and O'Neill\u00e2\u20ac\u201deach review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following could be an accurate and complete list of the students who review Tamerlane?",
    "options": [
      "A) Jiang, Kramer",
      "B) Kramer, O'Neill",
      "C) Kramer, Lopez, O'Neill",
      "D) Kramer, Megregian, O'Neill",
      "E) Lopez, Megregian, O'Neill"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, ONiell])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)) & Not(reviews(Megregian, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nAnd(reviews(Kramer, Tamerlane), reviews(ONiell, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nExists([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) ::: Exactly two students review exactly the same plays\n\n# Options\nQuestion ::: Which one of the following could be an accurate and complete list of the students who review Tamerlane?\nis_sat(And(ForAll([s:students], Implies(reviews(s, Tamerlane), Or(s == Jiang, s == Kramer))), reviews(Kramer, Tamerlane), reviews(ONiell, Tamerlane))) ::: (A) is invalid as it omits ONiell\nis_sat(ForAll([s:students], Implies(reviews(s, Tamerlane), Or(s == Kramer, s == ONiell)))) ::: (B)\nis_sat(ForAll([s:students], Implies(reviews(s, Tamerlane), Or(s == Kramer, s == Lopez, s == ONiell)))) ::: (C)\nis_sat(ForAll([s:students], Implies(reviews(s, Tamerlane), Or(s == Kramer, s == Megregian, s == ONiell)))) ::: (D)\nis_sat(ForAll([s:students], Implies(reviews(s, Tamerlane), Or(s == Lopez, s == Megregian, s == ONiell)))) ::: (E)\n\n**Answer:** (D) Kramer, Megregian, O'Neill\n\n**Step-by-Step Explanation:**\n1. **Constraints Analysis:**\n   - Kramer and O'Neill must review Tamerlane (Condition 3).\n   - Megregian reviews more plays than Kramer and Lopez (Condition 1).\n   - Lopez and Megregian cannot review any play Jiang reviews (Condition 2).\n   - Exactly two students have identical review sets (Condition 4).\n\n2. **Scenario Validation for Option (D):**\n   - **Tamerlane Reviewers:** Kramer, O'Neill, and Megregian.\n   - **Jiang's Plays:** Assume Jiang reviews Sunset (avoids Tamerlane/Undulation conflict).\n   - **Megregian's Plays:** Reviews Tamerlane and Undulation (2 plays, satisfying Condition 1"
  },
  {
    "id": "ar_lsat_200312_1-G_4_23",
    "context": "For the school paper, five students\u00e2\u20ac\u201dJiang, Kramer, Lopez, Megregian, and O'Neill\u00e2\u20ac\u201deach review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "If Jiang does not review Tamerlane, then which one of the following must be true?",
    "options": [
      "A) Jiang reviews Sunset.",
      "B) Lopez reviews Undulation.",
      "C) Megregian reviews Sunset.",
      "D) Megregian reviews Tamerlane.",
      "E) O'Neill reviews Undulation."
    ],
    "answer": "D",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_1_1",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "Which one of the following could be the assignment of parking spaces to the new employees?",
    "options": [
      "A) #1: Young; #2: Souza; #3: Vaughn; #4: Robertson; #5: Togowa; #6: Xu",
      "B) #1: Vaughn; #2: Togowa; #3: Young; #4: Souza; #5: Robertson; #6: Xu",
      "C) #1: Togowa; #2: Young; #3: Xu; #4: Robertson; #5: Souza; #6: Vaughn",
      "D) #1: Togowa; #2: Robertson; #3: Young; #4: Souza; #5: Vaughn; #6: Xu",
      "E) #1: Souza; #2: Togowa; #3: Young; #4: Robertson; #5: Xu; #6: Vaughn"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassign = Function([employees] -> [spaces])\n\n# Constraints\nDistinct([e:employees], assign(e)) ::: No two employees can be assigned the same parking space\nassign(Young) > assign(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassign(Xu) > assign(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassign(Robertson) > assign(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nAnd(assign(Robertson) >= 1, assign(Robertson) <= 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: Which one of the following could be the assignment of parking spaces to the new employees?\nis_sat(And(\n    assign(Young) == 1, assign(Souza) == 2, assign(Vaughn) == 3, assign(Robertson) == 4, assign(Togowa) == 5, assign(Xu) == 6\n)) ::: (A)\nis_sat(And(\n    assign(Vaughn) == 1, assign(Togowa) == 2, assign(Young) == 3, assign(Souza) == 4, assign(Robertson) == 5, assign(Xu) == 6\n)) ::: (B)\nis_sat(And(\n    assign(Togowa) == 1, assign(Young) == 2, assign(Xu) == 3, assign(Robertson) == 4, assign(Souza) == 5, assign(Vaughn) == 6\n)) ::: (C)\nis_sat(And(\n    assign(Togowa) == 1, assign(Robertson) == 2, assign(Young) == 3, assign(Souza) == 4, assign(Vaughn) == 5, assign(Xu) == 6\n)) ::: (D)\nis_sat(And(\n    assign(Souza) == 1, assign(Togowa) == 2, assign(Young) == 3, assign(Robertson) == 4, assign(Xu) == 5, assign(Vaughn) == 6\n)) ::: (E)\n\n**Answer:** (E)"
  },
  {
    "id": "ar_lsat_201110_2-G_1_2",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Togowa is assigned a higher-numbered parking space than Souza, then which one of the following could be true?",
    "options": [
      "A) Young is assigned parking space #2.",
      "B) Vaughn is assigned parking space #5.",
      "C) Togowa is assigned parking space #3.",
      "D) Souza is assigned parking space #2.",
      "E) Robertson is assigned parking space #3."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nparking_spaces = EnumSort([1, 2, 3, 4, 5, 6])\nassign = Function([employees] -> [parking_spaces])\n\n# Constraints\nDistinct([e:employees], assign(e)) ::: No two employees can be assigned the same parking space\nassign(Young) > assign(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassign(Xu) > assign(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassign(Robertson) > assign(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nAnd(assign(Robertson) >= 1, assign(Robertson) <= 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\nassign(Togowa) > assign(Souza) ::: [Additional condition] Togowa is assigned a higher-numbered parking space than Souza\n\n# Options\nQuestion ::: If Togowa is assigned a higher-numbered parking space than Souza, then which one of the following could be true?\nis_sat(assign(Young) == 2) ::: (A)\nis_sat(assign(Vaughn) == 5) ::: (B)\nis_sat(assign(Togowa) == 3) ::: (C)\nis_sat(assign(Souza) == 2) ::: (D)\nis_sat(assign(Robertson) == 3) ::: (E)"
  },
  {
    "id": "ar_lsat_201110_2-G_1_3",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "The assignment of parking spaces to each of the new employees is fully and uniquely determined if which one of the following is true?",
    "options": [
      "A) Souza is assigned parking space #1.",
      "B) Young is assigned parking space #2.",
      "C) Vaughn is assigned parking space #3.",
      "D) Robertson is assigned parking space #4.",
      "E) Xu is assigned parking space #5."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassign = Function([employees] -> [spaces])\n\n# Constraints\nDistinct([e:employees], assign(e)) ::: No two employees can be assigned the same parking space\nassign(Young) > assign(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassign(Xu) > assign(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassign(Robertson) > assign(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nAnd(assign(Robertson) == 1, assign(Robertson) == 2, assign(Robertson) == 3, assign(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: The assignment of parking spaces to each of the new employees is fully and uniquely determined if which one of the following is true?\nis_unique(assign(Souza) == 1) ::: (A)\nis_unique(assign(Young) == 2) ::: (B)\nis_unique(assign(Vaughn) == 3) ::: (C)\nis_unique(assign(Robertson) == 4) ::: (D)\nis_unique(assign(Xu) == 5) ::: (E)\n\n**Answer:** (C) Urma and Xena"
  },
  {
    "id": "ar_lsat_201110_2-G_1_4",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "For how many of the six new employees is the assignment of a parking space limited to one of only two possible spaces?",
    "options": [
      "A) none",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "answer": "D",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_1_5",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Young is assigned a higher-numbered parking space than Souza, then which one of the following could be true?",
    "options": [
      "A) Togowa is assigned parking space #1.",
      "B) Young is assigned parking space #2.",
      "C) Robertson is assigned parking space #3.",
      "D) Souza is assigned parking space #3.",
      "E) Vaughn is assigned parking space #4."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nparking_spaces = EnumSort([1, 2, 3, 4, 5, 6])\nassign = Function([employees] -> [parking_spaces])\n\n# Constraints\nDistinct([e:employees], assign(e)) ::: No two employees can be assigned the same parking space\nassign(Young) > assign(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassign(Xu) > assign(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassign(Robertson) > assign(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assign(Robertson) == 1, assign(Robertson) == 2, assign(Robertson) == 3, assign(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\nassign(Young) > assign(Souza) ::: Additional condition: Young is assigned a higher-numbered parking space than Souza\n\n# Options\nQuestion ::: If Young is assigned a higher-numbered parking space than Souza, then which one of the following could be true?\nis_sat(assign(Togowa) == 1) ::: (A)\nis_sat(assign(Young) == 2) ::: (B)\nis_sat(assign(Robertson) == 3) ::: (C)\nis_sat(assign(Souza) == 3) ::: (D)\nis_sat(assign(Vaughn) == 4) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_201110_2-G_1_6",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Robertson is assigned parking space #3, then which one of the following must be true?",
    "options": [
      "A) Souza is assigned parking space #4.",
      "B) Togowa is assigned parking space #2.",
      "C) Vaughn is assigned parking space #5.",
      "D) Xu is assigned parking space #6.",
      "E) Young is assigned parking space #2."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nparking_spaces = IntSort()\nassign = Function([employees] -> parking_spaces)\n\n# Constraints\nForAll([e:employees], And(1 <= assign(e), assign(e) <= 6)) ::: Each assigned to 1-6\nDistinct([e:employees], assign(e)) ::: No two employees can be assigned the same parking space\nassign(Young) > assign(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassign(Xu) > assign(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassign(Robertson) > assign(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nAnd(assign(Robertson) >= 1, assign(Robertson) <= 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\nassign(Robertson) == 3 ::: Robertson is assigned parking space #3\n\n# Options\nQuestion ::: If Robertson is assigned parking space #3, then which one of the following must be true?\nis_valid(assign(Souza) == 4) ::: (A)\nis_valid(assign(Togowa) == 2) ::: (B)\nis_valid(assign(Vaughn) == 5) ::: (C)\nis_valid(assign(Xu) == 6) ::: (D)\nis_valid(assign(Young) == 2) ::: (E)"
  },
  {
    "id": "ar_lsat_201110_2-G_2_7",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following could be the assignment of the ambassadors?",
    "options": [
      "A) Venezuela: Jaramillo Yemen: Ong Zambia: Novetzke",
      "B) Venezuela: Kayne Yemen: Jaramillo Zambia: Landon",
      "C) Venezuela: Landon Yemen: Novetzke Zambia: Ong",
      "D) Venezuela: Novetzke Yemen: Jaramillo Zambia: Kayne",
      "E) Venezuela: Ong Yemen: Kayne Zambia: Landon"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \ncountries = EnumSort([Venezuela, Yemen, Zambia])  \nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])  \nassigned = Function([countries] -> [ambassadors])  \n\n# Constraints  \nDistinct([c:countries], assigned(c)) ::: One ambassador per country, no duplicates  \nXor(Exists([c:countries], assigned(c) == Kayne), Exists([c:countries], assigned(c) == Novetzke)) ::: Either Kayne or Novetzke, but not both  \nImplies(Exists([c:countries], assigned(c) == Jaramillo), Exists([c:countries], assigned(c) == Kayne)) ::: If Jaramillo is assigned, Kayne must be assigned  \nImplies(assigned(Venezuela) == Ong, Not(assigned(Yemen) == Kayne)) ::: If Ong is in Venezuela, Kayne not in Yemen  \nForAll([c:countries], Implies(assigned(c) == Landon, c == Zambia)) ::: Landon only assigned to Zambia  \n\n# Options  \nQuestion ::: Which one of the following could be the assignment of the ambassadors?  \nis_sat(And(assigned(Venezuela) == Kayne, assigned(Yemen) == Jaramillo, assigned(Zambia) == Landon)) ::: (B)"
  },
  {
    "id": "ar_lsat_201110_2-G_2_8",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "The pair of candidates who are not assigned to ambassadorships could be",
    "options": [
      "A) Jaramillo and Novetzke",
      "B) Jaramillo and Ong",
      "C) Kayne and Landon",
      "D) Kayne and Novetzke",
      "E) Landon and Ong"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\nunassigned = Function([ambassadors] -> [bool])\n\n# Constraints\nForAll([a:ambassadors], If(unassigned(a), ForAll([c:countries], assigned(a) != c), Exists([c:countries], assigned(a) == c))) ::: One ambassador per country, no duplicates\nExactlyOne([assigned(Kayne), assigned(Novetzke)]) ::: Either Kayne or Novetzke, but not both, is assigned\nImplies(assigned(Jaramillo) != null, assigned(Kayne) != null) ::: If Jaramillo is assigned, Kayne is assigned\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is in Venezuela, Kayne not in Yemen\nImplies(assigned(Landon) != null, assigned(Landon) == Zambia) ::: Landon assigned only to Zambia\n\n# Options\nQuestion ::: The pair of candidates who are not assigned to ambassadorships could be\nis_sat(And(unassigned(Jaramillo), unassigned(Novetzke))) ::: (A)\nis_sat(And(unassigned(Jaramillo), unassigned(Ong))) ::: (B)\nis_sat(And(unassigned(Kayne), unassigned(Landon))) ::: (C)\nis_sat(And(unassigned(Kayne), unassigned(Novetzke))) ::: (D)\nis_sat(And(unassigned(Landon), unassigned(Ong))) ::: (E)\n\n**Answer:** (A) Jaramillo and Novetzke"
  },
  {
    "id": "ar_lsat_201110_2-G_2_9",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "If Ong is assigned as ambassador to Venezuela, then the other two ambassadors assigned could be",
    "options": [
      "A) Jaramillo and Landon",
      "B) Jaramillo and Novetzke",
      "C) Kayne and Landon",
      "D) Kayne and Novetzke",
      "E) Landon and Novetzke"
    ],
    "answer": "E",
    "logic_program": "# Declarations\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\nassigned = Function(["
  },
  {
    "id": "ar_lsat_201110_2-G_2_10",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "If Kayne is assigned as ambassador to Yemen, which one of the following must be true?",
    "options": [
      "A) Jaramillo is assigned as ambassador to Venezuela.",
      "B) Landon is assigned as ambassador to Zambia.",
      "C) Ong is assigned as ambassador to Zambia.",
      "D) Jaramillo is not assigned to an ambassadorship.",
      "E) Ong is not assigned to an ambassadorship."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_2_11",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following CANNOT be true?",
    "options": [
      "A) Jaramillo is assigned as ambassador to Zambia.",
      "B) Kayne is assigned as ambassador to Zambia.",
      "C) Novetzke is assigned as ambassador to Zambia.",
      "D) Landon is not assigned to an ambassadorship.",
      "E) Ong is not assigned to an ambassadorship."
    ],
    "answer": "C",
    "logic_program": "# Declarations  \nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])  \ncountries = EnumSort([Venezuela, Yemen, Zambia])  \nassigned = Function([ambassadors] -> [countries])  \n\n# Constraints  \nForAll([a:ambassadors], assigned(a) == NoCountry -> ForAll([a2:ambassadors], a != a2 -> assigned(a2) != assigned(a))) ::: One ambassador per country, no duplicates  \nExactlyOne([Exists([c:countries], assigned(Kayne) == c), Exists([c:countries], assigned(Novetzke) == c)]) ::: Either Kayne or Novetzke, but not both  \nImplies(Exists([c:countries], assigned(Jaramillo) == c), Exists([c:countries], assigned(Kayne) == c)) ::: If Jaramillo is assigned, so is Kayne  \nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is in Venezuela, Kayne not in Yemen  \nForAll([c:countries], Implies(assigned(Landon) == c, c == Zambia)) ::: Landon only to Zambia if assigned  \n\n# Options  \nQuestion ::: Which one of the following CANNOT be true?  \nis_valid(assigned(Jaramillo) == Zambia) ::: (A)  \nis_valid(assigned(Kayne) == Zambia) ::: (B)  \nis_valid(assigned(Novetzke) == Zambia) ::: (C)  \nis_valid(assigned(Landon) == NoCountry) ::: (D)  \nis_valid(assigned(Ong) == NoCountry) ::: (E)  \n\n**Answer:** (C) Novetzke is assigned as ambassador to Zambia."
  },
  {
    "id": "ar_lsat_201110_2-G_2_12",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following, if substituted for the constraint that if Jaramillo is assigned to one of the ambassadorships, then so is Kayne, would have the same effect in determining the assignment of the ambassadors?",
    "options": [
      "A) If Kayne is assigned to an ambassadorship, then so is Jaramillo.",
      "B) If Landon and Ong are both assigned to ambassadorships, then so is Novetzke.",
      "C) If Ong is not assigned to an ambassadorship, then Kayne is assigned to an ambassadorship.",
      "D) Jaramillo and Novetzke are not both assigned to ambassadorships.",
      "E) Novetzke and Ong are not both assigned to ambassadorships."
    ],
    "answer": "D",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_3_13",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following is a possible assignment of riders to bicycles, with the riders for each bicycle listed in the order in which they test the bicycle?",
    "options": [
      "A) F: Seamus, Reynaldo; G: Yuki, Seamus; H: Theresa, Yuki; J: Reynaldo, Theresa",
      "B) F: Seamus, Yuki; G: Reynaldo, Theresa; H: Yuki, Seamus; J: Theresa, Reynaldo",
      "C) F: Yuki, Seamus; G: Seamus, Reynaldo; H: Theresa, Yuki; J: Reynaldo, Theresa",
      "D) F: Yuki, Seamus; G: Theresa, Reynaldo; H: Reynaldo, Theresa; J: Seamus, Yuki",
      "E) F: Yuki, Theresa; G: Seamus, Yuki; H: Theresa, Reynaldo; J: Reynaldo, Seamus"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ndays = EnumSort([day1, day2])\nassignment = Function([riders, days] -> [bicycles])\n\n# Constraints\nForAll([r:riders], Distinct([d:days], assignment(r, d))) ::: Each rider tests a different bicycle each day\nForAll([d:days], Distinct([r:"
  },
  {
    "id": "ar_lsat_201110_2-G_3_14",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "If Theresa tests G on the second day, then which one of the following must be true?",
    "options": [
      "A) Reynaldo tests H on the first day.",
      "B) Reynaldo tests J on the first day.",
      "C) Theresa tests H on the second day.",
      "D) Theresa tests J on the first day.",
      "E) Yuki tests H on the second day."
    ],
    "answer": "E",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_3_15",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Any of the following could be true EXCEPT:",
    "options": [
      "A) Reynaldo tests J on the first day.",
      "B) Reynaldo tests J on the second day.",
      "C) Seamus tests H on the first day.",
      "D) Yuki tests H on the first day.",
      "E) Yuki tests H on the second day."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\ndays = EnumSort([day1, day2])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, days] -> [bicycles])\n\n# Constraints\nForAll([d:days], Distinct([r:riders], tests(r, d))) ::: Each day, all four bicycles are tested and each rider tests a different one\nForAll([r:riders, d:days], tests(r, d) != F) ::: Reynaldo cannot test F (incorrect, should be ForAll([d:days], tests(Reynaldo, d) != F))\nForAll([d:days], tests(Yuki, d) != J) ::: Yuki cannot test J\nExists([d:days], tests(Theresa, d) == H) ::: Theresa must test H on at least one day\nForAll([d:days], Implies(tests(Yuki, day1) == X, tests(Seamus, day2) == X)) ::: Yuki's day1 bike is tested by Seamus on day2\n\n# Corrected Reynaldo's constraint\nForAll([d:days], tests(Reynaldo, d) != F) ::: Reynaldo cannot test F\n\n# Options\nQuestion ::: Any of the following could be true EXCEPT:\nis_exception(is_sat(tests(Reynaldo, day1) == J)) ::: (A)\nis_exception(is_sat(tests(Reynaldo, day2) == J)) ::: (B)\nis_exception(is_sat(tests(Seamus, day1) == H)) ::: (C)\nis_exception(is_sat(tests(Yuki, day1) == H)) ::: (D)\nis_exception(is_sat(tests(Yuki, day2) == H)) ::: (E)\n\n**Answer:** (D) Yuki tests H on the first day."
  },
  {
    "id": "ar_lsat_201110_2-G_3_16",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following CANNOT be true?",
    "options": [
      "A) Reynaldo tests G on the second day.",
      "B) Seamus tests F on the first day.",
      "C) Theresa tests F on the second day.",
      "D) Reynaldo tests H on the first day.",
      "E) Yuki tests F on the second day."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\ndays = EnumSort([day1, day2])\nbikes = EnumSort([F, G, H, J])\ntest = Function([riders, days] -> [bikes])\n\n# Constraints\nForAll([d:days], test(Reynaldo, d) != F) ::: Reynaldo cannot test F\nForAll([d:days], test(Yuki, d) != J) ::: Yuki cannot test J\nOr(test(Theresa, day1) == H, test(Theresa, day2) == H) ::: Theresa must test H on one day\ntest(Seamus, day2) == test(Yuki, day1) ::: Yuki's day1 bike is tested by Seamus on day2\nForAll([d:days], Distinct([r:riders], test(r, d))) ::: Each day, all bikes are tested once\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_invalid(test(Reynaldo, day2) == G) ::: (A)\nis_invalid(test(Seamus, day1) == F) ::: (B)\nis_invalid(test(Theresa, day2) == F) ::: (C)\nis_invalid(test(Reynaldo, day1) == H) ::: (D)\nis_invalid(test(Yuki, day2) == F) ::: (E)"
  },
  {
    "id": "ar_lsat_201110_2-G_3_17",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "If Theresa tests J on the first day, then which one of the following could be true?",
    "options": [
      "A) Reynaldo tests G on the second day.",
      "B) Seamus tests H on the first day.",
      "C) Yuki tests H on the second day.",
      "D) Seamus is one of the testers for J.",
      "E) Theresa is one of the testers for G."
    ],
    "answer": "B",
    "logic_program": "# Declarations  \nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])  \ndays = EnumSort([day1, day2])  \nbicycles = EnumSort([F, G, H, J])  \ntests = Function([riders, days] -> [bicycles])  \n\n# Constraints  \nForAll([r:riders], Distinct([d:days], tests(r, d))) ::: Each rider tests a different bicycle each day  \nForAll([d:days], Distinct([r:riders], tests(r, d))) ::: All bicycles are tested each day  \ntests(Reynaldo, day1) != F ::: Reynaldo cannot test F  \ntests(Reynaldo, day2) != F ::: Reynaldo cannot test F on any day  \ntests(Yuki, day1) != J ::: Yuki cannot test J  \ntests(Yuki, day2) != J ::: Yuki cannot test J  \nExists([d:days], tests(Theresa, d) == H) ::: Theresa must test H  \ntests(Yuki, day1) == tests(Seamus, day2) ::: Yuki's day1 bike is tested by Seamus on day2  \ntests(Theresa, day1) == J ::: Theresa tests J on the first day (given in question)  \n\n# Options  \nQuestion ::: If Theresa tests J on the first day, then which one of the following could be true?  \nis_sat(tests(Reynaldo, day2) == G) ::: (A)  \nis_sat(tests(Seamus, day1) == H) ::: (B)  \nis_sat(tests(Yuki, day2) == H) ::: (C)  \nis_sat(Or(tests(Seamus, day1) == J, tests(Seamus, day2) == J)) ::: (D)  \nis_sat(Or(tests(Theresa, day1) == G, tests(Theresa, day2) == G)) ::: (E)  \n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201110_2-G_3_18",
    "context": "On the first day of a two-day study for a cycling magazine, four riders\u00e2\u20ac\u201dReynaldo, Seamus, Theresa, and Yuki\u00e2\u20ac\u201dwill each test one of four bicycles\u00e2\u20ac\u201dF, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following CANNOT be true?",
    "options": [
      "A) Both Reynaldo and Seamus test J.",
      "B) Both Reynaldo and Theresa test J.",
      "C) Both Reynaldo and Yuki test G.",
      "D) Both Seamus and Theresa test G.",
      "E) Both Theresa and Yuki test F."
    ],
    "answer": "D",
    "logic_program": "**Declarations:**\n```python\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ndays = EnumSort([day1, day2])\ntests = Function([riders, days] -> [bicycles])\n```\n\n**Constraints:**\n```python\nForAll(d:days, tests(Reynaldo, d) != F) ::: Reynaldo cannot test F\nForAll(d:days, tests(Yuki, d) != J) ::: Yuki cannot test J\nOr(tests(Theresa, day1) == H, tests(Theresa, day2) == H) ::: Theresa must test H on at least one day\ntests(Yuki, day1) == tests(Seamus, day2) ::: Yuki's day1 bike is Seamus's day2 bike\nForAll(r:riders, tests(r, day1) != tests(r, day2)) ::: Each rider tests different bikes each day\nForAll(d:days, Distinct([r:riders], tests(r, d))) ::: All bikes tested each day\n```\n\n**Options:**\n```python\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists(m:days, tests(Reynaldo, m) == J & tests(Seamus, m) == J)) ::: (A)\nis_valid(Exists(m:days, tests(Reynaldo, m) == J & tests(Theresa, m) == J)) ::: (B)\nis_valid(Exists(m:days, tests(Reynaldo, m) == G & tests(Yuki, m) == G)) ::: (C)\nis_valid(Exists(m:days, tests(Seamus, m) == G & tests(Theresa, m) == G)) ::: (D)\nis_valid(Exists(m:days, tests(Theresa, m) == F & tests(Yuki, m) == F)) ::: (E)\n```\n\n**Answer:**\nThe correct answer is **(E) Both Theresa and Yuki test F**, as it's impossible due to constraints preventing both from testing F without violating other conditions."
  },
  {
    "id": "ar_lsat_201110_2-G_4_19",
    "context": "Exactly eight books\u00e2\u20ac\u201dF, G, H, I, K, L, M, O\u00e2\u20ac\u201dare placed on a bookcase with exactly three shelves\u00e2\u20ac\u201dthe top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "Which one of the following could be a complete and accurate list of the books placed on the bottom shelf?",
    "options": [
      "A) F, M",
      "B) F, H, M",
      "C) G, H, K",
      "D) F, G, M, O",
      "E) G, H, L, M"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\non = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], on(b) == s) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], on(b) == bottom) > Count([b:books], on(b) == top) ::: More of the books are placed on the bottom shelf than the top\non(I) == middle ::: I is placed on the middle shelf\non(K) < on(F) ::: K is placed on a higher shelf than F\non(O) < on(L) ::: O is placed on a higher shelf than L\non(F) == on(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the books placed on the bottom shelf?\nis_sat(And(ForAll([b:books], on(b) == bottom <=> Or(b == F, b == M)), Count([b:books], on(b) == bottom) == 2)) ::: (A)\nis_sat(And(ForAll([b:books], on(b) == bottom <=> Or(b == F, b == H, b == M)), Count([b:books], on(b) == bottom) == 3)) ::: (B)\nis_sat(And(ForAll([b:books], on(b) == bottom <=> Or(b == G, b == H, b == K)), Count([b:books], on(b) == bottom) == 3)) ::: (C)\nis_sat(And(ForAll([b:books], on(b) == bottom <=> Or(b == F, b == G, b == M, b == O)), Count([b:books], on(b) == bottom) == 4)) ::: (D)\nis_sat(And(ForAll([b:books], on(b) == bottom <=> Or(b == G, b == H, b == L, b == M)), Count([b:books], on(b) == bottom) == 4)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201110_2-G_4_20",
    "context": "Exactly eight books\u00e2\u20ac\u201dF, G, H, I, K, L, M, O\u00e2\u20ac\u201dare placed on a bookcase with exactly three shelves\u00e2\u20ac\u201dthe top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "It is fully determined which of the shelves each of the books is placed on if which one of the following is true?",
    "options": [
      "A) I and M are placed on the same shelf as each other.",
      "B) K and G are placed on the same shelf as each other.",
      "C) L and F are placed on the same shelf as each other.",
      "D) M and H are placed on the same shelf as each other.",
      "E) H and O are placed on the same shelf as each other."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201110_2-G_4_21",
    "context": "Exactly eight books\u00e2\u20ac\u201dF, G, H, I, K, L, M, O\u00e2\u20ac\u201dare placed on a bookcase with exactly three shelves\u00e2\u20ac\u201dthe top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) O is placed on a shelf higher than the shelf M is placed on.",
      "B) K is placed on a shelf higher than the shelf G is placed on.",
      "C) I is placed on a shelf higher than the shelf F is placed on.",
      "D) G is placed on a shelf higher than the shelf O is placed on.",
      "E) F is placed on a shelf higher than the shelf L is placed on."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nshelves = EnumSort([top, middle, bottom])\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nplaced_on = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], placed_on(b) == s) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed_on(b) == bottom) > Count([b:books], placed_on(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced_on(I) == middle ::: I is placed on the middle shelf\nplaced_on(K) < placed_on(F) ::: K is placed on a higher shelf than F\nplaced_on(O) < placed_on(L) ::: O is placed on a higher shelf than L\nplaced_on(F) == placed_on(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(placed_on(O) < placed_on(M)) ::: (A)\nis_valid(placed_on(K) < placed_on(G)) ::: (B)\nis_valid(placed_on(I) < placed_on(F)) ::: (C)\nis_valid(placed_on(G) < placed_on(O)) ::: (D)\nis_valid(placed_on(F) < placed_on(L)) ::: (E)"
  },
  {
    "id": "ar_lsat_201110_2-G_4_22",
    "context": "Exactly eight books\u00e2\u20ac\u201dF, G, H, I, K, L, M, O\u00e2\u20ac\u201dare placed on a bookcase with exactly three shelves\u00e2\u20ac\u201dthe top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "If G is placed on the top shelf, then which one of the following could be a complete and accurate list of the books placed on the middle shelf?",
    "options": [
      "A) H, I",
      "B) I, L",
      "C) H, I, L",
      "D) I, K, L",
      "E) F, I, M"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplacement = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], placement(b) == s) >= 2) ::: At least two books on each shelf\nCount([b:books], placement(b) == bottom) > Count([b:books], placement(b) == top) ::: More books on bottom than top\nplacement(I) == middle ::: I is placed on the middle shelf\nplacement(K) < placement(F) ::: K is on a higher shelf than F\nplacement(O) < placement(L) ::: O is on a higher shelf than L\nplacement(F) == placement(M) ::: F is on the same shelf as M\nplacement(G) == top ::: G is placed on the top shelf (given condition)\n\n# Options\nQuestion ::: If G is placed on the top shelf, which one of the following could be a complete and accurate list of the books placed on the middle shelf?\nis_sat(And(ForAll([b:books], Implies(placement(b) == middle, Or(b == H, b == I))), ForAll([b:books], Implies(Or(b == H, b == I), placement(b) == middle)))) ::: (A)\nis_sat(And(ForAll([b:books], Implies(placement(b) == middle, Or(b == I, b == L))), ForAll([b:books], Implies(Or(b == I, b == L), placement(b) == middle)))) ::: (B)\nis_sat(And(ForAll([b:books], Implies(placement(b) == middle, Or(b == H, b == I, b == L))), ForAll([b:books], Implies(Or(b == H, b == I, b == L), placement(b) == middle)))) ::: (C)\nis_sat(And(ForAll([b:books], Implies(placement(b) == middle, Or(b == I, b == K, b == L))), ForAll([b:books], Implies(Or(b == I, b == K, b == L), placement(b) == middle)))) ::: (D)\nis_sat(And(ForAll([b:books], Implies(placement(b) == middle, Or(b == F, b == I, b == M))), ForAll([b:books], Implies(Or(b == F, b == I, b == M), placement(b) == middle)))) ::: (E)\n\n**Answer:** (D) I, K, L"
  },
  {
    "id": "ar_lsat_201110_2-G_4_23",
    "context": "Exactly eight books\u00e2\u20ac\u201dF, G, H, I, K, L, M, O\u00e2\u20ac\u201dare placed on a bookcase with exactly three shelves\u00e2\u20ac\u201dthe top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "If L is placed on a shelf higher than the shelf H is placed on, then which one of the following must be true?",
    "options": [
      "A) F and G are placed on the same shelf as each other.",
      "B) G and H are placed on the same shelf as each other.",
      "C) H and M are placed on the same shelf as each other.",
      "D) I and G are placed on the same shelf as each other.",
      "E) K and O are placed on the same shelf as each other."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced_on = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], placed_on(b) == s) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed_on(b) == bottom) > Count([b:books], placed_on(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced_on(I) == middle ::: I is placed on the middle shelf\nplaced_on(K) < placed_on(F) ::: K is placed on a higher shelf than F\nplaced_on(O) < placed_on(L) ::: O is placed on a higher shelf than L\nplaced_on(F) == placed_on(M) ::: F is placed on the same shelf as M\nplaced_on(L) < placed_on(H) ::: L is placed on a shelf higher than the shelf H is placed on\n\n# Options\nQuestion ::: If L is placed on a shelf higher than the shelf H is placed on, then which one of the following must be true?\nis_valid(placed_on(F) == placed_on(G)) ::: (A)\nis_valid(placed_on(G) == placed_on(H)) ::: (B)\nis_valid(placed_on(H) == placed_on(M)) ::: (C)\nis_valid(placed_on(I) == placed_on(G)) ::: (D)\nis_valid(placed_on(K) == placed_on(O)) ::: (E)\n\n**Answer:** (C) H and M are placed on the same shelf as each other."
  },
  {
    "id": "ar_lsat_201206_3-G_1_1",
    "context": "A chemistry class has six lab sessions scheduled over three days\u00e2\u20ac\u201dWednesday, Thursday, and Friday\u00e2\u20ac\u201done session heing held each morning and one each afternoon. Each session will be led by a different lab assistant\u00e2\u20ac\u201dJulio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "Which one of the following could he an accurate assignment of lab assistants to morning and afternoon sessions, respectively, on the three days?",
    "options": [
      "A) Wednesday: Rebecca, Kevin Thursday: Julio, Lan Friday: Nessa, Olivia",
      "B) Wednesday: Olivia, Nessa Thursday: Julio, Lan Friday: Kevin, Rebecca",
      "C) Wednesday: Lan, Kevin Thursday: Rebecca, Julio Friday: Olivia, Nessa",
      "D) Wednesday: Kevin, Rebecca Thursday: Julio, Nessa Friday: Olivia, Lan",
      "E) Wednesday: Julio, Lan Thursday: Olivia, Nessa Friday: Rebecca, Kevin"
    ],
    "answer": "E",
    "logic_program": "# Declarations\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\nschedule = Function([days, times] -> [assistants])\n\n# Constraints\nAllDifferent([d:days, t:times], schedule(d, t)) ::: each session is led by a different lab assistant\nExists([d:days], ForAll([t:times], Or(schedule(d, t) == Kevin, schedule(d, t) == Rebecca))) ::: Kevin and Rebecca must lead sessions on the same day\nForAll([d:days], Not(Exists([t1:times, t2:times], And(schedule(d, t1) == Lan, schedule(d, t2) == Olivia)))) ::: Lan and Olivia cannot lead sessions on the same day\nForAll([d:days], schedule(d, afternoon) != Nessa) ::: Nessa must lead an afternoon session (corrected to check afternoon assignment)\nExists([d1:days, d2:days], And(d1 < d2, schedule(d1, morning) == Julio, schedule(d2, morning) == Olivia)) ::: Julio's session is earlier than Olivia's\n\n# Options\nQuestion ::: Which one of the following could be an accurate assignment?\nis_valid(\n  schedule(Wednesday, morning) == Rebecca,\n  schedule(Wednesday, afternoon) == Kevin,\n  schedule(Thursday, morning) == Julio,\n  schedule(Thursday, afternoon) == Lan,\n  schedule(Friday, morning) == Nessa,\n  schedule(Friday, afternoon) == Olivia\n) ::: (A)\nis_valid(\n  schedule(Wednesday, morning) == Olivia,\n  schedule(Wednesday, afternoon) == Nessa,\n  schedule(Thursday, morning) == Julio,\n  schedule(Thursday, afternoon) == Lan,\n  schedule(Friday, morning) == Kevin,\n  schedule(Friday, afternoon) == Rebecca\n) ::: (B)\nis_valid(\n  schedule(Wednesday, morning) == Lan,\n  schedule(Wednesday, afternoon) == Kevin,\n  schedule(Thursday, morning) == Rebecca,\n  schedule(Thursday, afternoon) == Julio,\n  schedule(Friday, morning) == Olivia,\n  schedule(Friday, afternoon) == Nessa\n) ::: (C)\nis_valid(\n  schedule(Wednesday, morning) == Kevin,\n  schedule(Wednesday, afternoon) == Rebecca,\n  schedule(Thursday, morning) == Julio,\n  schedule(Thursday, afternoon) == Nessa,\n  schedule(Friday, morning) == Olivia,\n  schedule(Friday, afternoon) == Lan\n) ::: (D)\nis_valid(\n  schedule(Wednesday, morning) == Julio,\n  schedule(Wednesday, afternoon) == Lan,\n  schedule(Thursday, morning) == Olivia,\n  schedule(Thursday, afternoon) == Nessa,\n  schedule(Friday, morning) == Rebecca,\n  schedule(Friday, afternoon) == Kevin\n) ::: (E)\n\n**Answer:** (E)"
  },
  {
    "id": "ar_lsat_201206_3-G_1_2",
    "context": "A chemistry class has six lab sessions scheduled over three days\u00e2\u20ac\u201dWednesday, Thursday, and Friday\u00e2\u20ac\u201done session heing held each morning and one each afternoon. Each session will be led by a different lab assistant\u00e2\u20ac\u201dJulio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Lan does not lead a Wednesday session, then which one of the following lab assistants must lead a Thursday session?",
    "options": [
      "A) Rebecca",
      "B) Olivia",
      "C) Nessa",
      "D) Kevin",
      "E) Julio"
    ],
    "answer": "E",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_1_3",
    "context": "A chemistry class has six lab sessions scheduled over three days\u00e2\u20ac\u201dWednesday, Thursday, and Friday\u00e2\u20ac\u201done session heing held each morning and one each afternoon. Each session will be led by a different lab assistant\u00e2\u20ac\u201dJulio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Kevin's session meets on the day before Nessa's, then which one of the following is a complete and accurate list of lab assistants any one of whom could lead the Thursday afternoon session?",
    "options": [
      "A) Julio, Nessa",
      "B) Kevin, Rebecca",
      "C) Kevin, Nessa, Rebecca",
      "D) Julio, Kevin, Nessa, Rebecca",
      "E) Julio, Kevin, Lan, Nessa, Rebecca"
    ],
    "answer": "B",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_1_4",
    "context": "A chemistry class has six lab sessions scheduled over three days\u00e2\u20ac\u201dWednesday, Thursday, and Friday\u00e2\u20ac\u201done session heing held each morning and one each afternoon. Each session will be led by a different lab assistant\u00e2\u20ac\u201dJulio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Julio and Kevin both lead morning sessions, then any of the following could be true EXCEPT:",
    "options": [
      "A) Lan's session meets Wednesday morning.",
      "B) Lan's session meets Thursday afternoon.",
      "C) Nessa's session meets Friday afternoon.",
      "D) Olivia's session meets Thursday morning.",
      "E) Olivia's session meets Friday morning."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_1_5",
    "context": "A chemistry class has six lab sessions scheduled over three days\u00e2\u20ac\u201dWednesday, Thursday, and Friday\u00e2\u20ac\u201done session heing held each morning and one each afternoon. Each session will be led by a different lab assistant\u00e2\u20ac\u201dJulio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Julio leads the Thursday afternoon session, then for how many of the other lab assistants can one determine which sessions they lead?",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "answer": "C",
    "logic_program": "# Declarations\ndays = EnumSort([Wednesday, Thursday, Friday])\nsessions = EnumSort([morning, afternoon])\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\nassigned = Function([assistants] -> [days, sessions])\n\n# Constraints\nDistinct([a:assistants], assigned(a)) ::: Each session is led by a different lab assistant\nAnd(assigned(Kevin)::day == assigned(Rebecca)::day) ::: Kevin and Rebecca must lead sessions on the same day\nassigned(Lan)::day != assigned(Olivia)::day ::: Lan and Olivia cannot lead sessions on the same day\nassigned(Nessa)::session == afternoon ::: Nessa must lead an afternoon session\nassigned(Julio)::day < assigned(Olivia)::day ::: Julio's session is earlier than Olivia's\n\n# Additional constraint from the question scenario\nassigned(Julio) == (Thursday, afternoon) ::: Julio leads Thursday afternoon session\n\n# Options\nQuestion ::: If Julio leads the Thursday afternoon session, then for how many of the other lab assistants can one determine which sessions they lead?\ncount_determined = Count([a:assistants where a != Julio], IsFixed(assigned(a)))\ncount_determined == 1 ::: (A)\ncount_determined == 2 ::: (B)\ncount_determined == 3 ::: (C)\ncount_determined == 4 ::: (D)\ncount_determined == 5 ::: (E)\n\n**Answer ( (C) three\n\nThe constraints fix assignments for Lan (Thursday morning), Olivia (Friday morning), and Nessa (Friday afternoon). Kevin and Rebecca are constrained to Wednesday but their morning/afternoon order isn't determined. Thus, three assistants (Lan, Olivia, Nessa) have fully determined sessions."
  },
  {
    "id": "ar_lsat_201206_3-G_2_6",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "Which one of the following could be the order of the businesses in spaces 1 through 7 respectively?",
    "options": [
      "A) pharmacy, optometrist, shoe store, restaurant, veterinarian, toy store, restaurant",
      "B) pharmacy, veterinarian, optometrist, shoe store, restaurant, toy store, restaurant",
      "C) restaurant, shoe store, veterinarian, pharmacy, optometrist, toy store, restaurant",
      "D) restaurant, toy store, optometrist, restaurant, veterinarian, shoe store, pharmacy",
      "E) restaurant, optometrist, toy store, restaurant, shoe store, veterinarian, pharmacy"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nassign = Function([spaces] -> [businesses])\n\n# Constraints\nDistinct([s:spaces], assign(s)) ::: Each business in a unique space\nOr(And(assign(1) == pharmacy, assign(7) == restaurant1), And(assign(1) == restaurant1, assign(7) == pharmacy)) ::: Pharmacy at one end, restaurant at the other\nForAll([s1:spaces, s2:spaces], Implies(And(Or(assign(s1) == restaurant1, assign(s1) == restaurant2), Or(assign(s2) == restaurant1, assign(s2) == restaurant2), s1 != s2), Abs(s1 - s2) > 2)) ::: Restaurants separated by at least two businesses\nOr(And(assign(1) == pharmacy, Or(assign(2) == optometrist, assign(2) == veterinarian)), And(assign(7) == pharmacy, Or(assign(6) == optometrist, assign(6) == veterinarian))) ::: Pharmacy next to optometrist or veterinarian\nForAll([s:spaces], Implies(assign(s) == veterinarian, And(assign(s-1) != toy_store, assign(s+1) != toy_store))) ::: Toy store not next to veterinarian\n\n# Options\nQuestion ::: Which one of the following could be the order of the businesses in spaces 1 through 7 respectively?\nis_sat(assign(1) == pharmacy, assign(2) == optometrist, assign(3) == shoe_store, assign(4) == restaurant1, assign(5) == veterinarian, assign(6) == toy_store, assign(7) == restaurant2) ::: (A)\nis_sat(assign(1) == pharmacy, assign(2) == veterinarian, assign(3) == optometrist, assign(4) == shoe_store, assign(5) == restaurant1, assign(6) == toy_store, assign(7) == restaurant2) ::: (B)\nis_sat(assign(1) == restaurant1, assign(2) == shoe_store, assign(3) == veterinarian, assign(4) == pharmacy, assign(5) == optometrist, assign(6) == toy_store, assign(7) == restaurant2) ::: (C)\nis_sat(assign(1) == restaurant1, assign(2) == toy_store, assign(3) == optometrist, assign(4) == restaurant2, assign(5) == veterinarian, assign(6) == shoe_store, assign(7) == pharmacy) ::: (D)\nis_sat(assign(1) == restaurant1, assign(2) == optometrist, assign(3) == toy_store, assign(4) == restaurant2, assign(5) == shoe_store, assign(6) == veterinarian, assign(7) == pharmacy) ::: (E)\n\n**Answer:** (E)"
  },
  {
    "id": "ar_lsat_201206_3-G_2_7",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the shoe store is in space 2, which one of the following could be true?",
    "options": [
      "A) The optometrist is in space 5.",
      "B) The pharmacy is in space 1.",
      "C) A restaurant is in space 3.",
      "D) The toy store is in space 6.",
      "E) The veterinarian is in space 4."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_2_8",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the veterinarian is in space 5, which one of the following must be true?",
    "options": [
      "A) The optometrist is in space 2.",
      "B) The pharmacy is in space 7.",
      "C) A restaurant is in space 4.",
      "D) The shoe store is in space 6.",
      "E) The toy store is in space 3."
    ],
    "answer": "C",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_2_9",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the optometrist is next to the shoe store, the businesses immediately on either side of this pair must be",
    "options": [
      "A) the pharmacy and a restaurant",
      "B) the pharmacy and the toy store",
      "C) the two restaurants",
      "D) a restaurant and the toy store",
      "E) a restaurant and the veterinarian"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nassigned = Function([spaces] -> [businesses])\n\n# Constraints\nDistinct([s:spaces], assigned(s)) ::: Each business occupies one space\nOr(assigned(1) == pharmacy, assigned(7) == pharmacy) ::: Pharmacy at one end\nOr(assigned(1) == restaurant1, assigned(1) == restaurant2, assigned(7) == restaurant1, assigned(7) == restaurant2) ::: One restaurant at the other end\nForAll([s:spaces], Implies(Or(assigned(s) == restaurant1, assigned(s) == restaurant2), \n    ForAll([t:spaces], Implies(Or(assigned(t) == restaurant1, assigned(t) == restaurant2), \n        Abs(s - t) >= 3)))) ::: Restaurants separated by at least two businesses\nForAll([s:spaces], Implies(Or(s == 1, s == 7), \n    Or(assigned(s+1 if s==1 else s-1) == optometrist, \n       assigned(s+1 if s==1 else s-1) == veterinarian))) ::: Pharmacy next to optometrist or vet\nForAll([s:spaces], Implies(assigned(s) == toy_store, \n    And(assigned(s-1) != veterinarian if s>1 else True, \n        assigned(s+1) != veterinarian if s<7 else True))) ::: Toy store not next to vet\n\n# Additional condition for the question\nExists([s:spaces], Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store), \n                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist))) ::: Optometrist next to shoe store\n\n# Options\nQuestion ::: If the optometrist is next to the shoe store, the businesses immediately on either side of this pair must be\nis_valid(ForAll([s:spaces], Implies(Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store),\n                                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist)),\n                                  Or(And(assigned(s-1) == pharmacy, assigned(s+2) == restaurant1),\n                                     And(assigned(s-1) == pharmacy, assigned(s+2) == restaurant2),\n                                     And(assigned(s+2) == pharmacy, assigned(s-1) == restaurant1),\n                                     And(assigned(s+2) == pharmacy, assigned(s-1) == restaurant2))))) ::: (A)\nis_valid(ForAll([s:spaces], Implies(Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store),\n                                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist)),\n                                  Or(And(assigned(s-1) == pharmacy, assigned(s+2) == toy_store),\n                                     And(assigned(s+2) == pharmacy, assigned(s-1) == toy_store))))) ::: (B)\nis_valid(ForAll([s:spaces], Implies(Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store),\n                                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist)),\n                                  And(assigned(s-1) == restaurant1, assigned(s+2) == restaurant2)))) ::: (C)\nis_valid(ForAll([s:spaces], Implies(Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store),\n                                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist)),\n                                  Or(And(assigned(s-1) == restaurant1, assigned(s+2) == toy_store),\n                                     And(assigned(s-1) == restaurant2, assigned(s+2) == toy_store),\n                                     And(assigned(s+2) == restaurant1, assigned(s-1) == toy_store),\n                                     And(assigned(s+2) == restaurant2, assigned(s-1) == toy_store))))) ::: (D)\nis_valid(ForAll([s:spaces], Implies(Or(And(assigned(s) == optometrist, assigned(s+1) == shoe_store),\n                                      And(assigned(s) == shoe_store, assigned(s+1) == optometrist)),\n                                  Or(And(assigned(s-1) == restaurant1, assigned(s+2) == veterinarian),\n                                     And(assigned(s-1) == restaurant2, assigned(s+2) == veterinarian),\n                                     And(assigned(s+2) == restaurant1, assigned(s-1) == veterinarian),\n                                     And(assigned(s+2) == restaurant2, assigned(s-1) == veterinarian))))) ::: (E)\n\n**Answer**\n(D) a restaurant and the toy store"
  },
  {
    "id": "ar_lsat_201206_3-G_2_10",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the shoe store is in space 4, which one of the following must be true?",
    "options": [
      "A) The optometrist is next to a restaurant.",
      "B) The pharmacy is next to the veterinarian.",
      "C) A restaurant is next to the toy store.",
      "D) The shoe store is next to the toy store.",
      "E) The shoe store is next to the veterinarian."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nDistinct([b:businesses], located(b)) ::: Each business is in a distinct space\nlocated(shoe_store) == 4 ::: Shoe store is in space 4\nOr(And(located(pharmacy) == 1, located(restaurant1) == 7), And(located(pharmacy) == 7, located(restaurant1) == 1)) ::: Pharmacy at one end, restaurant at the other\nAbs(located(restaurant1) - located(restaurant2)) >= 3 ::: Restaurants separated by at least two businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: Pharmacy next to optometrist or veterinarian\nForAll([s:spaces], Implies(Or(s == located(toy_store)+1, s == located(toy_store)-1), Not(s == located(veterinarian)))) ::: Toy store not next to veterinarian\n\n# Options\nQuestion ::: If the shoe store is in space 4, which one of the following must be true?\nis_valid(Exists([s:spaces], And(Or(s == located(optometrist)+1, s == located(optometrist)-1), Or(s == located(restaurant1), s == located(restaurant2))))) ::: (A)\nis_valid(Or(Abs(located(pharmacy) - located(veterinarian)) == 1)) ::: (B)\nis_valid(Exists([s:spaces], And(Or(s == located(toy_store)+1, s == located(toy_store)-1), Or(s == located(restaurant1), s == located(restaurant2))))) ::: (C)\nis_valid(Or(Abs(located(shoe_store) - located(toy_store)) == 1)) ::: (D)\nis_valid(Or(Abs(located(shoe_store) - located(veterinarian)) == 1)) ::: (E)\n\n**Answer:** (B) The pharmacy is next to the veterinarian."
  },
  {
    "id": "ar_lsat_201206_3-G_2_11",
    "context": "A shopping center has exactly seven spaces\u00e2\u20ac\u201dspace 1 through space 7\u00e2\u20ac\u201darranged in a straight row. Seven businesses\u00e2\u20ac\u201dan optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian\u00e2\u20ac\u201dwill be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "Which one of the following, if substituted for the constraint that the two restaurants must be separated by at least two other businesses, would have the same effect in determining the locations of the businesses?",
    "options": [
      "A) A restaurant must be in either space 3, space 4, or space 5.",
      "B) A restaurant must be next to either the optometrist or the veterinarian.",
      "C) Either the toy store or the veterinarian must be somewhere between the two restaurants.",
      "D) No more than two businesses can separate the pharmacy and the restaurant nearest it.",
      "E) The optometrist cannot be next to the shoe store."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlocation = Function([businesses] -> [spaces])\n\n# Constraints\nAllDifferent([b:businesses], location(b)) ::: each business is in a unique space\nlocation(pharmacy) == 1 | location(pharmacy) == 7 ::: pharmacy at one end\nlocation(restaurant1) == 1 | location(restaurant1) == 7 ::: one restaurant at the other end\nlocation(restaurant2) != 1, location(restaurant2) != 7 ::: other restaurant not at ends (original constraint)\nAbs(location(restaurant1) - location(restaurant2)) >= 3 ::: original constraint: separated by at least two businesses\nlocation(pharmacy) == 1 => (location(restaurant1) == 7 | location(restaurant2) == 7) ::: one restaurant at each end\n\n# Options\nQuestion ::: Which substitution has the same effect?\nis_equivalent(ForAll([r1, r2:restaurants], Exists([m:machines], Between(r1, m, r2) & (m == toy_store | m == veterinarian)))) ::: (C)"
  },
  {
    "id": "ar_lsat_201206_3-G_3_12",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following could be an accurate matching of the sales representatives to the sales zones in which they work?",
    "options": [
      "A) Zone 1: Kim, Parra Zone 2: Stuckey, Udall Zone 3: Mahr, Quinn, Tiao",
      "B) Zone 1: Kim, Tiao Zone 2: Stuckey, Udall Zone 3: Mahr, Parra, Quinn",
      "C) Zone 1: Parra, Quinn Zone 2: Kim, Udall Zone 3: Mahr, Stuckey, Tiao",
      "D) Zone 1: Stuckey, Udall Zone 2: Kim, Tiao Zone 3: Mahr, Parra, Quinn",
      "E) Zone 1: Tiao Zone 2: Kim, Parra, Quinn Zone 3: Stuckey, Udall"
    ],
    "answer": "B",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nassign = Function([technicians] -> [zones])\n\n# Constraints\nExactlyOne([assign(Parra) == Zone1, assign(Tiao) == Zone1]) ::: Either Parra or Tiao (but not both) works in Zone 1\nExactlyOne([assign(Tiao) == Zone2, assign(Udall) == Zone2]) ::: Either Tiao or Udall (but not both) works in Zone 2\nassign(Parra) == assign(Quinn) ::: Parra and Quinn work in the same sales zone\nassign(Stuckey) == assign(Udall) ::: Stuckey and Udall work in the same sales zone\nCount([t:technicians], assign(t) == Zone3) > Count([t:technicians], assign(t) == Zone2) ::: More representatives in Zone 3 than Zone 2\n\n# Options\nQuestion ::: Which one of the following could be an accurate matching of the sales representatives to the sales zones in which they work?\nis_sat(\n    And(\n        assign(Kim) == Zone1,\n        assign(Parra) == Zone1,\n        assign(Stuckey) == Zone2,\n        assign(Udall) == Zone2,\n        assign(Mahr) == Zone3,\n        assign(Quinn) == Zone3,\n        assign(Tiao) == Zone3\n    )\n) ::: (A)\nis_sat(\n    And(\n        assign(Kim) == Zone1,\n        assign(Tiao) == Zone1,\n        assign(Stuckey) == Zone2,\n        assign(Udall) == Zone2,\n        assign(Mahr) == Zone3,\n        assign(Parra) == Zone3,\n        assign(Quinn) == Zone3\n    )\n) ::: (B)\nis_sat(\n    And(\n        assign(Parra) == Zone1,\n        assign(Quinn) == Zone1,\n        assign(Kim) == Zone2,\n        assign(Udall) == Zone2,\n        assign(Mahr) == Zone3,\n        assign(Stuckey) == Zone3,\n        assign(Tiao) == Zone3\n    )\n) ::: (C)\nis_sat(\n    And(\n        assign(Stuckey) == Zone1,\n        assign(Udall) == Zone1,\n        assign(Kim) == Zone2,\n        assign(Tiao) == Zone2,\n        assign(Mahr) == Zone3,\n        assign(Parra) == Zone3,\n        assign(Quinn) == Zone3\n    )\n) ::: (D)\nis_sat(\n    And(\n        assign(Tiao) == Zone1,\n        assign(Kim) == Zone2,\n        assign(Parra) == Zone2,\n        assign(Quinn) == Zone2,\n        assign(Stuckey) == Zone3,\n        assign(Udall) == Zone3\n    )\n) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201206_3-G_3_13",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "If more sales representatives work in Zone 1 than in Zone 3, then which one of the following could be true?",
    "options": [
      "A) Kim works in Zone 2.",
      "B) Mahr works in Zone 2.",
      "C) Parra works in Zone 3.",
      "D) Tiao works in Zone 1.",
      "E) Udall works in Zone 3."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nreps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])  \nzones = EnumSort([Zone1, Zone2, Zone3])  \nworks_in = Function([reps] -> [zones])  \n\n# Constraints  \nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1  \nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2  \nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone  \nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone  \nCount([r:reps], works_in(r) == Zone3) > Count([r:reps], works_in(r) == Zone2) ::: More reps in Zone 3 than Zone 2  \nCount([r:reps], works_in(r) == Zone1) > Count([r:reps], works_in(r) == Zone3) ::: Additional constraint for the question: More reps in Zone 1 than Zone 3  \n\n# Options  \nQuestion ::: If more sales representatives work in Zone 1 than in Zone 3, then which one of the following could be true?  \nis_sat(works_in(Kim) == Zone2) ::: (A)  \nis_sat(works_in(Mahr) == Zone2) ::: (B)  \nis_sat(works_in(Parra) == Zone3) ::: (C)  \nis_sat(works_in(Tiao) == Zone1) ::: (D)  \nis_sat(works_in(Udall) == Zone3) ::: (E)  \n\n**Answer:**  \n(E)"
  },
  {
    "id": "ar_lsat_201206_3-G_3_14",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following must be false?",
    "options": [
      "A) Kim and Stuckey both work in Zone 1.",
      "B) Kim and Stuckey both work in Zone 3.",
      "C) Mahr and Stuckey both work in Zone 3.",
      "D) Mahr and Udall both work in Zone 3.",
      "E) Parra and Stuckey both work in Zone I."
    ],
    "answer": "A",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([technicians] -> [zones])\n\n# Constraints\nExactlyOne([works_in(Parra) == Zone1, works_in(Tiao) == Zone1]) ::: Either Parra or Tiao (but not both) works in Zone 1\nExactlyOne([works_in(Tiao) == Zone2, works_in(Udall) == Zone2]) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone\nCount([t:technicians], works_in(t) == Zone3) > Count([t:technicians], works_in(t) == Zone2) ::: More representatives in Zone 3 than Zone 2\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_invalid(works_in(Stacy) == works_in(Urma)) ::: (A)  # Note: Stacy should be Kim here, but original problem uses correct names\nis_invalid(And(works_in(Kim) == Zone1, works_in(Stuckey) == Zone1)) ::: (A)\nis_invalid(And(works_in(Kim) == Zone3, works_in(Stuckey) == Zone3)) ::: (B)\nis_invalid(And(works_in(Mahr) == Zone3, works_in(Stuckey) == Zone3)) ::: (C)\nis_invalid(And(works_in(Mahr) == Zone3, works_in(Udall) == Zone3)) ::: (D)\nis_invalid(And(works_in(Parra) == Zone1, works_in(Stuckey) == Zone1)) ::: (E)\n\n**Answer:** (E) Parra and Stuckey both work in Zone I."
  },
  {
    "id": "ar_lsat_201206_3-G_3_15",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following could be a complete and accurate list of the sales representatives working in Zone 3?",
    "options": [
      "A) Kim, Mahr",
      "B) Kim, Tiao",
      "C) Parra, Quinn",
      "D) Stuckey, Tiao, Udall",
      "E) Parra, Quinn, Stuckey, Udall"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nzone = Function([technicians] -> [zones])\n\n# Constraints\nOr(And(zone(Parra) == Zone1, zone(Tiao) != Zone1), And(zone(Parra) != Zone1, zone(Tiao) == Zone1)) ::: Either Parra or Tiao (but not both) works in Zone 1\nOr(And(zone(Tiao) == Zone2, zone(Udall) != Zone2), And(zone(Tiao) != Zone2, zone(Udall) == Zone2)) ::: Either Tiao or Udall (but not both) works in Zone 2\nzone(Parra) == zone(Quinn) ::: Parra and Quinn work in the same sales zone\nzone(Stuckey) == zone(Udall) ::: Stuckey and Udall work in the same sales zone\nCount([t:technicians], zone(t) == Zone3) > Count([t:technicians], zone(t) == Zone2) ::: More sales representatives in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the sales representatives working in Zone 3?\nis_sat(ForAll([t:technicians], zone(t) == Zone3 == (t == Kim Or t == Mahr))) ::: (A)\nis_sat(ForAll([t:technicians], zone(t) == Zone3 == (t == Kim Or t == Tiao))) ::: (B)\nis_sat(ForAll([t:technicians], zone(t) == Zone3 == (t == Parra Or t == Quinn))) ::: (C)\nis_sat(ForAll([t:technicians], zone(t) == Zone3 == (t == Stuckey Or t == Tiao Or t == Udall))) ::: (D)\nis_sat(ForAll([t:technicians], zone(t) == Zone3 == (t == Parra Or t == Quinn Or t == Stuckey Or t == Udall))) ::: (E)"
  },
  {
    "id": "ar_lsat_201206_3-G_3_16",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Quinn CANNOT work in the same sales zone as which one of the following?",
    "options": [
      "A) Kim",
      "B) Mahr",
      "C) Stuckey",
      "D) Tiao",
      "E) Udall"
    ],
    "answer": "D",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([technicians] -> [zones])\n\n# Constraints\nExactlyOne({works_in(Parra) == Zone1, works_in(Tiao) == Zone1}) ::: Either Parra or Tiao (but not both) works in Zone 1\nExactlyOne({works_in(Tiao) == Zone2, works_in(Udall) == Zone2}) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone\nCount([t:technicians], works_in(t) == Zone3) > Count([t:technicians], works_in(t) == Zone2) ::: More representatives in Zone 3 than Zone 2\n\n# Options\nQuestion ::: Quinn CANNOT work in the same sales zone as which one of the following?\nis_valid(works_in(Quinn) == works_in(Kim)) ::: (A)\nis_valid(works_in(Quinn) == works_in(Mahr)) ::: (B)\nis_valid(works_in(Quinn) == works_in(Stuckey)) ::: (C)\nis_valid(works_in(Quinn) == works_in(Tiao)) ::: (D)\nis_valid(works_in(Quinn) == works_in(Udall)) ::: (E)\n\n**Answer:** (C) Stuckey"
  },
  {
    "id": "ar_lsat_201206_3-G_3_17",
    "context": "A software company employs exactly seven sales representatives\u00e2\u20ac\u201dKim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall\u00e2\u20ac\u201dto work in its three sales zones\u00e2\u20ac\u201dZone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "If Mahr and Stuckey work in the same sales zone, then which one of the following could be true?",
    "options": [
      "A) Kim works in Zone 2.",
      "B) Mahr works in Zone 1.",
      "C) Parra works in Zone 3.",
      "D) Stuckey works in Zone 2.",
      "E) Tiao works in Zone 1."
    ],
    "answer": "A",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n---\n\n**Step-by-Step Explanation:**\n\n1. **Declarations:**  \n   - `technicians` and `machines` are enumerated types.  \n   - `repairs` is a function mapping each technician-machine pair to a boolean (indicating if the technician repairs that machine type).\n\n2. **Constraints:**  \n   - **Radio Repairers:** Xena and exactly three others repair radios.  \n   - **Yolanda\u2019s Expertise:** Repairs both TVs and VCRs.  \n   - **Stacy\u2019s Restriction:** Avoids any machine type Yolanda repairs.  \n   - **Zane\u2019s Superiority:** Repairs more types than Yolanda (who repairs 2).  \n   - **Wim\u2019s Avoidance:** Doesn\u2019t repair any type Stacy does.  \n   - **Urma\u2019s Limit:** Repairs exactly two machine types.  \n\n3. **Options Analysis:**  \n   - **(A) Stacy & Urma:** Impossible since Stacy avoids TVs/VCRs (Yolanda\u2019s), but Urma must repair two types (could include TVs/VCRs).  \n   - **(B) Urma & Yolanda:** Yolanda repairs two types; Urma must also repair two. However, Urma could share Yolanda\u2019s types (TVs/VCRs), but Stacy\u2019s constraint doesn\u2019t block Urma.  \n   - **(C) Urma & Xena:** Xena repairs radios. Urma\u2019s two types could include radios + one more (e.g., TVs), feasible.  \n   - **(D) Wim & Xena:** Wim avoids Stacy\u2019s types. If Stacy repairs radios (allowed), Wim can\u2019t, conflicting with Xena\u2019s radio repair.  \n   - **(E) Xena & Yolanda:** Xena repairs radios; Yolanda doesn\u2019t. Impossible.  \n\n**Answer:** (D) Wim and Xena cannot share all repairs (due to radio conflict), but the question asks for **could** be true. However, the correct answer is **(D)** based on the problem's constraints."
  },
  {
    "id": "ar_lsat_201206_3-G_4_18",
    "context": "During a recital, two pianists\u00e2\u20ac\u201dWayne and Zara\u00e2\u20ac\u201dwill perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "Which one of the following could be all of the solos that are traditional pieces?",
    "options": [
      "A) the first, third, and fourth",
      "B) the second, third, and fourth",
      "C) the third and fourth",
      "D) the third and fifth",
      "E) the fourth and fifth"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nsolos = EnumSort([1, 2, 3, 4, 5])\npianists = EnumSort([Wayne, Zara])\ntypes = EnumSort([modern, traditional])\nsolo_type = Function([solos] -> [types])\nperformed_by = Function([solos] -> [pianists])\n\n# Constraints\nsolo_type(3) == traditional ::: The third solo is a traditional piece\nExactlyTwoConsecutiveTraditional = Exists([s: solos], And(solo_type(s) == traditional, solo_type(s+1) == traditional)) ::: Exactly two of the traditional pieces are performed consecutively\nForAll([s: solos], Implies(solo_type(s) == traditional, Count([s2: solos], And(s2 < s, performed_by(s2) == Wayne, solo_type(s2) == modern)) >= 1)) ::: No traditional piece until Wayne performs at least one modern\nImplies(performed_by(4) == Wayne, solo_type(4) == traditional) ::: Fourth solo: Wayne performs traditional\nImplies(performed_by(4) == Zara, solo_type(4) == modern) ::: Fourth solo: Zara performs modern\nperformed_by(2) != performed_by(5) ::: Second and fifth solos have different pianists\n\n# Options\nQuestion ::: Which one of the following could be all of the solos that are traditional pieces?\nis_sat(And(solo_type(1) == traditional, solo_type(3) == traditional, solo_type(4) == traditional)) ::: (A)\nis_sat(And(solo_type(2) == traditional, solo_type(3) == traditional, solo_type(4) == traditional)) ::: (B)\nis_sat(And(solo_type(3) == traditional, solo_type(4) == traditional)) ::: (C)\nis_sat(And(solo_type(3) == traditional, solo_type(5) == traditional)) ::: (D)\nis_sat(And(solo_type(4) == traditional, solo_type(5) == traditional)) ::: (E)"
  },
  {
    "id": "ar_lsat_201206_3-G_4_19",
    "context": "During a recital, two pianists\u00e2\u20ac\u201dWayne and Zara\u00e2\u20ac\u201dwill perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "What is the minimum number of solos in which Wayne performs a traditional piece?",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "answer": "A",
    "logic_program": "# Declarations  \nsolos = EnumSort([1, 2, 3, 4, 5])  \npianists = EnumSort([Wayne, Zara])  \ntypes = EnumSort([modern, traditional])  \nperform = Function([solos] -> [pianists])  \npiece = Function([solos] -> [types])  \n\n# Constraints  \npiece(3) == traditional ::: The third solo is a traditional piece  \nExactlyTwoConsecutiveTrad() ::: Exactly two of the traditional pieces are performed consecutively  \nOr(And(perform(4) == Wayne, piece(4) == traditional), And(perform(4) == Zara, piece(4) == modern)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece  \nperform(5) != perform(2) ::: The pianist who performs the second solo does not perform the fifth solo  \nForAll([s:solos], Implies(piece(s) == traditional, Exists([s_prev:solos], And(s_prev < s, perform(s_prev) == Wayne, piece(s_prev) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modern piece  \n\n# Options  \nQuestion ::: What is the minimum number of solos in which Wayne performs a traditional piece?  \nis_valid(Count([s:solos], And(perform(s) == Wayne, piece(s) == traditional)) == 0) ::: (A)  \nis_valid(Count([s:solos], And(perform(s) == Wayne, piece(s) == traditional)) == 1) ::: (B)  \nis_valid(Count([s:solos], And(perform(s) == Wayne, piece(s) == traditional)) == 2) ::: (C)  \nis_valid(Count([s:solos], And(perform(s) == Wayne, piece(s) == traditional)) == 3) ::: (D)  \nis_valid(Count([s:solos], And(perform(s) == Wayne, piece(s) == traditional)) == 4) ::: (E)  \n\n**Answer:** (B) one  \n\n**Explanation:**  \nThe constraints necessitate that Wayne must perform at least one traditional piece. The scenario where Wayne has zero traditional pieces violates the requirement that the fourth solo must be traditional if performed by Wayne or modern if by Zara. Ensuring all constraints are met, the minimum number of traditional pieces Wayne must perform is one."
  },
  {
    "id": "ar_lsat_201206_3-G_4_20",
    "context": "During a recital, two pianists\u00e2\u20ac\u201dWayne and Zara\u00e2\u20ac\u201dwill perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If the pianist who performs the first solo also performs the second solo, then which one of the following must be true?",
    "options": [
      "A) Zara performs the first solo.",
      "B) Wayne performs the third solo.",
      "C) Zara performs the fifth solo.",
      "D) The second solo is a traditional piece.",
      "E) The fourth solo is a modem piece."
    ],
    "answer": "C",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201206_3-G_4_21",
    "context": "During a recital, two pianists\u00e2\u20ac\u201dWayne and Zara\u00e2\u20ac\u201dwill perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If the fifth solo is a traditional piece, then for exactly determined?",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "answer": "B",
    "logic_program": "# Declarations\npeople = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\ntypes = EnumSort([modern, traditional])\npiece_type = Function([solos] -> [types])\npianist = Function([solos] -> [people])\n\n# Constraints\npiece_type(3) == traditional ::: The third solo is a traditional piece\nExactlyOnePairConsecutive(traditional, solos, piece_type) ::: Exactly two of the traditional pieces are performed consecutively\nOr(And(pianist(4) == Wayne, piece_type(4) == traditional), And(pianist(4) == Zara, piece_type(4) == modern)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\npianist(2) != pianist(5) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(piece_type(s) == traditional, Exists([s_prev:solos], And(s_prev < s, pianist(s_prev) == Wayne, piece_type(s_prev) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modern piece\npiece_type(5) == traditional ::: If the fifth solo is a traditional piece (given in the question)\n\n# Options\nQuestion ::: If the fifth solo is a traditional piece, then for exactly how many solos can the type be determined?\nis_determined_count([s:solos], piece_type(s), 5) ::: (E) five"
  },
  {
    "id": "ar_lsat_201206_3-G_4_22",
    "context": "During a recital, two pianists\u00e2\u20ac\u201dWayne and Zara\u00e2\u20ac\u201dwill perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If in the fifth solo Wayne performs a traditional piece, which one of the following could be true?",
    "options": [
      "A) Zara performs the first solo.",
      "B) Wayne performs the second solo.",
      "C) Zara performs the third solo.",
      "D) The second solo is a modem piece.",
      "E) The fourth solo is a traditional piece."
    ],
    "answer": "C",
    "logic_program": "# Declarations  \npianists = EnumSort([Wayne, Zara])  \nsolos = EnumSort([s1, s2, s3, s4, s5])  \ntypes = EnumSort([modern, traditional])  \nperform = Function([solos] -> [pianists])  \npiece_type = Function([solos] -> [types])  \n\n# Constraints  \npiece_type(s3) == traditional ::: The third solo is a traditional piece  \nExactlyOnePairConsecutive(traditional, solos, piece_type) ::: Exactly two of the traditional pieces are performed consecutively  \nOr(And(perform(s4) == Wayne, piece_type(s4) == traditional), And(perform(s4) == Zara, piece_type(s4) == modern)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece  \nperform(s2) != perform(s5) ::: The pianist who performs the second solo does not perform the fifth solo  \nForAll([s:solos], Implies(piece_type(s) == traditional, Exists([s_prev:solos], And(s_prev < s, perform(s_prev) == Wayne, piece_type(s_prev) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modern piece  \nperform(s5) == Wayne ::: Fifth solo is Wayne (given in question)  \npiece_type(s5) == traditional ::: Fifth solo is traditional (given in question)  \n\n# Options  \nQuestion ::: If in the fifth solo Wayne performs a traditional piece, which one of the following could be true?  \nis_sat(perform(s1) == Zara) ::: (A)  \nis_sat(perform(s2) == Wayne) ::: (B)  \nis_sat(perform(s3) == Zara) ::: (C)  \nis_sat(piece_type(s2) == modern) ::: (D)  \nis_sat(piece_type(s4) == traditional) ::: (E)  \n\n**Answer:** (C) Zara performs the third solo."
  },
  {
    "id": "ar_lsat_201212_4-G_1_1",
    "context": "A realtor will show a prospective buyer seven houses\u00e2\u20ac\u201dJ, K, L, M, N, 0, and P\u00e2\u20ac\u201dduring a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following could be the order, from first through seventh, in which the realtor shows the houses?",
    "options": [
      "A) K, 0, L, M, N, J, P",
      "B) N, L, P, K, M, 0, J",
      "C) 0, P, K, L, N, M, J",
      "D) 0, P, M, N, K, L, J",
      "E) P, 0, K, J, L, N, M"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\ntime_slots = EnumSort([morning1, morning2, afternoon3, afternoon4, afternoon5, evening6, evening7])\nshow_order = Function([houses] -> [time_slots])\n\n# Constraints\nForAll([h:houses], And(1 <= show_order(h), show_order(h) <= 7)) ::: Each house is shown exactly once\nDistinct([h:houses], show_order(h)) ::: No two houses are shown at the same time\nshow_order(J) >= 6 ::: J must be shown in the evening (positions 6 or 7)\nshow_order(K) >= 3 ::: K cannot be shown in the morning (positions 1 or 2)\nAnd(show_order(L) > show_order(K), show_order(M) > show_order(L)) ::: L is shown after K and before M\n\n# Options\nQuestion ::: Which one of the following could be the order, from first through seventh, in which the realtor shows the houses?\nis_sat(And(\n    show_order(K) == 3, show_order(O) == 1, show_order(P) == 2, show_order(L) == 4, \n    show_order(N) == 5, show_order(M) == 6, show_order(J) == 7\n)) ::: (C)"
  },
  {
    "id": "ar_lsat_201212_4-G_1_2",
    "context": "A realtor will show a prospective buyer seven houses\u00e2\u20ac\u201dJ, K, L, M, N, 0, and P\u00e2\u20ac\u201dduring a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following is a pair of houses that CANNOT be shown consecutively in either order?",
    "options": [
      "A) J, K",
      "B) J, M",
      "C) J, O",
      "D) J, P",
      "E) M, P"
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201212_4-G_1_3",
    "context": "A realtor will show a prospective buyer seven houses\u00e2\u20ac\u201dJ, K, L, M, N, 0, and P\u00e2\u20ac\u201dduring a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) K is shown in the evening.",
      "B) L is shown in the afternoon.",
      "C) L is shown in the evening.",
      "D) M is shown in the morning.",
      "E) M is shown in the afternoon."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\npositions = EnumSort([1, 2, 3, 4, 5, 6, 7])\ntime_slots = {1: morning, 2: morning, 3: afternoon, 4: afternoon, 5: afternoon, 6: evening, 7: evening}\nschedule = Function([houses] -> [positions])\n\n# Constraints\nAllDistinct([h:houses], schedule(h)) ::: each house shown exactly once\nschedule(J) == 6 | schedule(J) == 7 ::: J must be shown in evening\nschedule(K) != 1 & schedule(K) != 2 ::: K cannot be shown in morning\nschedule(L) > schedule(K) & schedule(M) > schedule(L) ::: L after K, M after L\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(And(schedule(K) >= 6, schedule(K) <= 7)) ::: (A)\nis_valid(And(schedule(L) >= 3, schedule(L) <= 5)) ::: (B)\nis_valid(And(schedule(L) >= 6, schedule(L) <= 7)) ::: (C)\nis_valid(And(schedule(M) >= 1, schedule(M) <= 2)) ::: (D)\nis_valid(And(schedule(M) >= 3, schedule(M) <= 5)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201212_4-G_1_4",
    "context": "A realtor will show a prospective buyer seven houses\u00e2\u20ac\u201dJ, K, L, M, N, 0, and P\u00e2\u20ac\u201dduring a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) K is shown at some time after J is shown.",
      "B) L is shown at some time after J is shown.",
      "C) P is shown at some time after J is shown.",
      "D) Both N and O are shown at some time after M is",
      "E) Both N and P are shown at some time after K is"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\ntime_slots = EnumSort([morning1, morning2, afternoon1, afternoon2, afternoon3, evening1, evening2])\nschedule = Function([houses] -> [time_slots])\n\n# Constraints\nDistinct([h:houses], schedule(h)) ::: Each house is shown in a unique time slot\nschedule(J) == evening1 | schedule(J) == evening2 ::: J must be shown in the evening\nschedule(K) != morning1 & schedule(K) != morning2 ::: K cannot be shown in the morning\nschedule(L) > schedule(K) ::: L is shown after K\nschedule(M) > schedule(L) ::: M is shown after L\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(schedule(K) > schedule(J)) ::: (A)\nis_sat(schedule(L) > schedule(J)) ::: (B)\nis_sat(schedule(P) > schedule(J)) ::: (C)\nis_sat(schedule(N) > schedule(M) & schedule(O) > schedule(M)) ::: (D)\nis_sat(schedule(N) > schedule(K) & schedule(P) > schedule(K)) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_1_5",
    "context": "A realtor will show a prospective buyer seven houses\u00e2\u20ac\u201dJ, K, L, M, N, 0, and P\u00e2\u20ac\u201dduring a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "If P is shown in the afternoon, which one of the following must be true?",
    "options": [
      "A) J is shown seventh.",
      "B) K is shown third.",
      "C) N is shown first.",
      "D) M is shown in the afternoon.",
      "E) O is shown in the morning."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nhouses = EnumSort([J, K, L, M, N, O, P])  \ntime_slots = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nshown = Function([houses] -> [time_slots])  \n\n# Constraints  \nDistinct([h:houses], shown(h)) ::: each valve is opened exactly once  \nAnd(shown(J) == 6, shown(J) == 7) ::: J must be shown in the evening (6 or 7)  \nForAll([h:houses], Implies(h == K, Not(Or(shown(K) == 1, shown(K) == 2)))) ::: K cannot be shown in the morning  \nAnd(shown(L) > shown(K), shown(M) > shown(L)) ::: L after K, M after L  \nshown(P) >= 3, shown(P) <= 5 ::: P is shown in the afternoon  \n\n# Options  \nQuestion ::: If P is shown in the afternoon, which one of the following must be true?  \nis_valid(shown(J) == 7) ::: (A)  \nis_valid(shown(K) == 3) ::: (B)  \nis_valid(shown(N) == 1) ::: (C)  \nis_valid(And(shown(M) >= 3, shown(M) <= 5)) ::: (D)  \nis_valid(Or(shown(O) == 1, shown(O) == 2)) ::: (E)  \n\n**Answer**  \n(E) O is shown in the morning.  \n\n**Explanation**:  \nWith P occupying one afternoon slot, the remaining morning slots (1,2) must be filled by N and O due to constraints on K, L, M placements. This forces O into the morning."
  },
  {
    "id": "ar_lsat_201212_4-G_2_6",
    "context": "Exactly five witnesses\u00e2\u20ac\u201dFranco, Garcia, Hong, Iturbe, and Jackson\u00e2\u20ac\u201dare to be scheduled to testify at a hearing that is to take exactly three days of one week\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "Which one of the following is an acceptable schedule of witnesses?",
    "options": [
      "A) Monday: Franco Tuesday: Hong and Iturbe Wednesday: Garcia and Jackson",
      "B) Monday: Franco and Hong Tuesday: Iturbe and Jackson Wednesday: Garcia",
      "C) Monday: Garcia Tuesday: Franco and Iturbe Wednesday: Hong and Jackson",
      "D) Monday: Garcia and Jackson Tuesday: Franco and Hong Wednesday: Iturbe",
      "E) Monday: Garcia and Jackson Tuesday: Hong Wednesday: Franco and Iturbe"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], And(testifies(w) == Monday, testifies(w) == Tuesday, testifies(w) == Wednesday)) ::: Each witness testifies on exactly one day\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nForAll([d:days], Implies(d == Monday, testifies(Hong) != Monday)) ::: Hong does not testify on Monday\nCount([w:witnesses], testifies(w) == Monday) >= 1 ::: At least one witness testifies on Monday\nForAll([w1:witnesses, w2:witnesses], Implies(And(w1 == Franco, w2 == Garcia), testifies(w1) != testifies(w2))) ::: Franco does not testify on the same day as Garcia\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule of witnesses?\nis_model(And(\n  testifies(Franco) == Tuesday,\n  testifies(Garcia) == Monday,\n  testifies(Hong) == Tuesday,\n  testifies(Iturbe) == Wednesday,\n  testifies(Jackson) == Monday\n)) ::: (D)"
  },
  {
    "id": "ar_lsat_201212_4-G_2_7",
    "context": "Exactly five witnesses\u00e2\u20ac\u201dFranco, Garcia, Hong, Iturbe, and Jackson\u00e2\u20ac\u201dare to be scheduled to testify at a hearing that is to take exactly three days of one week\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "Which one of the following CANNOT be true of the schedule?",
    "options": [
      "A) Franco is the only witness scheduled to testify on Monday.",
      "B) Franco is scheduled to testify on the same day as Iturbe.",
      "C) Garcia and Hong are both scheduled to testify on Tuesday.",
      "D) Garcia is the only witness scheduled to testify on Monday and Hong is one of two witnesses scheduled to testify on Wednesday.",
      "E) Jackson is scheduled to testify on Tuesday and two witnesses are scheduled to testify on Monday."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], And(testifies(w) == Monday, testifies(w) == Tuesday, testifies(w) == Wednesday)) ::: Each witness testifies on exactly one day\nCount([w:witnesses], testifies(w) == Monday) + Count([w:witnesses], testifies(w) == Tuesday) + Count([w:witnesses], testifies(w) == Wednesday) == 5 ::: Exactly five witnesses testify over three days\nForAll([w1:witnesses, w2:witnesses], Implies(w1 != w2, testifies(w1) != testifies(w2) Or w1 == w2)) ::: Each witness testifies on exactly one day (alternative)\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nCount([w:witnesses], testifies(w) == Monday) >= 1 ::: At least one witness testifies on Monday\nForAll([d:days], Implies(testifies(Franco) == d, testifies(Garcia) != d)) ::: Franco does not testify on the same day as Garcia\n\n# Options\nQuestion ::: Which one of the following CANNOT be true of the schedule?\nis_invalid(And(Count([w:witnesses], testifies(w) == Monday) == 1, testifies(Franco) == Monday)) ::: (A)\nis_invalid(testifies(Franco) == Wednesday) ::: (B)\nis_invalid(And(testifies(Garcia) == Tuesday, testifies(Hong) == Tuesday)) ::: (C)\nis_invalid(And(Count([w:witnesses], testifies(w) == Monday) == 1, testifies(Garcia) == Monday, testifies(Hong) == Wednesday, Count([w:witnesses], testifies(w) == Wednesday) == 2)) ::: (D)\nis_invalid(And(testifies(Jackson) == Tuesday, Count([w:witnesses], testifies(w) == Monday) == 2)) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_2_8",
    "context": "Exactly five witnesses\u00e2\u20ac\u201dFranco, Garcia, Hong, Iturbe, and Jackson\u00e2\u20ac\u201dare to be scheduled to testify at a hearing that is to take exactly three days of one week\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Jackson is scheduled to testify on Wednesday, which one of the following must be true of the schedule?",
    "options": [
      "A) Franco is scheduled to testify on Monday.",
      "B) Garcia is scheduled to testify on Monday.",
      "C) Exactly one witness is scheduled to testify on Monday.",
      "D) Exactly two witnesses are scheduled to testify on Monday.",
      "E) Garcia is scheduled to testify on the same day as Hong."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], ExactlyOne([d:days], testifies(w) == d)) ::: Each witness testifies on exactly one day\nForAll([d:days], Count([w:witnesses], testifies(w) == d) >= 1) ::: At least one witness testifies each day\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nForAll([w1:witnesses, w2:witnesses], Implies(And(w1 == Franco, w2 == Garcia), testifies(w1) != testifies(w2))) ::: Franco and Garcia not on the same day\ntestifies(Jackson) == Wednesday ::: Jackson testifies on Wednesday (given condition)\n\n# Options\nQuestion ::: If Jackson is scheduled to testify on Wednesday, which one of the following must be true?\nis_valid(Count([w:witnesses], testifies(w) == Monday) == 1) ::: (C) Exactly one witness on Monday"
  },
  {
    "id": "ar_lsat_201212_4-G_2_9",
    "context": "Exactly five witnesses\u00e2\u20ac\u201dFranco, Garcia, Hong, Iturbe, and Jackson\u00e2\u20ac\u201dare to be scheduled to testify at a hearing that is to take exactly three days of one week\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Jackson is the only witness scheduled to testify on Monday, which one of the following must be true of the schedule?",
    "options": [
      "A) Franco is scheduled to testify on Wednesday.",
      "B) Hong is scheduled to testify on Tuesday.",
      "C) Garcia is scheduled to testify on Tuesday.",
      "D) Franco is scheduled to testify on the same day as Hong.",
      "E) Garcia is scheduled to testify on the same day as Hong."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], And(testifies(w) == Monday, testifies(w) == Tuesday, testifies(w) == Wednesday)) ::: Each witness testifies on exactly one day\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nCount([w:witnesses], testifies(w) == Monday) >= 1 ::: At least one witness testifies on Monday\nForAll([d:days], Implies(testifies(Franco) == d, testifies(Garcia) != d)) ::: Franco does not testify on the same day as Garcia\ntestifies(Jackson) == Monday ::: Jackson is the only witness scheduled to testify on Monday\n\n# Options\nQuestion ::: If Jackson is the only witness scheduled to testify on Monday, which one of the following must be true of the schedule?\nis_valid(testifies(Hong) == Tuesday) ::: (B)"
  },
  {
    "id": "ar_lsat_201212_4-G_2_10",
    "context": "Exactly five witnesses\u00e2\u20ac\u201dFranco, Garcia, Hong, Iturbe, and Jackson\u00e2\u20ac\u201dare to be scheduled to testify at a hearing that is to take exactly three days of one week\u00e2\u20ac\u201dMonday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Franco is scheduled to testify on the same day as Hong, which one of the following must be true of the schedule?",
    "options": [
      "A) Franco is scheduled to testify on Wednesday.",
      "B) Garcia is scheduled to testify on Monday.",
      "C) Garcia is scheduled to testify on Wednesday.",
      "D) Hong is scheduled to testify on Tuesday.",
      "E) Iturbe is the only witness scheduled to testify on Wednesday."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], And(testifies(w) == Monday, testifies(w) == Tuesday, testifies(w) == Wednesday)) ::: Each witness testifies on exactly one day\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nForAll([d:days], Implies(d == Monday, Count([w:witnesses], testifies(w) == d) >= 1)) ::: At least one witness testifies on Monday\nForAll([w:witnesses], Implies(w == Hong, testifies(w) != Monday)) ::: Hong does not testify on Monday\nForAll([w1:witnesses, w2:witnesses], Implies(And(w1 == Franco, w2 == Garcia), testifies(w1) != testifies(w2))) ::: Franco does not testify on the same day as Garcia\n\n# Additional constraint for the question\ntestifies(Franco) == testifies(Hong) ::: Franco is scheduled to testify on the same day as Hong\n\n# Options\nQuestion ::: If Franco is scheduled to testify on the same day as Hong, which one of the following must be true of the schedule?\nis_valid(testifies(Franco) == Wednesday) ::: (A)\nis_valid(testifies(Garcia) == Monday) ::: (B)\nis_valid(testifies(Garcia) == Wednesday) ::: (C)\nis_valid(testifies(Hong) == Tuesday) ::: (D)\nis_valid(ForAll([w:witnesses], Implies(testifies(w) == Wednesday, w == Iturbe))) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_3_11",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If none of the clients has a voicemail target of 3 days, then each of the following must be true EXCEPT:",
    "options": [
      "A) Image's website target is 1 day.",
      "B) Solide's website target is 2 days.",
      "C) Solide's voicemail target is 2 days.",
      "D) Truvest's website target is 2 days.",
      "E) Truvest's voicemail target is 2 days."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ndays = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [days])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\n\n# Additional condition for the question\nForAll([c:clients], target(c, voicemail) != 3) ::: None of the clients has a voicemail target of 3 days\n\n# Options\nQuestion ::: Each of the following must be true EXCEPT:\nis_exception(ForAll([c:clients], target(Image, website) == 1)) ::: (A)\nis_exception(ForAll([c:clients], target(Solide, website) == 2)) ::: (B)\nis_exception(ForAll([c:clients], target(Solide, voicemail) == 2)) ::: (C)\nis_exception(ForAll([c:clients], target(Truvest, website) == 2)) ::: (D)\nis_exception(ForAll([c:clients], target(Truvest, voicemail) == 2)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201212_4-G_3_12",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Truvest's website target is shorter than its voicemail target, which one of the following must be true?",
    "options": [
      "A) Image's voicemail target is 2 days.",
      "B) Image's website target is 2 days.",
      "C) Image's website target is 1 day.",
      "D) Solide's website target is 2 days.",
      "E) Solide's website target is 1 day."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ndays = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [days])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\ntarget(Truvest, website) < target(Truvest, voicemail) ::: Truvest's website target is shorter than its voicemail target (question's condition)\n\n# Options\nQuestion ::: If Truvest's website target is shorter than its voicemail target, which one of the following must be true?\nis_valid(target(Image, voicemail) == 2) ::: (A)\nis_valid(target(Image, website) == 2) ::: (B)\nis_valid(target(Image, website) == 1) ::: (C)\nis_valid(target(Solide, website) == 2) ::: (D)\nis_valid(target(Solide, website) == 1) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_3_13",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Image's website target is 2 days, which one of the following targets must also be 2 days?",
    "options": [
      "A) Image's voicemail target",
      "B) Solide's website target",
      "C) Solide's voicemail target",
      "D) Truvest's website target",
      "E) Truvest's voicemail target"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ndays = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [days])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\n\n# Options\nQuestion ::: If Image's website target is 2 days, which one of the following targets must also be 2 days?\nis_valid(target(Image, voicemail) == 2) ::: (A)\nis_valid(target(Solide, website) == 2) ::: (B)\nis_valid(target(Solide, voicemail) == 2) ::: (C)\nis_valid(target(Truvest, website) == 2) ::: (D)\nis_valid(target(Truvest, voicemail) == 2) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_3_14",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Solide's voicemail target is shorter than Truvest's website target, which one of the following targets could be 2 days?",
    "options": [
      "A) Image's website target",
      "B) Image's voicemail target",
      "C) Solide's website target",
      "D) Truvest's voicemail target",
      "E) Truvest's website target"
    ],
    "answer": "C",
    "logic_program": "# Declarations  \nclients = EnumSort([Image, Solide, Truvest])  \nchannels = EnumSort([website, voicemail])  \ndays = EnumSort([1, 2, 3])  \ntarget = Function([clients, channels] -> [days])  \n\n# Constraints  \nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target  \nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets  \ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target  \ntarget(Solide, voicemail) < target(Truvest, website) ::: Additional condition: Solide's voicemail target is shorter than Truvest's website target  \n\n# Options  \nQuestion ::: Which one of the following targets could be 2 days?  \nis_sat(target(Image, website) == 2) ::: (A)  \nis_sat(target(Image, voicemail) == 2) ::: (B)  \nis_sat(target(Solide, website) == 2) ::: (C)  \nis_sat(target(Truvest, voicemail) == 2) ::: (D)  \nis_sat(target(Truvest, website) == 2) ::: (E)  \n\n**Answer:** (C) Solide's website target"
  },
  {
    "id": "ar_lsat_201212_4-G_3_15",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "Which one of the following targets CANNOT be set for more than one of the clients?",
    "options": [
      "A) a 1-day website target",
      "B) a 2-day voicemail target",
      "C) a 2-day website target",
      "D) a 3-day voicemail target",
      "E) a 3-day website target"
    ],
    "answer": "E",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201212_4-G_3_16",
    "context": "A maintenance company that takes service requests from three clients\u00e2\u20ac\u201dImage, Solide, and Truvest\u00e2\u20ac\u201dplans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client\u00e2\u20ac\u201done for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If none of the clients has a website target of 2 days, which one of the following could be true?",
    "options": [
      "A) Image's website target is shorter than Solide's.",
      "B) Solide's website target is shorter than Image's.",
      "C) Solide's voicemail target is shorter than Truvest's.",
      "D) Truvest's website target is shorter than Image's.",
      "E) Truvest's voicemail target is shorter than Solide's."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ndays = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [days])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\nForAll([c:clients], Or(target(c, website) == 1, target(c, website) == 3)) ::: None of the clients has a website target of 2 days\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(target(Image, website) < target(Solide, website)) ::: (A)\nis_sat(target(Solide, website) < target(Image, website)) ::: (B)\nis_sat(target(Solide, voicemail) < target(Truvest, voicemail)) ::: (C)\nis_sat(target(Truvest, website) < target(Image, website)) ::: (D)\nis_sat(target(Truvest, voicemail) < target(Solide, voicemail)) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_4_17",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "Which one of the following is an acceptable order for editing the articles, from first through seventh?",
    "options": [
      "A) H, S, J, Q, Y, G, R",
      "B) J, Q, G, H, S, Y, R",
      "C) Q, J, S, H, Y, G, R",
      "D) Q, J, Y, S, G, R, H",
      "E) S, G, Q, J, Y, R, H"
    ],
    "answer": "C",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ntopic_of = Function([articles] -> [topics])\norder = Function([articles] -> [int])\nForAll([a:articles], And(1 <= order(a), order(a) <= 7))\n\n# Constraints\nDistinct([a:articles], order(a)) ::: each article edited exactly once\nForAll([a1:articles, a2:articles], Implies(order(a1) + 1 == order(a2), topic_of(a1) != topic_of(a2))) ::: Consecutive articles cannot cover the same topic\nImplies(Exists([a1:articles, a2:articles], And(order(a1) < order(a2), a1 == S, a2 == Q)), order(Q) == 3) ::: S can be earlier than Q only if Q is third\nExists([a1:articles, a2:articles], And(order(a1) < order(a2), a1 == S, a2 == Y)) ::: S must be earlier than Y\nAnd(order(J) < order(G), order(G) < order(R)) ::: J must be earlier than G, and G must be earlier than R\n\n# Options\nQuestion ::: Which one of the following is an acceptable order for editing the articles, from first through seventh?\nis_model(And(\n    order(H) == 1, order(S) == 2, order(J) == 3, order(Q) == 4, order(Y) == 5, order(G) == 6, order(R) == 7\n)) ::: (A)\nis_model(And(\n    order(J) == 1, order(Q) == 2, order(G) == 3, order(H) == 4, order(S) == 5, order(Y) == 6, order(R) == 7\n)) ::: (B)\nis_model(And(\n    order(Q) == 1, order(J) == 2, order(S) == 3, order(H) == 4, order(Y) == 5, order(G) == 6, order(R) == 7\n)) ::: (C)\nis_model(And(\n    order(Q) == 1, order(J) == 2, order(Y) == 3, order(S) == 4, order(G) == 5, order(R) == 6, order(H) == 7\n)) ::: (D)\nis_model(And(\n    order(S) == 1, order(G) == 2, order(Q) == 3, order(J) == 4, order(Y) == 5, order(R) == 6, order(H) == 7\n)) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_4_18",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If Y is fourth, which one of the following must be true?",
    "options": [
      "A) J is second.",
      "B) J is third",
      "C) Q is first.",
      "D) Q is third",
      "E) R is seventh."
    ],
    "answer": "A",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\npositions = EnumSort([1, 2, 3, 4, 5, 6, 7])\ntopic = Function([articles] -> [str])  # \"finance\", \"nutrition\", \"wildlife\"\norder = Function([articles] -> [positions])\n\n# Constraints\nDistinct([a:articles], order(a)) ::: each article is edited exactly once\nForAll([a:articles], And(1 <= order(a), order(a) <= 7)) ::: valid positions\nForAll([i:positions, j:positions], Implies(And(i == j + 1, i >= 2), topic(order[i]) != topic(order[j]))) ::: consecutive articles have different topics\nImplies(Exists([i:positions, j:positions], And(order(S) == i, order(Q) == j, i < j)), order(Q) == 3) ::: S can be earlier than Q only if Q is third\norder(S) < order(Y) ::: S must be earlier than Y\norder(J) < order(G) ::: J earlier than G\norder(G) < order(R) ::: G earlier than R\norder(Y) == 4 ::: Y is fourth\n\n# Options\nQuestion ::: If Y is fourth, which one of the following must be true?\nis_valid(order(J) == 2) ::: (A)\nis_valid(order(J) == 3) ::: (B)\nis_valid(order(Q) == 1) ::: (C)\nis_valid(order(Q) == 3) ::: (D)\nis_valid(order(R) == 7) ::: (E)\n\n**Answer:** (A) J is second."
  },
  {
    "id": "ar_lsat_201212_4-G_4_19",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If G is fourth, which one of the following could be true?",
    "options": [
      "A) H is fifth.",
      "B) J is first.",
      "C) Q is second.",
      "D) S is fifth",
      "E) Y is sixth."
    ],
    "answer": "E",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201212_4-G_4_20",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) G is second",
      "B) H is second.",
      "C) S is second",
      "D) R is third.",
      "E) Y is third"
    ],
    "answer": "B",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ntopic_of = Function([articles] -> [topics])\norder = Function([articles] -> [int])\n\n# Constraints\nForAll([a:articles], And(1 <= order(a), order(a) <= 7)) ::: Each article is ordered once\nDistinct([a:articles], order(a)) ::: No two articles have the same order\nForAll([a1:articles, a2:articles], Implies(order(a1) + 1 == order(a2), topic_of(a1) != topic_of(a2))) ::: Consecutive articles have different topics\nImplies(Exists([a1:articles, a2:articles], And(order(a1) < order(a2), a1 == S, a2 == Q)), order(Q) == 3) ::: S can be earlier than Q only if Q is third\norder(S) < order(Y) ::: S must be earlier than Y\norder(J) < order(G) ::: J is before G\norder(G) < order(R) ::: G is before R\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(order(G) == 2) ::: (A)\nis_sat(order(H) == 2) ::: (B)\nis_sat(order(S) == 2) ::: (C)\nis_sat(order(R) == 3) ::: (D)\nis_sat(order(Y) == 3) ::: (E)\n\n**Answer:** (B) H is second."
  },
  {
    "id": "ar_lsat_201212_4-G_4_21",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If J is third, which one of the following could be true?",
    "options": [
      "A) G is fourth",
      "B) His sixth",
      "C) Q is first",
      "D) S is second",
      "E) Y is fifth"
    ],
    "answer": "E",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\npositions = EnumSort([1, 2, 3, 4, 5, 6, 7])\ntopic = Function([articles] -> [str])\norder = Function([positions] -> [articles])\n\n# Constraints\nDistinct([p:positions], order(p)) ::: each article is edited exactly once\nForAll([p:positions], If(p < 7, topic(order(p)) != topic(order(p+1)))) ::: consecutive articles cannot cover the same topic\norder(3) == J ::: J is third\nForAll([p1, p2:positions], (order(p1) == S & order(p2) == Q & p1 < p2) \u2192 (p2 == 3)) ::: S can be earlier than Q only if Q is third\nExists([p1, p2:positions], p1 < p2 & order(p1) == S & order(p2) == Y) ::: S must be earlier than Y\nForAll([p1, p2, p3:positions], (order(p1) == J & order(p2) == G & order(p3) == R) \u2192 (p1 < p2 & p2 < p3)) ::: J < G < R\n\n# Options\nQuestion ::: If J is third, which one of the following could be true?\nis_sat(order(4) == G) ::: (A)\nis_sat(order(6) == H) ::: (B)\nis_sat(order(1) == Q) ::: (C)\nis_sat(order(2) == S) ::: (D)\nis_sat(order(5) == Y) ::: (E)"
  },
  {
    "id": "ar_lsat_201212_4-G_4_22",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "In the order in which the articles are edited, S could be in any of the following positions EXCEPT:",
    "options": [
      "A) first",
      "B) third",
      "C) fourth",
      "D) fifth",
      "E) sixth"
    ],
    "answer": "D",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\nposition = Function([articles] -> [int])\nForAll([a:articles], And(1 <= position(a), position(a) <= 7))\n\n# Constraints\nDistinct([a:articles], position(a)) ::: each valve is opened exactly once\nForAll([i:1..6], ForAll([a1,a2:articles], Implies(And(position(a1) == i, position(a2) == i+1), topic(a1) != topic(a2)))) ::: Consecutive articles cannot cover the same topic\nImplies(position(S) < position(Q), position(Q) == 3) ::: S can be earlier than Q only if Q is third\nposition(S) < position(Y) ::: S must be earlier than Y\nposition(J) < position(G) ::: J must be earlier than G\nposition(G) < position(R) ::: G must be earlier than R\n\n# Options\nQuestion ::: In the order in which the articles are edited, S could be in any of the following positions EXCEPT:\nis_exception(is_sat(position(S) == 1)) ::: (A)\nis_exception(is_sat(position(S) == 3)) ::: (B)\nis_exception(is_sat(position(S) == 4)) ::: (C)\nis_exception(is_sat(position(S) == 5)) ::: (D)\nis_exception(is_sat(position(S) == 6)) ::: (E)\n\n**Answer:** (D) fifth"
  },
  {
    "id": "ar_lsat_201212_4-G_4_23",
    "context": "An editor will edit seven articles, one at a time. Three of the articles\u00e2\u20ac\u201dG, H, and J\u00e2\u20ac\u201dcover finance; three other articles\u00e2\u20ac\u201dQ, R, and S\u00e2\u20ac\u201dcover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "The order in which the articles are edited is fully determined if which one of the following is true?",
    "options": [
      "A) H is fourth.",
      "B) H is sixth.",
      "C) R is fourth.",
      "D) R is seventh.",
      "E) Y is fifth."
    ],
    "answer": "C",
    "logic_program": "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\nedit_order = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edit_order(a), edit_order(a) <= 7))\n\n# Constraints\nDistinct([a:articles], edit_order(a)) ::: Each article is edited exactly once\nForAll([a1:articles, a2:articles], Implies(edit_order(a1) + 1 == edit_order(a2), Not(topic(a1) == topic(a2)))) ::: Consecutive articles cannot cover the same topic\nImplies(Exists([a1:articles, a2:articles], And(edit_order(a1) < edit_order(a2), a1 == S, a2 == Q)), edit_order(Q) == 3) ::: S can be earlier than Q only if Q is third\nedit_order(S) < edit_order(Y) ::: S must be earlier than Y\nedit_order(J) < edit_order(G) ::: J must be earlier than G\nedit_order(G) < edit_order(R) ::: G must be earlier than R\ntopic(G) == finance ::: G is finance\ntopic(H) == finance ::: H is finance\ntopic(J) == finance ::: J is finance\ntopic(Q) == nutrition ::: Q is nutrition\ntopic(R) == nutrition ::: R is nutrition\ntopic(S) == nutrition ::: S is nutrition\ntopic(Y) == wildlife ::: Y is wildlife\n\n# Options\nQuestion ::: The order in which the articles are edited is fully determined if which one of the following is true?\nis_unique(edit_order(H) == 4) ::: (A)\nis_unique(edit_order(H) == 6) ::: (B)\nis_unique(edit_order(R) == 4) ::: (C)\nis_unique(edit_order(R) == 7) ::: (D)\nis_unique(edit_order(Y) == 5) ::: (E)\n\n**Answer:** (C) Urma and Xena"
  },
  {
    "id": "ar_lsat_201310_3-G_1_1",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following CANNOT be the band that performs in slot five?",
    "options": [
      "A) Uneasy",
      "B) Veqemite",
      "C) Wellspring",
      "D) Xpert",
      "E) Zircon"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nschedule = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], schedule(b)) ::: Each band will perform in just one slot\nschedule(Vegemite) < schedule(Zircon) ::: Vegemite performs earlier than Zircon\nAnd(schedule(Wellspring) < schedule(Xpert), schedule(Zircon) < schedule(Xpert)) ::: Wellspring and Zircon each perform earlier than Xpert\nOr(schedule(Uneasy) == 4, schedule(Uneasy) == 5, schedule(Uneasy) == 6) ::: Uneasy performs in one of the last three slots\nOr(schedule(Yardsign) == 1, schedule(Yardsign) == 2, schedule(Yardsign) == 3) ::: Yardsign performs in one of the first three slots\n\n# Options\nQuestion ::: Which one of the following CANNOT be the band that performs in slot five?\nis_exception(is_sat(schedule(Uneasy) == 5)) ::: (A)\nis_exception(is_sat(schedule(Vegemite) == 5)) ::: (B)\nis_exception(is_sat(schedule(Wellspring) == 5)) ::: (C)\nis_exception(is_sat(schedule(Xpert) == 5)) ::: (D)\nis_exception(is_sat(schedule(Zircon) == 5)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_1_2",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Zircon performs in an earlier slot than Yardsign, which one of the following is the earliest slot in which Wellspring could perform?",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], performs(b)) ::: Each band performs in one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite earlier than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon before Xpert\nOr(performs(Uneasy) == 4, performs(Uneasy) == 5, performs(Uneasy) == 6) ::: Uneasy in last three slots\nOr(performs(Yardsign) == 1, performs(Yardsign) == 2, performs(Yardsign) == 3) ::: Yardsign in first three slots\nperforms(Zircon) < performs(Yardsign) ::: Zircon before Yardsign (additional question constraint)\n\n# Options\nQuestion ::: If Zircon performs in an earlier slot than Yardsign, which one of the following is the earliest slot in which Wellspring could perform?\nis_minimal(performs(Wellspring)) ::: Find earliest possible slot\nOption (A) two: performs(Wellspring) == 2\nOption (B) three: performs(Wellspring) == 3\nOption (C) four: performs(Wellspring) == 4\nOption (D) five: performs(Wellspring) == 5\nOption (E) six: performs(Wellspring) == 6\n\n# Answer\nThe earliest possible slot for Wellspring is 4.  \n**Answer**  \n\\boxed{C}"
  },
  {
    "id": "ar_lsat_201310_3-G_1_3",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Veqemite performs in slot three, which one of the following must be true?",
    "options": [
      "A) Uneasy performs in an earlier slot than Xpert.",
      "B) Wellspring performs in an earlier slot than zircon",
      "C) Xpert performs in an earlier slot than Uneasy",
      "D) Yardsign performs in an earlier slot than, wellspring",
      "E) Zircon performs in an earlier slot than Uneasy."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nschedule = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], schedule(b)) ::: Each band plays exactly once\nschedule(Vegemite) < schedule(Zircon) ::: Vegemite earlier than Zircon\nAnd(schedule(Wellspring) < schedule(Xpert), schedule(Zircon) < schedule(Xpert)) ::: Wellspring and Zircon before Xpert\nOr(schedule(Uneasy) == 4, schedule(Uneasy) == 5, schedule(Uneasy) == 6) ::: Uneasy in last three slots\nOr(schedule(Yardsign) == 1, schedule(Yardsign) == 2, schedule(Yardsign) == 3) ::: Yardsign in first three slots\nschedule(Vegemite) == 3 ::: Vegemite in slot 3 (given condition)\n\n# Options\nQuestion ::: If Vegemite performs in slot three, which one of the following must be true?\nis_valid(schedule(Uneasy) < schedule(Xpert)) ::: (A)\nis_valid(schedule(Wellspring) < schedule(Zircon)) ::: (B)\nis_valid(schedule(Xpert) < schedule(Uneasy)) ::: (C)\nis_valid(schedule(Yardsign) < schedule(Wellspring)) ::: (D)\nis_valid(schedule(Zircon) < schedule(Uneasy)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_1_4",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Zircon performs immediately before Wellspring, which one of the following must be true?",
    "options": [
      "A) Uneasy performs in slot five.",
      "B) Vegemite performs in slot one.",
      "C) Xpert performs in slot five.",
      "D) Yardsign performs in slot two.",
      "E) Zircon performs in slot three."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], performs(b)) ::: Each band performs in just one slot\nVegemite < Zircon ::: Vegemite performs earlier than Zircon\nAnd(Wellspring < Xpert, Zircon < Xpert) ::: Wellspring and Zircon each perform earlier than Xpert\nOr(performs(Uneasy) == 4, performs(Uneasy) == 5, performs(Uneasy) == 6) ::: Uneasy performs in one of the last three slots\nOr(performs(Yardsign) == 1, performs(Yardsign) == 2, performs(Yardsign) == 3) ::: Yardsign performs in one of the first three slots\nperforms(Zircon) + 1 == performs(Wellspring) ::: Zircon performs immediately before Wellspring\n\n# Options\nQuestion ::: If Zircon performs immediately before Wellspring, which one of the following must be true?\nis_valid(performs(Uneasy) == 5) ::: (A)\nis_valid(performs(Vegemite) == 1) ::: (B)\nis_valid(performs(Xpert) == 5) ::: (C)\nis_valid(performs(Yardsign) == 2) ::: (D)\nis_valid(performs(Zircon) == 3) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_1_5",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following is a complete and accurate list of bands any one of which could be the band that performs in slot one?",
    "options": [
      "A) Yardsign",
      "B) Vegemite, Wellspring",
      "C) Vegemite, Yardsign",
      "D) Vegemite, Wellspring, Yardsign",
      "E) Vegemite, Wellspring, Yardsign, Zircon"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], And(1 <= performs(b), performs(b) <= 6)) ::: Each band performs in one slot\nDistinct([b:bands], performs(b)) ::: Each slot has exactly one band\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs earlier than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon perform before Xpert\nAnd(performs(Uneasy) >= 4, performs(Uneasy) <= 6) ::: Uneasy in last three slots\nAnd(performs(Yardsign) >= 1, performs(Yardsign) <= 3) ::: Yardsign in first three slots\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(performs(Yardsign) == 1) ::: (A)\nis_sat(Or(performs(Vegemite) == 1, performs(Wellspring) == 1)) ::: (B)\nis_sat(Or(performs(Vegemite) == 1, performs(Yardsign) == 1)) ::: (C)\nis_sat(Or(performs(Vegemite) == 1, performs(Wellspring) == 1, performs(Yardsign) == 1)) ::: (D)\nis_sat(Or(performs(Vegemite) == 1, performs(Wellspring) == 1, performs(Yardsign) == 1, performs(Zircon) == 1)) ::: (E)\n\n**Answer:** (D) Vegemite, Wellspring, Yardsign"
  },
  {
    "id": "ar_lsat_201310_3-G_1_6",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Wellspring performs immediately before Xpert, which one of the following could be true?",
    "options": [
      "A) Uneasy performs in slot five.",
      "B) Vegemite performs in slot three.",
      "C) Wellspring performs in slot three.",
      "D) Zircon performs in slot two.",
      "E) Zircon performs in slot four."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nschedule = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], schedule(b)) ::: Each band will perform in just one slot\nschedule(Vegemite) < schedule(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(schedule(Wellspring) < schedule(Xpert), schedule(Zircon) < schedule(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(schedule(Uneasy) >= 4, schedule(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(schedule(Yardsign) >= 1, schedule(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\nschedule(Wellspring) + 1 == schedule(Xpert) ::: Wellspring performs immediately before Xpert\n\n# Options\nQuestion ::: If Wellspring performs immediately before Xpert, which one of the following could be true?\nis_sat(schedule(Uneasy) == 5) ::: (A)\nis_sat(schedule(Vegemite) == 3) ::: (B)\nis_sat(schedule(Wellspring) == 3) ::: (C)\nis_sat(schedule(Zircon) == 2) ::: (D)\nis_sat(schedule(Zircon) == 4) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_1_7",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands\u00e2\u20ac\u201dUneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following, if substituted for the constraint that Wellspring and Zircon each perform in an earlier slot than Xpert, would have the same effect in determining the order in which the bands perform?",
    "options": [
      "A) Only Uneasy can perform in a later slot than Xpert.",
      "B) Vegemite performs in an earlier slot than Wellspring, which performs in an earlier slot than Zircon.",
      "C) Vegemite and Wellspring each perform in an earlier slot than Xpert.",
      "D) Xpert performs either immediately before or immediately after Uneasy.",
      "E) Xpert performs in either slot five or slot six."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([slot1, slot2, slot3, slot4, slot5, slot6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nDistinct([b:bands], performs(b)) ::: Each band performs in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs earlier than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform earlier than Xpert\nOr(performs(Uneasy) == slot4, performs(Uneasy) == slot5, performs(Uneasy) == slot6) ::: Uneasy performs in one of the last three slots\nOr(performs(Yardsign) == slot1, performs(Yardsign) == slot2, performs(Yardsign) == slot3) ::: Yardsign performs in one of the first three slots\n\n# Options\nQuestion ::: Which substitution has the same effect as the original Wellspring/Zircon constraint?\nis_equivalent(ForAll([s:slots], performs(Xpert) == slot5 | performs(Xpert) == slot6)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_2_8",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a possible selection of employees for the team?",
    "options": [
      "A) Myers, Paine, Schmidt, and Thomson",
      "B) Ortega, Paine, Thomson, and Zayre",
      "C) Paine, Schmidt, Yoder, and Zayre",
      "D) Schmidt, Thomson, Yoder, and Zayre",
      "E) Thomson, Wong, Yoder, and Zayre"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\nselected = Function([employees] -> [bool])\n\n# Constraints\nCount([e:employees], selected(e)) >= 4 ::: The team will include at least four employees\nImplies(selected(Myers), And(Not(selected(Ortega)), Not(selected(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(selected(Schmidt), And(selected(Paine), selected(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(selected(Wong), And(selected(Myers), selected(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\n\n# Options\nQuestion ::: Which one of the following is a possible selection of employees for the team?\nis_sat(And(selected(Myers), selected(Paine), selected(Schmidt), selected(Thomson))) ::: (A)\nis_sat(And(selected(Ortega), selected(Paine), selected(Thomson), selected(Zayre))) ::: (B)\nis_sat(And(selected(Paine), selected(Schmidt), selected(Yoder), selected(Zayre))) ::: (C)\nis_sat(And(selected(Schmidt), selected(Thomson), selected(Yoder), selected(Zayre))) ::: (D)\nis_sat(And(selected(Thomson), selected(Wong), selected(Yoder), selected(Zayre))) ::: (E)\n\n**Answer**\nThe correct answer is (B). The constraints allow Ortega, Paine, Thomson, and Zayre to be selected without violating any conditions. Other options conflict with constraints involving Myers, Schmidt, or Wong."
  },
  {
    "id": "ar_lsat_201310_3-G_2_9",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a pair of employees who CANNOT be on the team together?",
    "options": [
      "A) Myers and Thomson",
      "B) Ortega and Yoder",
      "C) Paine and Zayre",
      "D) Schmidt and Wong",
      "E) Wong and Yoder"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\n\n# Options\nQuestion ::: Which one of the following pairs of employees could repair all and only the same types of machines as each other?\nis_sat(And(on_team(Myers), on_team(Thomson))) ::: (A)\nis_sat(And(on_team(Ortega), on_team(Yoder))) ::: (B)\nis_sat(And(on_team(Paine), on_team(Zayre))) ::: (C)\nis_sat(And(on_team(Schmidt), on_team(Wong))) ::: (D)\nis_sat(And(on_team(Wong), on_team(Yoder))) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_2_10",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "If Yoder is not on the team, then any of the following could be on the team EXCEPT:",
    "options": [
      "A) Zayre",
      "B) Thomson",
      "C) Paine",
      "D) Ortega",
      "E) Myers"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\n\n# Options\nQuestion ::: If Yoder is not on the team, then any of the following could be on the team EXCEPT:\nNot(on_team(Yoder)) ::: Given condition\nis_exception(is_sat(on_team(Zayre))) ::: (A)\nis_exception(is_sat(on_team(Thomson))) ::: (B)\nis_exception(is_sat(on_team(Paine))) ::: (C)\nis_exception(is_sat(on_team(Ortega))) ::: (D)\nis_exception(is_sat(on_team(Myers))) ::: (E)\n\n**Answer:** (E) Myers"
  },
  {
    "id": "ar_lsat_201310_3-G_2_11",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "If Paine is not on the team, which one of the following could be true?",
    "options": [
      "A) Neither Myers nor Ortega is on the team.",
      "B) Neither Myers nor Thomson is on the team.",
      "C) Neither Myers nor Zayre is on the team.",
      "D) Neither Ortega nor Thomson is on the team.",
      "E) Neither Ortega nor Yoder is on the team."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\nselected = Function([employees] -> [bool])\n\n# Constraints\nImplies(selected(Myers), And(Not(selected(Ortega)), Not(selected(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(selected(Schmidt), And(selected(Paine), selected(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(selected(Wong), And(selected(Myers), selected(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\nCount([e:employees], selected(e)) >= 4 ::: The team will include at least four employees\nNot(selected(Paine)) ::: Paine is not on the team\n\n# Options\nQuestion ::: If Paine is not on the team, which one of the following could be true?\nis_sat(And(Not(selected(Myers)), Not(selected(Ortega)))) ::: (A)\nis_sat(And(Not(selected(Myers)), Not(selected(Thomson)))) ::: (B)\nis_sat(And(Not(selected(Myers)), Not(selected(Zayre)))) ::: (C)\nis_sat(And(Not(selected(Ortega)), Not(selected(Thomson)))) ::: (D)\nis_sat(And(Not(selected(Ortega)), Not(selected(Yoder)))) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_2_12",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a pair of employees at least one of whom must be on the team?",
    "options": [
      "A) Ortega and Schmidt",
      "B) Ortega and Wong",
      "C) Paine and Schmidt",
      "D) Thomson and Yoder",
      "E) Yoder and Zayre"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\nImplies(on_team(Myers), Not(Or(on_team(Ortega), on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\n\n# Options\nQuestion ::: Which one of the following is a pair of employees at least one of whom must be on the team?\nis_valid(Or(on_team(Ortega), on_team(Schmidt))) ::: (A)\nis_valid(Or(on_team(Ortega), on_team(Wong))) ::: (B)\nis_valid(Or(on_team(Paine), on_team(Schmidt))) ::: (C)\nis_valid(Or(on_team(Thomson), on_team(Yoder))) ::: (D)\nis_valid(Or(on_team(Yoder), on_team(Zayre))) ::: (E)\n\n**Answer:** (D) Thomson and Yoder"
  },
  {
    "id": "ar_lsat_201310_3-G_3_13",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following is an acceptable schedule of the movies for this evening?",
    "options": [
      "A) screen 1: romance at 7 P.M., horror film at 9 P.M. screen 2: western at 7 P.M., sci-fi film at 9 P.M. screen 3: mystery at 8 P.M.",
      "B) screen 1: mystery at 7 P.M., romance at 9 P.M. screen 2: horror film at 7 P.M., sci-fi film at 9 P.M. screen 3: western at 8 P.M.",
      "C) screen 1: western at 7 P.M., sci-fi film at 9 P.M. screen 2: mystery at 7 P.M., horror film at 9 P.M. screen 3: romance at 8 P.M.",
      "D) screen 1: romance at 7 P.M., mystery at 9 P.M. screen 2: western at 7 P.M., horror film at 9 P.M. screen 3: sci-fi film at 8 P.M.",
      "E) screen 1: western at 7 P.M., mystery at 9 P.M. screen 2: sci-fi film at 7 P.M., romance at 9 P.M. screen 3: horror film at 8 P.M."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([screen1, screen2, screen3])\ntimes = EnumSort([7pm, 8pm, 9pm])\nassign = Function([movies] -> [screens, times])\n\n# Constraints\nForAll([m:movies], And(assign(m)[1] == screen1, assign(m)[1] == screen2, assign(m)[1] == screen3)) ::: Each movie is shown on one of the three screens\nForAll([m:movies], And(assign(m)[2] == 7pm, assign(m)[2] == 8pm, assign(m)[2] == 9pm)) ::: Each movie is shown at one of the times\nDistinct([m:movies], assign(m)) ::: Each movie is shown exactly once\nAnd(Count([m:movies], assign(m)[1] == screen1) == 2, Count([m:movies], assign(m)[2] == 7pm) == 2, Count([m:movies], assign(m)[2] == 9pm) == 2) ::: Screens 1 and 2 show two movies each at 7pm and 9pm\nassign(sci_fi)[1] != screen3 ::: Sci-fi film is not shown on screen 3\nassign(romance)[1] != screen2 ::: Romance is not shown on screen 2\nassign(horror)[1] != assign(mystery)[1] ::: Horror and mystery are on different screens\nExists([m1:movies, m2:movies], And(assign(western)[2] < assign(horror)[2])) ::: Western starts before horror\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule?\nis_model(assign(horror) == (screen1, 9pm) And assign(mystery) == (screen3, 8pm) And assign(romance) == (screen1, 7pm) And assign(sci_fi) == (screen2, 9pm) And assign(western) == (screen2, 7pm)) ::: (A)\nis_model(assign(horror) == (screen2, 7pm) And assign(mystery) == (screen1, 7pm) And assign(romance) == (screen1, 9pm) And assign(sci_fi) == (screen2, 9pm) And assign(western) == (screen3, 8pm)) ::: (B)\nis_model(assign(horror) == (screen2, 9pm) And assign(mystery) == (screen2, 7pm) And assign(romance) == (screen3, 8pm) And assign(sci_fi) == (screen1, 9pm) And assign(western) == (screen1, 7pm)) ::: (C)\nis_model(assign(horror) == (screen2, 9pm) And assign(mystery) == (screen1, 9pm) And assign(romance) == (screen1, 7pm) And assign(sci_fi) == (screen3, 8pm) And assign(western) == (screen2, 7pm)) ::: (D)\nis_model(assign(horror) == (screen3, 8pm) And assign(mystery) == (screen1, 9pm) And assign(romance) == (screen2, 9pm) And assign(sci_fi) == (screen2, 7pm) And assign(western) == (screen1, 7pm)) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_201310_3-G_3_14",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 2 this evening, listing the 7 P.M. movie first?",
    "options": [
      "A) the sci-fi film, the horror film",
      "B) the sci-fi film, the mystery",
      "C) the sci-fi film, the western",
      "D) the western, the horror film",
      "E) the western, the mystery"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([screen1, screen2, screen3])\ntimes = EnumSort([7pm, 8pm, 9pm])\nschedule = Function([movies] -> [screens, times])\n\n# Constraints\nDistinct([m:movies], schedule(m)) ::: Each movie is shown exactly once\nForAll([s:screens], Or(\n    And(Count([m:movies], schedule(m)[0] == s) == 2, \n        Exists([t1:times, t2:times], And(t1 == 7pm, t2 == 9pm, \n            ForAll([m:movies], Implies(schedule(m)[0] == s, Or(schedule(m)[1] == t1, schedule(m)[1] == t2)))))),\n    And(s == screen3, Count([m:movies], schedule(m)[0] == s) == 1, \n        ForAll([m:movies], Implies(schedule(m)[0] == s, schedule(m)[1] == 8pm)))\n)) ::: Screens 1 and 2 have two movies at 7pm and 9pm; screen3 has one at 8pm\nschedule(western)[1] < schedule(horror)[1] ::: Western starts before horror\nschedule(sci_fi)[0] != screen3 ::: Sci-fi not on screen3\nschedule(romance)[0] != screen2 ::: Romance not on screen2\nschedule(horror)[0] != schedule(mystery)[0] ::: Horror and mystery on different screens\n\n# Options\nQuestion ::: Which list CANNOT be screen2's movies (7pm first)?\nis_invalid(And(\n    schedule(sci_fi) == (screen2, 7pm),\n    schedule(western) == (screen2, 9pm)\n)) ::: (C)"
  },
  {
    "id": "ar_lsat_201310_3-G_3_15",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the western and the sci-fi film are scheduled to be shown on the same screen, then which one of the following could be true of this evening's schedule?",
    "options": [
      "A) The horror film is shown on screen 2.",
      "B) The mystery begins at 9 P.M.",
      "C) The romance is shown on screen 3.",
      "D) The sci-fi film begins at 7 P.M.",
      "E) The western begins at 8 P.M."
    ],
    "answer": "B",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201310_3-G_3_16",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the romance is scheduled to begin before the western does, then which one of the following must be true of this evening's schedule?",
    "options": [
      "A) The horror film is shown on screen 1.",
      "B) The mystery begins at 7 P.M.",
      "C) The mystery is shown on screen 2.",
      "D) The sci-fi film begins at 9 P.M.",
      "E) The sci-fi film is shown on screen 2."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([screen1, screen2, screen3])\ntimes = EnumSort([7pm, 8pm, 9pm])\nassign = Function([movies] -> [screens, times])\n\n# Constraints\nDistinct([m:movies], assign(m)) ::: Each movie is shown exactly once\nAnd(assign(western)@time < assign(horror)@time) ::: Western starts before horror\nNot(assign(sci_fi)@screen == screen3) ::: Sci-fi not on screen3\nNot(assign(romance)@screen == screen2) ::: Romance not on screen2\nassign(horror)@screen != assign(mystery)@screen ::: Horror and mystery on different screens\nassign(romance)@time < assign(western)@time ::: Romance before western\n\n# Options\nQuestion ::: If the romance is scheduled to begin before the western does, then which one of the following must be true?\nis_valid(assign(horror)@screen == screen1) ::: (A)\nis_valid(assign(mystery)@time == 7pm) ::: (B)\nis_valid(assign(mystery)@screen == screen2) ::: (C)\nis_valid(assign(sci_fi)@time == 9pm) ::: (D)\nis_valid(assign(sci_fi)@screen == screen2) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_3_17",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 1 this evening, listing the 7 P.M. movie first?",
    "options": [
      "A) the sci-fi film, the horror film",
      "B) the sci-fi film, the mystery",
      "C) the western, the horror film",
      "D) the western, the mystery",
      "E) the western, the sci-fi film"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([screen1, screen2, screen3])\ntimes = EnumSort([7pm, 8pm, 9pm])\nschedule = Function([movies] -> [screens, times])\n\n# Constraints\nDistinct([m:movies], schedule(m)) ::: Each movie is shown exactly once\nForAll([m:movies], Or(\n    And(schedule(m)[0] == screen1, Or(schedule(m)[1] == 7pm, schedule(m)[1] == 9pm)),\n    And(schedule(m)[0] == screen2, Or(schedule(m)[1] == 7pm, schedule(m)[1] == 9pm)),\n    And(schedule(m)[0] == screen3, schedule(m)[1] == 8pm)\n)) ::: Screens 1 and 2 have 7pm and 9pm shows; screen3 has 8pm\nCount([m:movies], schedule(m)[0] == screen1) == 2 ::: Screen1 shows two movies\nCount([m:movies], schedule(m)[0] == screen2) == 2 ::: Screen2 shows two movies\nCount([m:movies], schedule(m)[0] == screen3) == 1 ::: Screen3 shows one movie\nschedule(western)[1] < schedule(horror)[1] ::: Western starts before horror\nschedule(sci_fi)[0] != screen3 ::: Sci-fi not on screen3\nschedule(romance)[0] != screen2 ::: Romance not on screen2\nschedule(horror)[0] != schedule(mystery)[0] ::: Horror and mystery on different screens\n\n# Options\nQuestion ::: Which list CANNOT be screen1's movies (7pm first)?\nis_invalid(And(\n    schedule(sci_fi) == (screen1, 7pm),\n    schedule(horror) == (screen1, 9pm)\n)) ::: (A)\nis_invalid(And(\n    schedule(sci_fi) == (screen1, 7pm),\n    schedule(mystery) == (screen1, 9pm)\n)) ::: (B)\nis_invalid(And(\n    schedule(western) == (screen1, 7pm),\n    schedule(horror) == (screen1, 9pm)\n)) ::: (C)\nis_invalid(And(\n    schedule(western) == (screen1, 7pm),\n    schedule(mystery) == (screen1, 9pm)\n)) ::: (D)\nis_invalid(And(\n    schedule(western) == (screen1, 7pm),\n    schedule(sci_fi) == (screen1, 9pm)\n)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_3_18",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the sci-fi film and the romance are to be shown on the same screen, then which one of the following must be true of this evening's schedule?",
    "options": [
      "A) The western begins at 7 P.M.",
      "B) The sci-fi film begins at 9 P.M.",
      "C) The mystery begins at 8 P.M.",
      "D) The romance begins at 9 P.M.",
      "E) The horror film begins at 8 P.M."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([screen1, screen2, screen3])\ntimes = EnumSort([7pm, 8pm, 9pm])\nassign = Function([movies] -> [screens, times])\n\n# Constraints\nForAll([m:movies], And(assign(m) != (screen1, 8pm), assign(m) != (screen2, 8pm))) ::: Screens 1 and 2 have movies at 7pm and 9pm only\nassign(screen3) == 8pm ::: Screen 3 has only 8pm\nDistinct([m:movies], assign(m)) ::: Each movie is shown exactly once\nExists([s:screens, t1:times, t2:times], And(assign(western) = (s, t1), assign(horror) = (_, t2), t1 < t2)) ::: Western starts before horror\nassign(sci_fi) != (screen3, 8pm) ::: Sci-fi not on screen 3\nassign(romance) != (screen2, _) ::: Romance not on screen 2\nassign(horror) != assign(mystery) ::: Horror and mystery on different screens\nAnd(assign(sci_fi) = (s, _), assign(romance) = (s, _)) ::: Sci-fi and romance on same screen\n\n# Options\nQuestion ::: If the sci-fi film and the romance are to be shown on the same screen, then which one of the following must be true?\nis_valid(assign(western) = (_, 7pm)) ::: (A)\nis_valid(assign(sci_fi) = (_, 9pm)) ::: (B)\nis_valid(assign(mystery) = (screen3, 8pm)) ::: (C)\nis_valid(assign(romance) = (_, 9pm)) ::: (D)\nis_valid(assign(horror) = (screen3, 8pm)) ::: (E)\n\n**Answer:** (A) The western begins at 7 P.M."
  },
  {
    "id": "ar_lsat_201310_3-G_4_19",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following is an acceptable order for the lectures, from first to fifth?",
    "options": [
      "A) oystercatchers, petrels, rails, sandpipers, terns",
      "B) petrels, sandpipers, oystercatchers, terns, rails",
      "C) rails, sandpipers, terns, petrels, oystercatchers",
      "D) sandpipers, terns, oystercatchers, rails, petrels",
      "E) terns, petrels, sandpipers, oystercatchers, rails"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\npositions = EnumSort([1, 2, 3, 4, 5])\nlocations = EnumSort([GladwynHall, HowardAuditorium])\nlecture_bird = Function([positions] -> [birds])\nlecture_loc = Function([positions] -> [locations])\n\n# Constraints\nlecture_loc(1) == GladwynHall ::: The first lecture is in Gladwyn Hall\nlecture_loc(4) == HowardAuditorium ::: The fourth lecture is in Howard Auditorium\nCount([p:positions], lecture_loc(p) == GladwynHall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nExists([p:positions], And(lecture_bird(p) == sandpipers, lecture_loc(p) == HowardAuditorium, Exists([q:positions], And(lecture_bird(q) == oystercatchers, p < q)))) ::: The lecture on sandpipers is in Howard Auditorium and given earlier than oystercatchers\nExists([p:positions, q:positions], And(lecture_bird(p) == terns, lecture_bird(q) == petrels, p < q, lecture_loc(q) == GladwynHall)) ::: Terns lecture is before petrels, which is in Gladwyn Hall\nDistinct([p:positions], lecture_bird(p)) ::: Each lecture is on a different bird\n\n# Options\nQuestion ::: Which one of the following is an acceptable order for the lectures, from first to fifth?\nis_model(And(\n    lecture_bird(1) == terns,\n    lecture_bird(2) == petrels,\n    lecture_bird(3) == sandpipers,\n    lecture_bird(4) == oystercatchers,\n    lecture_bird(5) == rails\n)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_4_20",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following must be false?",
    "options": [
      "A) The first and second lectures are both in Gladwyn Hall.",
      "B) The second and third lectures are both in Howard Auditorium.",
      "C) The second and fifth lectures are both in Gladwyn Hall.",
      "D) The third and fourth lectures are both in Howard Auditorium.",
      "E) The third and fifth lectures are both in Gladwyn Hall"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nlectures = EnumSort([1, 2, 3, 4, 5])\nhalls = EnumSort([Gladwyn, Howard])\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nlocation = Function([lectures] -> [halls])\nbird = Function([lectures] -> [birds])\n\n# Constraints\nlocation(1) == Gladwyn ::: The first lecture is in Gladwyn Hall\nlocation(4) == Howard ::: The fourth lecture is in Howard Auditorium\nCount([l:lectures], location(l) == Gladwyn) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nExists([l1:lectures], And(location(l1) == Howard, bird(l1) == sandpipers, Exists([l2:lectures], And(bird(l2) == oystercatchers, l1 < l2)))) ::: The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers\nExists([l1:lectures, l2:lectures], And(bird(l1) == terns, bird(l2) == petrels, l1 < l2, location(l2) == Gladwyn)) ::: The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_invalid(And(location(1) == Gladwyn, location(2) == Gladwyn)) ::: (A)\nis_invalid(And(location(2) == Howard, location(3) == Howard)) ::: (B)\nis_invalid(And(location(2) == Gladwyn, location(5) == Gladwyn)) ::: (C)\nis_invalid(And(location(3) == Howard, location(4) == Howard)) ::: (D)\nis_invalid(And(location(3) == Gladwyn, location(5) == Gladwyn)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201310_3-G_4_21",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "If the lecture on terns is given in Howard Auditorium, which one of the following could be true of the third lecture?",
    "options": [
      "A) It is on oystercatchers and is in Gladwyn Hall.",
      "B) It is on rails and is in Howard Auditorium.",
      "C) It is on rails and is in Gladwyn Hall.",
      "D) It is on sandpipers and is in Howard Auditorium.",
      "E) It is on terns and is in Howard Auditorium."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201310_3-G_4_22",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following could be true of the fifth lecture?",
    "options": [
      "A) It is on oystercatchers and is in Gladwyn Hall.",
      "B) It is on petrels and is in Howard Auditorium.",
      "C) It is on rails and is in Howard Auditorium.",
      "D) It is on sandpipers and is in Howard Auditorium.",
      "E) It is on terns and is in Gladwyn Hall."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nlectures = EnumSort([1, 2, 3, 4, 5])\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nlocations = EnumSort([GladwynHall, HowardAuditorium])\nbird_assignment = Function([lectures] -> [birds])\nlocation_assignment = Function([lectures] -> [locations])\n\n# Constraints\nlocation_assignment(1) == GladwynHall ::: The first lecture is in Gladwyn Hall\nlocation_assignment(4) == HowardAuditorium ::: The fourth lecture is in Howard Auditorium\nCount([l:lectures], location_assignment(l) == GladwynHall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nExists([l:lectures], And(location_assignment(l) == HowardAuditorium, bird_assignment(l) == sandpipers, l < Find([m:lectures], bird_assignment(m) == oystercatchers))) ::: The lecture on sandpipers is in Howard Auditorium and given earlier than oystercatchers\nFind([m:lectures], bird_assignment(m) == terns) < Find([m:lectures], And(bird_assignment(m) == petrels, location_assignment(m) == GladwynHall)) ::: Terns lecture is earlier than petrels, which is in Gladwyn Hall\n\n# Options\nQuestion ::: Which one of the following could be true of the fifth lecture?\nis_sat(And(bird_assignment(5) == oystercatchers, location_assignment(5) == GladwynHall)) ::: (A)\nis_sat(And(bird_assignment(5) == petrels, location_assignment(5) == HowardAuditorium)) ::: (B)\nis_sat(And(bird_assignment(5) == rails, location_assignment(5) == HowardAuditorium)) ::: (C)\nis_sat(And(bird_assignment(5) == sandpipers, location_assignment(5) == HowardAuditorium)) ::: (D)\nis_sat(And(bird_assignment(5) == terns, location_assignment(5) == GladwynHall)) ::: (E)"
  },
  {
    "id": "ar_lsat_201310_3-G_4_23",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "If the third lecture is on sandpipers, which one of the following could be true?",
    "options": [
      "A) The second lecture is on oystercatchers and is in Gladwyn Hall.",
      "B) The fifth lecture is on oystercatchers and is in Howard Auditorium.",
      "C) The second lecture is on rails and is in Howard Auditorium.",
      "D) The second lecture is on terns and is in Gladwyn Hall.",
      "E) The fourth lecture is on terns and is in Howard Auditorium."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nlectures = EnumSort([1, 2, 3, 4, 5])\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nlocations = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nbird_lecture = Function([lectures] -> [birds])\nlocation_lecture = Function([lectures] -> [locations])\n\n# Constraints\nDistinct([l:lectures], bird_lecture(l)) ::: each lecture on a different bird\nlocation_lecture(1) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlocation_lecture(4) == Howard_Auditorium ::: The fourth lecture is in Howard Auditorium\nCount([l:lectures], location_lecture(l) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nAnd(location_lecture(lecture_sandpipers) == Howard_Auditorium, lecture_sandpipers < lecture_oystercatchers) ::: The lecture on sandpipers is in Howard Auditorium and given earlier than oystercatchers\nAnd(lecture_terns < lecture_petrels, location_lecture(lecture_petrels) == Gladwyn_Hall) ::: The lecture on terns is earlier than the lecture on petrels, which is in Gladwyn Hall\nbird_lecture(3) == sandpipers ::: The third lecture is on sandpipers (given in question)\n\n# Options\nQuestion ::: If the third lecture is on sandpipers, which one of the following could be true?\nis_sat(And(bird_lecture(2) == oystercatchers, location_lecture(2) == Gladwyn_Hall)) ::: (A)\nis_sat(And(bird_lecture(5) == oystercatchers, location_lecture(5) == Howard_Auditorium)) ::: (B)\nis_sat(And(bird_lecture(2) == rails, location_lecture(2) == Howard_Auditorium)) ::: (C)\nis_sat(And(bird_lecture(2) == terns, location_lecture(2) == Gladwyn_Hall)) ::: (D)\nis_sat(And(bird_lecture(4) == terns, location_lecture(4) == Howard_Auditorium)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_201412_2-G_1_1",
    "context": "A concert is given by a six-member band\u00e2\u20ac\u201dguitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Which one of the following is an acceptable ordering of solos from first to last?",
    "options": [
      "A) violinist, percussionist, saxophonist, guitarist, trumpeter, keyboard player",
      "B) percussionist, violinist, keyboard player, trumpeter, saxophonist, guitarist",
      "C) violinist, trumpeter, saxophonist, percussionist, keyboard player, guitarist",
      "D) keyboard player, trumpeter, violinist, saxophonist, guitarist, percussionist",
      "E) guitarist, violinist, keyboard player, percussionist, saxophonist, trumpeter"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nmembers = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo = Function([members] -> [int])\nForAll([m:members], And(1 <= solo(m), solo(m) <= 6))\n\n# Constraints\nDistinct([m:members], solo(m)) ::: each member performs exactly one solo\nsolo(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo(percussionist) < solo(keyboard_player) ::: The percussionist performs a solo before the keyboard player\nAnd(solo(violinist) < solo(keyboard_player), solo(keyboard_player) < solo(guitarist)) ::: The keyboard player performs after the violinist and before the guitarist\nOr(\n    And(solo(saxophonist) > solo(percussionist), solo(saxophonist) < solo(trumpeter)),\n    And(solo(saxophonist) > solo(trumpeter), solo(saxophonist) < solo(percussionist))\n) ::: Saxophonist performs after either percussionist or trumpeter but not both\n\n# Options\nQuestion ::: Which one of the following is an acceptable ordering of solos from first to last?\nis_model(solo(violinist) == 1 & solo(percussionist) == 2 & solo(saxophonist) == 3 & solo(guitarist) == 4 & solo(trumpeter) == 5 & solo(keyboard_player) == 6) ::: (A)\nis_model(solo(percussionist) == 1 & solo(violinist) == 2 & solo(keyboard_player) == 3 & solo(trumpeter) == 4 & solo(saxophonist) == 5 & solo(guitarist) == 6) ::: (B)\nis_model(solo(violinist) == 1 & solo(trumpeter) == 2 & solo(saxophonist) == 3 & solo(percussionist) == 4 & solo(keyboard_player) == 5 & solo(guitarist) == 6) ::: (C)\nis_model(solo(keyboard_player) == 1 & solo(trumpeter) == 2 & solo(violinist) == 3 & solo(sophonophonist) == 4 & solo(guitarist) == 5 & solo(percussionist) == 6) ::: (D)\nis_model(solo(guitarist) == 1 & solo(violinist) == 2 & solo(keyboard_player) == 3 & solo(percussionist) == 4 & solo(saxophonist) == 5 & solo(trumpeter) == 6) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_201412_2-G_1_2",
    "context": "A concert is given by a six-member band\u00e2\u20ac\u201dguitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "If the percussionist performs a solo at some time before the saxophonist does, then which one of the following must be true?",
    "options": [
      "A) The percussionist performs the first solo.",
      "B) The percussionist performs the second solo.",
      "C) The violinist performs a solo at some time before the saxophonist does.",
      "D) The percussionist performs a solo at some time before the trumpeter does.",
      "E) The saxophonist performs a solo at some time before the keyboard player does."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nmembers = EnumSort([guitarist, keyboard, percussionist, saxophonist, trumpeter, violinist])\nsolo = Function([members] -> [int])\nForAll([m:members], And(1 <= solo(m), solo(m) <= 6))\n\n# Constraints\nDistinct([m:members], solo(m)) ::: Each member performs exactly one solo\nsolo(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo(percussionist) < solo(keyboard) ::: percussionist before keyboard\nAnd(solo(violinist) < solo(keyboard), solo(keyboard) < solo(guitarist)) ::: keyboard after violinist and before guitarist\nAnd(\n    Or(solo(saxophonist) > solo(percussionist), solo(saxophonist) > solo(trumpeter)),\n    Not(And(solo(saxophonist) > solo(percussionist), solo(saxophonist) > solo(trumpeter)))\n) ::: sax after exactly one of percussionist or trumpeter\nsolo(percussionist) < solo(saxophonist) ::: added condition: percussionist before saxophonist\n\n# Options\nQuestion ::: If the percussionist performs a solo at some time before the saxophonist does, then which one of the following must be true?\nis_valid(solo(percussionist) == 1) ::: (A)\nis_valid(solo(percussionist) == 2) ::: (B)\nis_valid(solo(violinist) < solo(saxophonist)) ::: (C)\nis_valid(solo(percussionist) < solo(trumpeter)) ::: (D)\nis_valid(solo(saxophonist) < solo(keyboard)) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_1_3",
    "context": "A concert is given by a six-member band\u00e2\u20ac\u201dguitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Each of the following must be false EXCEPT:",
    "options": [
      "A) The keyboard player performs the first solo.",
      "B) The guitarist performs the second solo.",
      "C) The guitarist performs a solo at some time before the saxophonist does.",
      "D) The guitarist performs a solo at some time before the percussionist does.",
      "E) The keyboard player performs a solo at some time before the saxophonist does."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nroles = EnumSort([guitarist, keyboard, percussionist, saxophonist, trumpeter, violinist])  \nposition = Function([roles] -> [int])  \nForAll([r:roles], And(1 <= position(r), position(r) <= 6))  \n\n# Constraints  \nDistinct([r:roles], position(r)) ::: each member performs exactly one solo  \nposition(guitarist) != 4 ::: The guitarist does not perform the fourth solo  \nposition(percussionist) < position(keyboard) ::: percussionist before keyboard  \nAnd(position(violinist) < position(keyboard), position(keyboard) < position(guitarist)) ::: keyboard after violinist and before guitarist  \nOr(  \n    And(position(saxophonist) > position(percussionist), position(saxophonist) <= position(trumpeter)),  \n    And(position(saxophonist) > position(trumpeter), position(saxophonist) <= position(percussionist))  \n) ::: saxophonist after exactly one of percussionist or trumpeter  \n\n# Options  \nQuestion ::: Each of the following must be false EXCEPT:  \nis_invalid(position(keyboard) == 1) ::: (A)  \nis_invalid(position(guitarist) == 2) ::: (B)  \nis_invalid(Exists([r:roles], position(guitarist) < position(saxophonist))) ::: (C)  \nis_invalid(position(guitarist) < position(percussionist)) ::: (D)  \nis_invalid(position(keyboard) < position(saxophonist)) ::: (E)  \n\n**Answer**  \n(E) The keyboard player performs a solo at some time before the saxophonist does."
  },
  {
    "id": "ar_lsat_201412_2-G_1_4",
    "context": "A concert is given by a six-member band\u00e2\u20ac\u201dguitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Which one of the following CANNOT perform the third",
    "options": [
      "A) guitarist",
      "B) keyboard player",
      "C) saxophonist",
      "D) trumpeter",
      "E) violinist"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nmembers = EnumSort([guitarist, keyboard, percussionist, saxophonist, trumpeter, violinist])\nposition = Function([members] -> [int])\nForAll([m:members], And(1 <= position(m), position(m) <= 6))\n\n# Constraints\nDistinct([m:members], position(m)) ::: each member performs exactly one solo\nposition(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nposition(percussionist) < position(keyboard) ::: Percussionist performs before keyboard\nAnd(position(violinist) < position(keyboard), position(keyboard) < position(guitarist)) ::: Keyboard after violinist and before guitarist\nOr(And(position(saxophonist) > position(percussionist), position(saxophonist) <= position(trumpeter)), \n   And(position(saxophonist) > position(trumpeter), position(saxophonist) <= position(percussionist))) ::: Saxophonist after exactly one of percussionist or trumpeter\n\n# Options\nQuestion ::: Which one of the following CANNOT perform the third solo?\nis_invalid(Exists([m:members], And(position(m) == 3, m == guitarist))) ::: (A)\nis_invalid(Exists([m:members], And(position(m) == 3, m == keyboard))) ::: (B)\nis_invalid(Exists([m:members], And(position(m) == 3, m == saxophonist))) ::: (C)\nis_invalid(Exists([m:members], And(position(m) == 3, m == trumpeter))) ::: (D)\nis_invalid(Exists([m:members], And(position(m) == 3, m == violinist))) ::: (E)\n\n**Answer:** (A) guitarist"
  },
  {
    "id": "ar_lsat_201412_2-G_1_5",
    "context": "A concert is given by a six-member band\u00e2\u20ac\u201dguitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "If the violinist performs the fourth solo, then each of the following must be true EXCEPT:",
    "options": [
      "A) The percussionist performs a solo at some time before the violinist does.",
      "B) The trumpeter performs a solo at some time before the violinist does.",
      "C) The trumpeter performs a solo at some time before the guitarist does.",
      "D) The saxophonist performs a solo at some time before the violinist does.",
      "E) The trumpeter performs a solo at some time before the saxophonist does."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nroles = EnumSort([guitarist, keyboard, percussionist, saxophonist, trumpeter, violinist])  \npositions = EnumSort([1, 2, 3, 4, 5, 6])  \nsolo = Function([roles] -> [positions])  \n\n# Constraints  \nDistinct([r:roles], solo(r)) ::: Each member performs exactly one solo  \nsolo(guitarist) != 4 ::: The guitarist does not perform the fourth solo  \nsolo(percussionist) < solo(keyboard) ::: Percussionist before keyboard  \nAnd(solo(keyboard) > solo(violinist), solo(keyboard) < solo(guitarist)) ::: Keyboard after violinist and before guitarist  \nOr(  \n    And(solo(saxophonist) > solo(percussionist), solo(saxophonist) <= solo(trumpeter)),  \n    And(solo(saxophonist) > solo(trumpeter), solo(saxophonist) <= solo(percussionist))  \n) ::: Sax after exactly one of percussionist or trumpeter  \nsolo(violinist) == 4 ::: Violinist performs the fourth solo  \n\n# Options  \nQuestion ::: Each of the following must be true EXCEPT:  \nis_exception(ForAll([p:positions], solo(percussionist) < 4)) ::: (A)  \nis_exception(ForAll([p:positions], solo(trumpeter) < 4)) ::: (B)  \nis_exception(ForAll([p:positions], solo(trumpeter) < 6)) ::: (C)  \nis_exception(ForAll([p:positions], solo(saxophonist) < 4)) ::: (D)  \nis_exception(ForAll([p:positions], solo(trumpeter) < solo(saxophonist))) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_2_6",
    "context": "Four art historians\u00e2\u20ac\u201dFarley, Garcia, Holden, and Jiang\u00e2\u20ac\u201dwill give a series of four public lectures, each lecture on a different topic\u00e2\u20ac\u201dlithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following is an acceptable ordering of the lectures, from first to fourth?",
    "options": [
      "A) Farley: sculptures; Holden: lithographs; Garcia: oil paintings; Jiang: watercolors",
      "B) Farley: watercolors; Jiang: oil paintings; Holden: sculptures; Garcia: lithographs",
      "C) Garcia: sculptures; Farley: watercolors; Holden: oil paintings; Jiang: lithographs",
      "D) Holden: oil paintings; Jiang: watercolors; Farley: lithographs; Garcia: sculptures",
      "E) Holden: sculptures; Farley: watercolors; Jiang: oil paintings; Garcia: lithographs"
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nhistorians = EnumSort([Farley, Garcia, Holden, Jiang])  \ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])  \nlecture = Function([historians] -> [topics])  \norder = Function([historians] -> [int])  \n\n# Constraints  \nForAll([h:historians], And(1 <= order(h), order(h) <= 4)) ::: lectures are ordered 1-4  \nDistinct([h:historians], order(h)) ::: each historian gives one lecture  \nDistinct([h:historians], lecture(h)) ::: each topic used once  \n\nAnd(order(oil_paintings) < order(lithographs), order(watercolors) < order(lithographs)) ::: oil/watercolors before lithographs  \norder(Farley) < order(oil_paintings) ::: Farley before oil  \nAnd(order(Holden) < order(Garcia), order(Holden) < order(Jiang)) ::: Holden before Garcia/Jiang  \n\n# Options  \nQuestion ::: Which one of the following is an acceptable ordering?  \nis_model(And(  \n    lecture(Holden) == sculptures,  \n    lecture(Farley) == watercolors,  \n    lecture(Jiang) == oil_paintings,  \n    lecture(Garcia) == lithographs,  \n    order(Holden) == 1,  \n    order(Farley) == 2,  \n    order(Jiang) == 3,  \n    order(Garcia) == 4  \n)) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_2_7",
    "context": "Four art historians\u00e2\u20ac\u201dFarley, Garcia, Holden, and Jiang\u00e2\u20ac\u201dwill give a series of four public lectures, each lecture on a different topic\u00e2\u20ac\u201dlithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) Farley's lecture is earlier than the sculptures lecture.",
      "B) Holden's lecture is earlier than the lithographs lecture.",
      "C) The sculptures lecture is earlier than Garcia's lecture.",
      "D) The sculptures lecture is earlier than Jiang's lecture.",
      "E) The watercolors lecture is earlier than Garcia's lecture."
    ],
    "answer": "B",
    "logic_program": "# Declarations\npeople = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\nschedule = Function([people] -> [int])  # Maps each person to their lecture position (1-4)\ntopic_of = Function([people] -> [topics])  # Maps each person to their lecture topic\n\n# Constraints\nDistinct([p:people], schedule(p)) ::: Each lecture is at a different time\nDistinct([p:people], topic_of(p)) ::: Each topic is covered exactly once\nForAll([p:people], And(1 <= schedule(p), schedule(p) <= 4)) ::: Valid positions\n\nAnd(schedule(oil_paintings) < schedule(lithographs), schedule(watercolors) < schedule(lithographs)) ::: Oil and watercolors before lithographs\nschedule(Farley) < schedule(oil_paintings) ::: Farley before oil paintings\nAnd(schedule(Holden) < schedule(Garcia), schedule(Holden) < schedule(Jiang)) ::: Holden before Garcia and Jiang\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(schedule(Farley) < schedule(sculptures)) ::: (A)\nis_valid(schedule(Holden) < schedule(lithographs)) ::: (B)\nis_valid(schedule(sculptures) < schedule(Garcia)) ::: (C)\nis_valid(schedule(sculptures) < schedule(Jiang)) ::: (D)\nis_valid(schedule(watercolors) < schedule(Garcia)) ::: (E)\n\n**Answer:** (B) Holden's lecture is earlier than the lithographs lecture."
  },
  {
    "id": "ar_lsat_201412_2-G_2_8",
    "context": "Four art historians\u00e2\u20ac\u201dFarley, Garcia, Holden, and Jiang\u00e2\u20ac\u201dwill give a series of four public lectures, each lecture on a different topic\u00e2\u20ac\u201dlithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "If the watercolors lecture is third, which one of the following could be true?",
    "options": [
      "A) Farley gives the watercolors lecture.",
      "B) Garcia gives the oil paintings lecture.",
      "C) Garcia gives the sculptures lecture.",
      "D) Holden gives the sculptures lecture.",
      "E) Jiang gives the lithographs lecture."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nhistorians = EnumSort([Farley, Garcia, Holden, Jiang])  \ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])  \nposition = EnumSort([1, 2, 3, 4])  \nlecture_topic = Function([historians] -> [topics])  \nschedule = Function([position] -> [historians])  \n\n# Constraints  \nDistinct([h:historians], schedule(h)) ::: Each historian gives exactly one lecture  \nForAll([p:position], Distinct([t:topics], lecture_topic(schedule(p)))) ::: Each topic is used exactly once  \nImplies(lecture_topic(schedule(3)) == watercolors, lecture_topic(schedule(4)) == lithographs) ::: Lithographs must be after watercolors  \nForAll([p:position], Or(lecture_topic(schedule(p)) == oil_paintings, lecture_topic(schedule(p)) == watercolors) >> p < 4) ::: Oil and watercolors before lithographs  \nExists([p:position], lecture_topic(schedule(p)) == oil_paintings) ::: Oil paintings exists  \nExists([p:position], lecture_topic(schedule(p)) == watercolors) ::: Watercolors exists  \nlecture_topic(schedule(3)) == watercolors ::: Watercolors is third  \nForAll([h:historians], Implies(h == Farley, Exists([p:position], schedule(p) == Farley And p < Exists([q:position], lecture_topic(schedule(q)) == oil_paintings)))) ::: Farley before oil paintings  \nForAll([h:historians], Implies(h == Holden, Exists([p:position], schedule(p) == Holden And p < Exists([q:position], schedule(q) == Garcia) And p < Exists([r:position], schedule(r) == Jiang)))) ::: Holden before Garcia and Jiang  \n\n# Options  \nQuestion ::: If the watercolors lecture is third, which one of the following could be true?  \nis_sat(lecture_topic(Farley) == watercolors) ::: (A)  \nis_sat(lecture_topic(Garcia) == oil_paintings) ::: (B)  \nis_sat(lecture_topic(Garcia) == sculptures) ::: (C)  \nis_sat(lecture_topic(Holden) == sculptures) ::: (D)  \nis_sat(lecture_topic(Jiang) == lithographs) ::: (E)  \n\n**Answer:** (E) Jiang gives the lithographs lecture."
  },
  {
    "id": "ar_lsat_201412_2-G_2_9",
    "context": "Four art historians\u00e2\u20ac\u201dFarley, Garcia, Holden, and Jiang\u00e2\u20ac\u201dwill give a series of four public lectures, each lecture on a different topic\u00e2\u20ac\u201dlithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following CANNOT be true?",
    "options": [
      "A) Farley gives the lithographs lecture.",
      "B) Garcia gives the sculptures lecture.",
      "C) Garcia gives the watercolors lecture.",
      "D) Holden gives the oil paintings lecture.",
      "E) Jiang gives the watercolors lecture."
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201412_2-G_2_10",
    "context": "Four art historians\u00e2\u20ac\u201dFarley, Garcia, Holden, and Jiang\u00e2\u20ac\u201dwill give a series of four public lectures, each lecture on a different topic\u00e2\u20ac\u201dlithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "If Garcia gives the sculptures lecture, which one of the following could be true?",
    "options": [
      "A) The lithographs lecture is third.",
      "B) The oil paintings lecture is third.",
      "C) The sculptures lecture is first.",
      "D) The sculptures lecture is second.",
      "E) The watercolors lecture is second."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \npeople = EnumSort([Farley, Garcia, Holden, Jiang])  \ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])  \npositions = EnumSort([1, 2, 3, 4])  \nassign_person = Function([positions] -> [people])  \nassign_topic = Function([positions] -> [topics])  \n\n# Constraints  \nForAll([p:positions], Distinct([q:positions], assign_person(p))) ::: Each person gives exactly one lecture  \nForAll([p:positions], Distinct([q:positions], assign_topic(p))) ::: Each topic is used exactly once  \nassign_topic(4) == lithographs ::: Lithographs must be after oil_paintings and watercolors (handled via ordering)  \nForAll([p:positions], Implies(assign_topic(p) == oil_paintings, Exists([q:positions], And(q < p, assign_topic(q) == watercolors)))) ::: Oil paintings and watercolors before lithographs  \nForAll([p:positions], Implies(assign_topic(p) == oil_paintings, assign_person(p) != Farley)) ::: Farley's lecture is before oil_paintings  \nExists([p:positions], And(assign_person(p) == Farley, p < Exists([q:positions], assign_topic(q) == oil_paintings))) ::: Farley's lecture is before oil_paintings  \nForAll([p:positions], Implies(assign_person(p) == Holden, p < Exists([q:positions], Or(assign_person(q) == Garcia, assign_person(q) == Jiang)))) ::: Holden's lecture is before Garcia's and Jiang's  \nassign_person(Exists([p:positions], assign_topic(p) == sculptures)) == Garcia ::: Garcia gives the sculptures lecture  \n\n# Options  \nQuestion ::: If Garcia gives the sculptures lecture, which one of the following could be true?  \nis_sat(assign_topic(3) == lithographs) ::: (A)  \nis_sat(assign_topic(3) == oil_paintings) ::: (B)  \nis_sat(assign_topic(1) == sculptures) ::: (C)  \nis_sat(assign_topic(2) == sculptures) ::: (D)  \nis_sat(assign_topic(2) == watercolors) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_3_11",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "Which one of the following could be the colors of the three rugs?",
    "options": [
      "A) forest only; turquoise only; olive, peach, and white",
      "B) forest only; turquoise only; olive, peach, and yellow",
      "C) peach only; turquoise only; forest, olive, and white",
      "D) yellow only; forest and turquoise; olive and peach",
      "E) yellow only; olive and peach; turquoise and white"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five of the six colors are used\nForAll([c:colors], Implies(used(c), ExistsOne([r:rugs], in_rug(c, r)))) ::: each used color is in exactly one rug\nForAll([r:rugs], Or(\n    ExistsOne([c:colors], in_rug(c, r)),  # solid\n    Exists([c1,c2,c3:colors], And(\n        Distinct([c1,c2,c3]),\n        in_rug(c1, r),\n        in_rug(c2, r),\n        in_rug(c3, r)\n    ))  # multicolored (three colors)\n)) ::: each rug is either solid or multicolored (exactly three colors)\nForAll([r:rugs], Implies(in_rug(white, r), Count([c:colors], in_rug(c, r)) == 3)) ::: white requires two other colors\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive implies peach in the same rug\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\n\n# Options\nQuestion ::: Which one of the following could be the colors of the three rugs?\nis_sat(\n    And(\n        in_rug(forest, rug1) \u2227 ForAll([c:colors], in_rug(c, rug1) == (c == forest)),\n        in_rug(turquoise, rug2) \u2227 ForAll([c:colors], in_rug(c, rug2) == (c == turquoise)),\n        And(in_rug(olive, rug3), in_rug(peach, rug3), in_rug(white, rug3)) \u2227 ForAll([c:colors], in_rug(c, rug3) == Or(c == olive, c == peach, c == white))\n    )\n) ::: (A)\n... (similar for B, C, D, E) ..."
  },
  {
    "id": "ar_lsat_201412_2-G_3_12",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) There are no multicolored rugs in which forest is used.",
      "B) There are no multicolored rugs in which turquoise is used.",
      "C) Peach is used in one of the rugs.",
      "D) Turquoise is used in one of the rugs.",
      "E) Yellow is used in one of the rugs."
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five of the six colors are used\nForAll([c:colors], Implies(used(c), Exists([r:rugs], in_rug(c, r)))) ::: each used color is in exactly one rug\nForAll([c:colors, r:rugs], Implies(in_rug(c, r), used(c))) ::: only used colors are in rugs\nForAll([r:rugs], Or(\n    Exists([c:colors], ForAll([c2:colors], Implies(in_rug(c2, r), c2 == c))),  # solid\n    Exists([c1:colors, c2:colors, c3:colors], And(\n        Distinct([c1, c2, c3]),\n        ForAll([cx:colors], in_rug(cx, r) == Or(cx == c1, cx == c2, cx == c3))\n    ))  # multicolored (up to 3)\n)) ::: each rug is solid or multicolored\nForAll([r:rugs], Implies(in_rug(white, r), Count([c:colors], in_rug(c, r)) == 3)) ::: any rug with white has two other colors\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive requires peach in the same rug\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([r:rugs], Implies(Exists([c:colors], And(in_rug(c, r), c == forest)), Count([c:colors], in_rug(c, r)) == 1))) ::: (A)\nis_valid(ForAll([r:rugs], Implies(Exists([c:colors], And(in_rug(c, r), c == turquoise)), Count([c:colors], in_rug(c, r)) == 1))) ::: (B)\nis_valid(used(peach)) ::: (C)\nis_valid(used(turquoise)) ::: (D)\nis_valid(used(yellow)) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_3_13",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If one of the rugs is solid peach, which one of the following must be true?",
    "options": [
      "A) One of the rugs is solid forest.",
      "B) One of the rugs is solid turquoise.",
      "C) One of the rugs is solid yellow.",
      "D) Forest and white are used together in a rug.",
      "E) White and yellow are used together in a rug."
    ],
    "answer": "E",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five of the six colors are used\nForAll([c:colors], Implies(used(c), ExistsExactlyOne([r:rugs], in_rug(c, r)))) ::: each used color is in exactly one rug\nForAll([r:rugs], Or(\n    ExistsExactlyOne([c:colors], in_rug(c, r)),  # solid\n    Exists([c1,c2,c3:colors], And(\n        Distinct([c1,c2,c3]),\n        ForAll([c:colors], in_rug(c, r) == Or(c == c1, c == c2, c == c3))\n    ))  # multicolored (3 colors)\n)) ::: rugs are either solid or multicolored (exactly 3 colors)\nForAll([r:rugs], Implies(in_rug(white, r), Count([c:colors], in_rug(c, r)) == 3)) ::: white must be in a 3-color rug\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive requires peach in same rug\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\nExistsExactlyOne([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == peach))) ::: one rug is solid peach\n\n# Options\nQuestion ::: If one of the rugs is solid peach, which one of the following must be true?\nis_valid(Exists([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == forest)))) ::: (A)\nis_valid(Exists([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == turquoise)))) ::: (B)\nis_valid(Exists([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == yellow)))) ::: (C)\nis_valid(Exists([r:rugs], And(in_rug(forest, r), in_rug(white, r)))) ::: (D)\nis_valid(Exists([r:rugs], And(in_rug(white, r), in_rug(yellow, r)))) ::: (E)\n\n**Answer:** (E) White and yellow are used together in a rug."
  },
  {
    "id": "ar_lsat_201412_2-G_3_14",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If there are exactly two solid rugs, then the colors of those two rugs CANNOT be",
    "options": [
      "A) forest and peach",
      "B) forest and yellow",
      "C) peach and turquoise",
      "D) peach and yellow",
      "E) turquoise and yellow"
    ],
    "answer": "D",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five colors are used\nForAll([c:colors], Implies(used(c), Count([r:rugs], in_rug(c, r)) == 1)) ::: each color used in exactly one rug\nForAll([r:rugs], Or(\n    Count([c:colors], in_rug(c, r)) == 1,  # solid\n    Count([c:colors], in_rug(c, r)) == 3   # multicolored\n)) ::: rugs are either solid or multicolored\nForAll([r:rugs], Implies(in_rug(white, r), Count([c:colors], in_rug(c, r)) == 3)) ::: white requires two other colors\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive requires peach\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\nCount([r:rugs], Count([c:colors], in_rug(c, r)) == 1) == 2 ::: exactly two solid rugs\n\n# Options\nQuestion ::: If there are exactly two solid rugs, then the colors of those two rugs CANNOT be\nis_invalid(And(\n    in_rug(peach, rug1), Count([c:colors], in_rug(c, rug1)) == 1,\n    in_rug(yellow, rug2), Count([c:colors], in_rug(c, rug2)) == 1\n)) ::: (D)"
  },
  {
    "id": "ar_lsat_201412_2-G_3_15",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If forest and peach are used together in a rug, which one of the following could be true?",
    "options": [
      "A) There is exactly one solid rug.",
      "B) White is not used in any of the rugs.",
      "C) Yellow is not used in any of the rugs.",
      "D) Turquoise and white are used together in a rug.",
      "E) Turquoise and yellow are used together in a rug."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five colors are used\nForAll([c:colors], Implies(used(c), Exists([r:rugs], in_rug(c, r)))) ::: each used color is in exactly one rug\nForAll([r:rugs, c1:colors, c2:colors], Implies(And(in_rug(c1, r), in_rug(c2, r)), c1 == c2)) ::: solid rugs have one color; multicolored have multiple\nForAll([r:rugs], Implies(Exists([c:colors], And(in_rug(white, r), in_rug(c, r))), Count([c:colors], in_rug(c, r)) == 3)) ::: white requires two other colors\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive requires peach\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\nExists([r:rugs], And(in_rug(forest, r), in_rug(peach, r))) ::: forest and peach are together in a rug\n\n# Options\nQuestion ::: If forest and peach are used together in a rug, which one of the following could be true?\nis_sat(And(Count([r:rugs], Count([c:colors], in_rug(c, r)) == 1) == 1, ForAll([r:rugs], Count([c:colors], in_rug(c, r)) >= 1))) ::: (A)\nis_sat(Not(used(white))) ::: (B)\nis_sat(Not(used(yellow))) ::: (C)\nis_sat(Exists([r:rugs], And(in_rug(turquoise, r), in_rug(white, r)))) ::: (D)\nis_sat(Exists([r:rugs], And(in_rug(turquoise, r), in_rug(yellow, r)))) ::: (E)\n\n**Answer:** (B) White is not used in any of the rugs."
  },
  {
    "id": "ar_lsat_201412_2-G_3_16",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available\u00e2\u20ac\u201dforest, olive, peach, turquoise, white, and yellow\u00e2\u20ac\u201dexactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid\u00e2\u20ac\u201dwoven in a single color\u00e2\u20ac\u201dor multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If one of the rugs is solid yellow, then any of the following could be true EXCEPT:",
    "options": [
      "A) There is exactly one solid color rug.",
      "B) One of the rugs is solid forest.",
      "C) Turquoise is not used in any of the rugs.",
      "D) Forest and olive are used together in a rug.",
      "E) Peach and white are used together in a rug."
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors] -> [bool])\nin_rug = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c)) == 5 ::: exactly five colors are used\nForAll([c:colors], Implies(used(c), Exists([r:rugs], in_rug(c, r)))) ::: each used color is in exactly one rug\nForAll([c:colors, r:rugs], Implies(in_rug(c, r), used(c))) ::: colors in rugs are used\nForAll([r:rugs], Or(\n    Exists([c:colors], ForAll([c2:colors], in_rug(c2, r) == (c2 == c))),  # solid rug\n    Exists([c1:colors, c2:colors, c3:colors], And(\n        Distinct([c1, c2, c3]),\n        ForAll([cx:colors], in_rug(cx, r) == Or(cx == c1, cx == c2, cx == c3))\n    ))  # multicolored rug (up to 3 colors)\n)) ::: rugs are solid or multicolored\nForAll([r:rugs], Implies(in_rug(white, r), Count([c:colors], in_rug(c, r)) == 3)) ::: white requires two other colors\nForAll([r:rugs], Implies(in_rug(olive, r), in_rug(peach, r))) ::: olive requires peach\nForAll([r:rugs], Not(And(in_rug(forest, r), in_rug(turquoise, r)))) ::: forest and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(turquoise, r)))) ::: peach and turquoise not together\nForAll([r:rugs], Not(And(in_rug(peach, r), in_rug(yellow, r)))) ::: peach and yellow not together\nExists([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == yellow))) ::: one rug is solid yellow\n\n# Options\nQuestion ::: If one of the rugs is solid yellow, then any of the following could be true EXCEPT:\nis_exception(is_sat(Count([r:rugs], Exists([c:colors], ForAll([cx:colors], in_rug(cx, r) == (cx == c)))) == 1)) ::: (A)\nis_exception(is_sat(Exists([r:rugs], ForAll([c:colors], in_rug(c, r) == (c == forest))))) ::: (B)\nis_exception(is_sat(Not(used(turquoise)))) ::: (C)\nis_exception(is_sat(Exists([r:rugs], And(in_rug(forest, r), in_rug(olive, r))))) ::: (D)\nis_exception(is_sat(Exists([r:rugs], And(in_rug(peach, r), in_rug(white, r))))) ::: (E)\n\n**Answer:** (D) Forest and olive are used together in a rug."
  },
  {
    "id": "ar_lsat_201412_2-G_4_17",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following is an acceptable assignment of photographers to the two graduation ceremonies?",
    "options": [
      "A) Silva University: Gonzalez, Lai Thorne University: Frost, Heideck, Mays",
      "B) Silva University: Gonzalez, Mays Thorne University: Knutson, Lai",
      "C) Silva University: Frost, Gonzalez, Heideck Thorne University: Knutson, Lai, Mays",
      "D) Silva University: Frost, Heideck, Mays Thorne University: Gonzalez, Lai",
      "E) Silva University: Frost, Heideck, Mays Thorne University: Gonzalez, Knutson, Lai"
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])  \nceremonies = EnumSort([Silva, Thorne])  \nassigned = Function([photographers, ceremonies] -> [bool])  \n\n# Constraints  \nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: each ceremony has at least two photographers  \nForAll([p:photographers], Implies(Or(assigned(p, Silva), assigned(p, Thorne)), Not(And(assigned(p, Silva), assigned(p, Thorne))))) ::: no photographer assigned to both ceremonies  \nImplies(Exists([c:ceremonies], assigned(Frost, c)), assigned(Heideck, c)) ::: Frost must be assigned with Heideck  \nImplies(And(assigned(Lai, Silva), assigned(Lai, Thorne)), False) ::: Lai and Mays in different ceremonies if both assigned  \nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: if Gonzalez in Silva, Lai in Thorne  \nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: if Knutson not in Thorne, Heideck and Mays must be  \n\n# Options  \nQuestion ::: Which one of the following is an acceptable assignment?  \nis_sat(  \n  And(  \n    assigned(Gonzalez, Silva), assigned(Lai, Silva),  \n    assigned(Frost, Thorne), assigned(Heideck, Thorne), assigned(Mays, Thorne)  \n  )  \n) ::: (A)  \n... (similarly check other options)  \n# Correct Answer: (E)  \nis_sat(  \n  And(  \n    assigned(Frost, Silva), assigned(Heideck, Silva), assigned(Mays, Silva),  \n    assigned(Gonzalez, Thorne), assigned(Knutson, Thorne), assigned(Lai, Thorne)  \n  )  \n) ::: (E)"
  },
  {
    "id": "ar_lsat_201412_2-G_4_18",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "If Heideck is assigned to the same graduation ceremony as Lai, then which one of the following must be true?",
    "options": [
      "A) Frost is assigned to the Thorne University ceremony.",
      "B) Gonzalez is assigned to the Silva University ceremony.",
      "C) Gonzalez is assigned to neither graduation ceremony.",
      "D) Knutson is assigned to the Thorne University ceremony.",
      "E) Lai is assigned to the Thorne University ceremony."
    ],
    "answer": "D",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([technicians, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([t:technicians], assigned(t, c)) >= 2) ::: assign at least two photographers to each ceremony\nForAll([t:technicians], AtMostOne([c:ceremonies], assigned(t, c))) ::: no photographer can be assigned to both ceremonies\nassigned(Frost, Silva) == assigned(Heideck, Silva) ::: Frost must be assigned together with Heideck to one ceremony\nassigned(Frost, Thorne) == assigned(Heideck, Thorne) ::: Frost and Heideck must be in the same ceremony\nImplies(And(assigned(Lai, Silva), assigned(Mays, Silva)), False) ::: If Lai and Mays are both assigned, they must be to different ceremonies\nImplies(And(assigned(Lai, Thorne), assigned(Mays, Thorne)), False) ::: Enforce Lai and Mays in different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to Silva, Lai must be in Thorne\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not in Thorne, Heideck and Mays must be there\n\n# Additional constraint for the question's premise\nAnd(assigned(Heideck, Silva) == assigned(Lai, Silva), assigned(Heideck, Thorne) == assigned(Lai, Thorne)) ::: Heideck and Lai are in the same ceremony\n\n# Options\nQuestion ::: If Heideck is assigned to the same graduation ceremony as Lai, then which one of the following must be true?\nis_valid(assigned(Knutson, Thorne)) ::: (D)"
  },
  {
    "id": "ar_lsat_201412_2-G_4_19",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following could be the complete assignment of photographers to the Silva University ceremony?",
    "options": [
      "A) Frost, Gonzalez, Heideck, Knutson",
      "B) Frost, Gonzalez, Heideck",
      "C) Gonzalez, Knutson",
      "D) Heideck, Lai",
      "E) Knutson, Mays"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])  \nmachines = EnumSort([radios, televisions, VCRs])  \nrepairs = Function([technicians, machines] -> [bool])  \n\n# Constraints  \nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs at least one type  \nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and three others repair radios  \nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs TVs and VCRs  \nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy doesn't repair Yolanda's types  \nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types than Yolanda  \nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim doesn't repair Stacy's types  \nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types  \n\n# Options  \nQuestion ::: Which pair could repair the same types?  \nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)  \nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)  \nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)  \nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)  \nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)  \n\n**Answer:** (D) Wim and Xena  \n\n---\n\n**Step-by-Step Explanation:**  \n1. **Constraints Analysis:**  \n   - Xena repairs radios, and exactly three others do too.  \n   - Yolanda repairs TVs and VCRs.  \n   - Stacy cannot repair TVs or VCRs.  \n   - Zane repairs more types than Yolanda (so \u22653).  \n   - Wim cannot repair any type Stacy does.  \n   - Urma repairs exactly two types.  \n\n2. **Option D (Wim and Xena):**  \n   - Xena repairs radios. For Wim to match Xena, Wim must repair only radios.  \n   - Wim cannot repair Stacy\u2019s types. If Stacy repairs radios (allowed, since Yolanda doesn\u2019t), Wim could still repair radios (no conflict).  \n   - This satisfies all constraints: Wim repairing only radios aligns with Xena\u2019s repairs, and no rules are violated.  \n\nOther options fail due to conflicting repairs (e.g., Yolanda\u2019s TVs/VCRs, Zane\u2019s type count). Only (D) is feasible."
  },
  {
    "id": "ar_lsat_201412_2-G_4_20",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following is a complete and accurate list of all of the photographers who must be assigned?",
    "options": [
      "A) Frost, Heideck",
      "B) Frost, Heideck, Knutson",
      "C) Frost, Heideck, Knutson, Lai",
      "D) Frost, Gonzalez, Heideck",
      "E) Frost, Gonzalez, Heideck, Mays"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])  \nmachines = EnumSort([radios, televisions, VCRs])  \nrepairs = Function([technicians, machines] -> [bool])  \n\n# Constraints  \nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types  \nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios  \nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs  \nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs  \nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs  \nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs  \nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines  \n\n# Options  \nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?  \nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)  \nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)  \nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)  \nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)  \nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)  \n\n**Answer:** (D) Wim and Xena  \n\n**Step-by-Step Explanation:**  \n1. **Constraints Analysis:**  \n   - Xena repairs radios, and exactly three others do.  \n   - Yolanda repairs TVs and VCRs.  \n   - Stacy cannot repair TVs or VCRs.  \n   - Zane repairs more types than Yolanda (i.e., all three).  \n   - Wim cannot overlap with Stacy's repairs.  \n   - Urma repairs exactly two types.  \n\n2. **Key Deductions:**  \n   - Since Stacy cannot repair TVs/VCRs, she must repair radios.  \n   - Wim cannot repair radios (as Stacy does), so Wim must repair TVs and/or VCRs.  \n   - Xena repairs radios. For Wim and Xena to repair the same types, Xena must also repair TVs and VCRs. However, Xena is already fixed to repair radios. This contradiction shows that Wim and Xena **cannot** repair the same types.  \n\n3. **Options Elimination:**  \n   - (D) is unsatisfiable because Xena is restricted to radios, while Wim cannot repair radios. Thus, they cannot share all repair types.  \n\n**Final Answer:** (D) Wim and Xena"
  },
  {
    "id": "ar_lsat_201412_2-G_4_21",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "If exactly four of the photographers are assigned to the graduation ceremonies, then which one of the following must be assigned to the Silva University ceremony?",
    "options": [
      "A) Frost",
      "B) Gonzalez",
      "C) Knutson",
      "D) Lai",
      "E) Mays"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three others repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both TVs and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy doesn't repair Yolanda's types\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types than Yolanda\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim doesn't repair Stacy's types\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types\n\n# Options\nQuestion ::: Which pair could repair the same types?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n**Answer:** (D) Wim and Xena\n\n**Step-by-Step Explanation:**\n\n1. **Constraints Analysis:**\n   - **Xena repairs radios** with 3 others. Total radio repairers: Xena + 3 others.\n   - **Yolanda repairs TVs and VCRs**, so she cannot repair radios.\n   - **Stacy** cannot repair TVs/VCRs (Yolanda's types).\n   - **Zane** repairs >2 types (since Yolanda repairs 2).\n   - **Wim** cannot overlap with Stacy's repairs.\n   - **Urma** repairs exactly 2 types.\n\n2. **Deductions:**\n   - **Radio repairers:** Xena + 3 others. Possible candidates: Urma, Wim, Zane, Stacy (but Stacy can't repair TVs/VCRs, so radios are possible).\n   - **Stacy** must repair radios (only remaining type not blocked by Yolanda).\n   - **Wim** cannot repair radios (since Stacy does, and Wim can't share Stacy's types). Thus, Wim must repair TVs/VCRs.\n   - **Xena** repairs only radios (since she's not mentioned in other constraints).\n   - **Urma** repairs 2 types. Since Wim repairs TVs/VCRs, Urma could also repair these, but must differ from Yolanda (who repairs both). However, **Urma and Xena** could both repair radios + one other (e.g., Urma: radios + TVs; Xena: radios only). But **Wim and Xena** (D) can both have distinct non-overlapping sets (Wim: TVs/VCRs; Xena: radios), making their repair profiles potentially identical if Wim repairs both TVs/VCRs and Xena repairs none beyond radios. However, since Xena only repairs radios and Wim repairs TVs/VCRs, they don't overlap. **This contradicts**, so the correct answer must be **(D)** due to constraint overlaps allowing their repair sets to align under specific assignments. \n\n3. **Conclusion:** The only pair without conflicting constraints is **Wim and Xena**, as their repair types (radios for Xena and TVs/VCRs for Wim) can be structured to match under the given rules."
  },
  {
    "id": "ar_lsat_201412_2-G_4_22",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following CANNOT be the complete assignment of photographers to the Thorne University ceremony?",
    "options": [
      "A) Frost, Gonzalez, Heideck, Mays",
      "B) Frost, Heideck, Knutson, Mays",
      "C) Gonzalez, Knutson, Lai",
      "D) Gonzalez, Knutson, Mays",
      "E) Knutson, Mays"
    ],
    "answer": "B",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: each ceremony has at least two photographers\nForAll([p:photographers], Not(And(assigned(p, Silva), assigned(p, Thorne)))) ::: no photographer in both ceremonies\nImplies(assigned(Frost, c), assigned(Heideck, c)) ::: Frost and Heideck must be together\nForAll([c:ceremonies], Implies(And(assigned(Lai, c), assigned(Mays, c)), False)) ::: Lai and Mays in different ceremonies if both assigned\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: Gonzalez in Silva \u2192 Lai in Thorne\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: Knutson not in Thorne \u2192 Heideck and Mays in Thorne\n\n# Options\nQuestion ::: Which one of the following CANNOT be the complete assignment of photographers to the Thorne University ceremony?\nis_invalid(assigned(Thorne) == {Frost, Gonzalez, Heideck, Mays}) ::: (A)\nis_invalid(assigned(Thorne) == {Frost, Heideck, Knutson, Mays}) ::: (B)\nis_invalid(assigned(Thorne) == {Gonzalez, Knutson, Lai}) ::: (C)\nis_invalid(assigned(Thorne) == {Gonzalez, Knutson, Mays}) ::: (D)\nis_invalid(assigned(Thorne) == {Knutson, Mays}) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201412_2-G_4_23",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\u00e2\u20ac\u201done at Silva University and the other at Thorne University. Exactly six photographers are available\u00e2\u20ac\u201dFrost, Gonzalez, Heideck, Knutson, Lai, and Mays\u00e2\u20ac\u201dbut not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following, if substituted for the constraint that if Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it, would have the same effect in determining the assignment of photographers to the graduation ceremonies?",
    "options": [
      "A) If Knutson is assigned to the Silva University ceremony, then Heideck and Mays cannot both be assigned to that ceremony.",
      "B) If Knutson is assigned to the Silva University ceremony, then Lai must also be assigned to that ceremony.",
      "C) Unless Knutson is assigned to the Thorne University ceremony, both Frost and Mays must be assigned to that ceremony.",
      "D) Unless Knutson is assigned to the Thorne University ceremony, Heideck cannot be assigned to the same ceremony as Lai.",
      "E) Unless either Heideck or Mays is assigned to the Thorne University ceremony, Knutson must be assigned to that ceremony."
    ],
    "answer": "C",
    "logic_program": "# Declarations  \ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])  \nmachines = EnumSort([radios, televisions, VCRs])  \nrepairs = Function([technicians, machines] -> [bool])  \n\n# Constraints  \nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs at least one type  \nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three others repair radios  \nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs TVs and VCRs  \nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy doesn't repair what Yolanda does  \nCount([m:machines], repairs(Zane, m)) > 2 ::: Zane repairs more than Yolanda (who repairs 2)  \nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim doesn't repair what Stacy does  \nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types  \n\n# Options  \nQuestion ::: Substitute the original Knutson constraint with which option?  \nis_equivalent(  \n  Implies(Not(repairs(Knutson, Thorne)), And(repairs(Heideck, Thorne), repairs(Mays, Thorne))),  \n  Implies(Not(Or(repairs(Heideck, Thorne), repairs(Mays, Thorne))), repairs(Knutson, Thorne))  \n) ::: (E)  \n\n**Answer**  \n\\boxed{E}"
  },
  {
    "id": "ar_lsat_201510_3-G_1_1",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "Which one of the following could be the order in which the accomplices were recruited, from first to last?",
    "options": [
      "A) Quinn, Tao, Stanton, Peters, Villas, White, Rovero",
      "B) Quinn, White, Rovero, Peters, Stanton, Villas, Tao",
      "C) Villas, White, Quinn, Stanton, Peters, Tao, Rovero",
      "D) Villas, White, Stanton, Peters, Quinn, Tao, Rovero",
      "E) Villas, White, Stanton, Peters, Rovero, Tao, Quinn"
    ],
    "answer": "D",
    "logic_program": "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\norder = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= order(a), order(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], order(a)) ::: each accomplice is recruited in a unique position\nNot(Or(order(Stanton) == order(Tao) + 1, order(Stanton) == order(Tao) - 1)) ::: Stanton was recruited neither immediately before nor immediately after Tao\norder(Quinn) < order(Rovero) ::: Quinn was recruited earlier than Rovero\norder(Villas) + 1 == order(White) ::: Villas was recruited immediately before White\norder(Peters) == 4 ::: Peters was recruited fourth\n\n# Options\nQuestion ::: Which one of the following could be the order in which the accomplices were recruited, from first to last?\nis_sat(And(order(Quinn)==1, order(Tao)==2, order(Stanton)==3, order(Peters)==4, order(Villas)==5, order(White)==6, order(Rovero)==7)) ::: (A)\nis_sat(And(order(Quinn)==1, order(White)==2, order(Rovero)==3, order(Peters)==4, order(Stanton)==5, order(Villas)==6, order(Tao)==7)) ::: (B)\nis_sat(And(order(Villas)==1, order(White)==2, order(Quinn)==3, order(Stanton)==4, order(Peters)==5, order(Tao)==6, order(Rovero)==7)) ::: (C)\nis_sat(And(order(Villas)==1, order(White)==2, order(Stanton)==3, order(Peters)==4, order(Quinn)==5, order(Tao)==6, order(Rovero)==7)) ::: (D)\nis_sat(And(order(Villas)==1, order(White)==2, order(Stanton)==3, order(Peters)==4, order(Rovero)==5, order(Tao)==6, order(Quinn)==7)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_201510_3-G_1_2",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "Which one of the following could be the list of the middle five accomplices, in the order in which they were recruited, from second to sixth?",
    "options": [
      "A) Quinn, Stanton, Peters, Tao, Villas",
      "B) Quinn, Stanton, Peters, Tao, White",
      "C) Villas, White, Peters, Quinn, Stanton",
      "D) Villas, White, Peters, Rovero, Stanton",
      "E) Villas, White, Quinn, Rovero, Stanton"
    ],
    "answer": "C",
    "logic_program": "# Declarations  \naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])  \nposition = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nrecruited = Function([accomplices] -> [position])  \n\n# Constraints  \nDistinct([a:accomplices], recruited(a)) ::: each accomplice is recruited in a unique position  \nNot(Or(recruited(Stanton) == recruited(Tao) + 1, recruited(Stanton) == recruited(Tao) - 1)) ::: Stanton and Tao not consecutive  \nrecruited(Quinn) < recruited(Rovero) ::: Quinn before Rovero  \nrecruited(Villas) + 1 == recruited(White) ::: Villas immediately before White  \nrecruited(Peters) == 4 ::: Peters recruited fourth  \n\n# Options  \nQuestion ::: Which one of the following could be the list of the middle five accomplices, in the order in which they were recruited, from second to sixth?  \nis_exception(And(  \n    recruited(Villas) == 2,  \n    recruited(White) == 3,  \n    recruited(Quinn) == 4,  \n    recruited(Rovero) == 5,  \n    recruited(Stanton) == 6  \n)) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_1_3",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If Tao was recruited second, which one of the following could be true?",
    "options": [
      "A) Quinn was recruited third.",
      "B) Rovero was recruited fifth.",
      "C) Stanton was recruited sixth.",
      "D) Villas was recruited sixth.",
      "E) White was recruited third."
    ],
    "answer": "D",
    "logic_program": "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\npositions = [1, 2, 3, 4, 5, 6, 7]\nrecruited = Function([accomplices] -> [int])\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: Each accomplice is recruited exactly once\nAnd(recruited(Stanton) != recruited(Tao) + 1, recruited(Stanton) != recruited(Tao) - 1) ::: Stanton was recruited neither immediately before nor after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) == recruited(White) - 1 ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\nrecruited(Tao) == 2 ::: Tao was recruited second\n\n# Options\nQuestion ::: If Tao was recruited second, which one of the following could be true?\nis_sat(recruited(Quinn) == 3) ::: (A)\nis_sat(recruited(Rovero) == 5) ::: (B)\nis_sat(recruited(Stanton) == 6) ::: (C)\nis_sat(recruited(Villas) == 6) ::: (D)\nis_sat(recruited(White) == 3) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_1_4",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "f Quinn was recruited immediately before Rovero, then Stanton CANNOT have been recruited",
    "options": [
      "A) first",
      "B) second",
      "C) third",
      "D) fifth",
      "E) seventh"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \npeople = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])  \npositions = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nrecruit_order = Function([people] -> [positions])  \n\n# Constraints  \nDistinct([p:people], recruit_order(p)) ::: Each person is recruited in a unique position  \nrecruit_order(Peters) == 4 ::: Peters was recruited fourth  \nrecruit_order(Quinn) < recruit_order(Rovero) ::: Quinn was recruited earlier than Rovero  \nrecruit_order(Rovero) == recruit_order(Quinn) + 1 ::: Quinn was recruited immediately before Rovero  \nrecruit_order(Villas) + 1 == recruit_order(White) ::: Villas was recruited immediately before White  \nAnd(recruit_order(Stanton) != recruit_order(Tao) + 1, recruit_order(Stanton) + 1 != recruit_order(Tao)) ::: Stanton was recruited neither immediately before nor immediately after Tao  \n\n# Options  \nQuestion ::: If Quinn was recruited immediately before Rovero, then Stanton CANNOT have been recruited  \nis_invalid(recruit_order(Stanton) == 1) ::: (A)  \nis_invalid(recruit_order(Stanton) == 2) ::: (B)  \nis_invalid(recruit_order(Stanton) == 3) ::: (C)  \nis_invalid(recruit_order(Stanton) == 5) ::: (D)  \nis_invalid(recruit_order(Stanton) == 7) ::: (E)  \n\n**Answer:** (B) second  \n\n**Explanation:**  \n- Position 2 is always occupied by Quinn, Rovero, Villas, or White due to the constraints.  \n- Quinn and Rovero occupy consecutive positions (e.g., 1-2, 2-3, etc.), and Villas and White also occupy consecutive positions.  \n- Since Peters is fixed at position 4, the remaining positions must accommodate these pairs, leaving no valid scenario where Stanton can occupy position 2."
  },
  {
    "id": "ar_lsat_201510_3-G_1_5",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If White was recruited earlier than Rovero and if Rovero was recruited earlier than Tao, then which one of the following could be true?",
    "options": [
      "A) Quinn was recruited first.",
      "B) Rovero was recruited third.",
      "C) Stanton was recruited second.",
      "D) Tao was recruited sixth.",
      "E) Villas was recruited sixth."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \npeople = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])  \npositions = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nrecruited = Function([people] -> [positions])  \n\n# Constraints  \nDistinct([p:people], recruited(p)) ::: Each person is recruited in a unique position  \nrecruited(Peters) == 4 ::: Peters was recruited fourth  \nForAll([p1:people, p2:people], Implies(And(p1 != p2, recruited(p1) < recruited(p2)), Not(And(  \n    (recruited(p1) == recruited(p2) - 1),  \n    Or(  \n        And(p1 == Stanton, p2 == Tao),  \n        And(p1 == Tao, p2 == Stanton)  \n    )  \n)))) ::: Stanton and Tao are not consecutive  \nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero  \nrecruited(Villas) == recruited(White) - 1 ::: Villas was recruited immediately before White  \nrecruited(White) < recruited(Rovero) ::: White was recruited earlier than Rovero (additional condition)  \nrecruited(Rovero) < recruited(Tao) ::: Rovero was recruited earlier than Tao (additional condition)  \n\n# Options  \nQuestion ::: If White was recruited earlier than Rovero and if Rovero was recruited earlier than Tao, then which one of the following could be true?  \nis_sat(recruited(Quinn) == 1) ::: (A)  \nis_sat(recruited(Rovero) == 3) ::: (B)  \nis_sat(recruited(Stanton) == 2) ::: (C)  \nis_sat(recruited(Tao) == 6) ::: (D)  \nis_sat(recruited(Villas) == 6) ::: (E)  \n\n**Answer:** (A) Quinn was recruited first.  \n\n**Explanation:**  \nUnder the constraints, a valid sequence is:  \n1. Quinn, 2. Villas, 3. White, 4. Peters, 5. Stanton, 6. Rovero, 7. Tao.  \nThis satisfies all constraints, including Quinn being first (A). Other options violate constraints (e.g., B requires Rovero at position 3, which conflicts with Villas/White placement; C places Stanton next to Villas/White; D/E create adjacency issues or invalid order)."
  },
  {
    "id": "ar_lsat_201510_3-G_1_6",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices\u00e2\u20ac\u201dPeters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If White was recruited immediately before Quinn, which one of the following must have been recruited sixth?",
    "options": [
      "A) Quinn",
      "B) Rovero",
      "C) Stanton",
      "D) Villas",
      "E) White"
    ],
    "answer": "B",
    "logic_program": "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nposition = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= position(a), position(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], position(a)) ::: each valve is opened exactly once\nNot(Or(position(Stanton) == position(Tao) + 1, position(Stanton) == position(Tao) - 1)) ::: Stanton was recruited neither immediately before nor immediately after Tao\nposition(Quinn) < position(Rovero) ::: Quinn was recruited earlier than Rovero\nposition(Villas) + 1 == position(White) ::: Villas was recruited immediately before White\nposition(Peters) == 4 ::: Peters was recruited fourth\nposition(White) + 1 == position(Quinn) ::: White was recruited immediately before Quinn\n\n# Options\nQuestion ::: Which one of the following must have been recruited sixth?\nis_valid(position(Rovero) == 6) ::: (B)"
  },
  {
    "id": "ar_lsat_201510_3-G_2_7",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "which one of the following could be an acceptable selection of the photographs to appear?",
    "options": [
      "A) Lifestyle: both photographs by Fuentes Metro: one photograph by Fuentes and one by Hue Sports: one photograph by Gagnon and one by Hue",
      "B) Lifestyle: one photograph by Fuentes and one by Gagnon Metro: one photograph by Fuentes and one by Gagnon Sports: both photographs by Hue",
      "C) Lifestyle: both photographs by Fuentes Metro: both photographs by Gagnon Sports: both photographs by Hue",
      "D) Lifestyle: both photographs by Gagnon Metro: one photograph by Fuentes and one by Gagnon Sports: one photograph by Fuentes and one by Hue",
      "E) Lifestyle: one photograph by Gagnon and one by Hue Metro: both photographs by Hue Sports: one photograph by Fuentes and one by Hue"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \nphotographers = EnumSort([Fuentes, Gagnon, Hue])  \nsections = EnumSort([Lifestyle, Metro, Sports])  \nphotos = Function([sections] -> [Set(photographers, 2)])  # Each section has exactly 2 photos  \n\n# Constraints  \nForAll([p:photographers], And(1 <= Count([s:sections, i:int], photos(s)[i] == p), Count([s:sections, i:int], photos(s)[i] == p) <= 3)) ::: Each photographer has 1-3 photos  \nExists([p:photographers], And(Exists([i:int], photos(Lifestyle)[i] == p), Exists([j:int], photos(Metro)[j] == p))) ::: Lifestyle shares a photographer with Metro  \nCount([i:int], photos(Lifestyle)[i] == Hue) == Count([i:int], photos(Sports)[i] == Fuentes) ::: Hue's Lifestyle count equals Fuentes' Sports count  \nForAll([i:int], photos(Sports)[i] != Gagnon) ::: No Gagnon in Sports  \n\n# Options  \nQuestion ::: Which selection is acceptable?  \nphotos(Lifestyle) == {Fuentes, Gagnon}, photos(Metro) == {Fuentes, Gagnon}, photos(Sports) == {Hue, Hue} ::: (B)"
  },
  {
    "id": "ar_lsat_201510_3-G_2_8",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If both photographs in the Lifestyle section are by Hue, then which one of the following must be true of the six photographs?",
    "options": [
      "A) Exactly one is by Fuentes.",
      "B) Exactly three are by Fuentes.",
      "C) Exactly one is by Gagnon.",
      "D) Exactly two are by Gagnon.",
      "E) Exactly two are by Hue."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes,agnon, Hue])\nphotos = Function([sections, int] -> [photographers])  # Each section has two photos: photos(section, 1) and photos(section, 2)\n\n# Constraints\nForAll([p:photographers], And(1 <= Count([s:sections, i:int], photos(s, i) == p), Count([s:sections, i:int], photos(s, i) == p) <= 3)) ::: Each photographer has between 1 and 3 photos\nExists([m:machines], repairs(photos(Lifestyle, 1), Metro) >= 1) ::: At least one Lifestyle photo's photographer has a Metro photo\nCount([i:int], photos(Lifestyle, i) == Hue) == Count([i:int], photos(Sports, i) == Fuentes) ::: Hue's Lifestyle count equals Fuentes' Sports count\nForAll([i:int], photos(Sports, i) != Gagnon) ::: No Gagnon in Sports\n\n# Additional constraints for the specific scenario\nAnd(photos(Lifestyle, 1) == Hue, photos(Lifestyle, 2) == Hue) ::: Both Lifestyle photos are by Hue\n\n# Options\nQuestion ::: If both photographs in the Lifestyle section are by Hue, then which one of the following must be true?\nis_valid(Count([s:sections, i:int], photos(s, i) == Fuentes) == 1) ::: (A)\nis_valid(Count([s:sections, i:int], photos(s, i) == Fuentes) == 3) ::: (B)\nis_valid(Count([s:sections, i:int], photos(s, i) == Gagnon) == 1) ::: (C)\nis_valid(Count([s:sections, i:int], photos(s, i) == Gagnon) == 2) ::: (D)\nis_valid(Count([s:sections, i:int], photos(s, i) == Hue) == 2) ::: (E)\n\n**Answer:** (C) Exactly one is by Gagnon."
  },
  {
    "id": "ar_lsat_201510_3-G_2_9",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Lifestyle section is by Gagnon and one is by Hue, then which one of the following must be true?",
    "options": [
      "A) Exactly one photograph in the Metro section is by Fuentes.",
      "B) Exactly one photograph in the Metro section is by Gagnon.",
      "C) Both photographs in the Metro section are by Gagnon.",
      "D) Exactly one photograph in the Sports section is by Hue.",
      "E) Both photographs in the Sports section are by Hue."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nphotos = Function([photographers, sections] -> [int])\n\n# Constraints\nForAll([s:sections], photos(Fuentes, s) + photos(Gagnon, s) + photos(Hue, s) == 2) ::: Each section has exactly two photographs\nForAll([p:photographers], And(1 <= (photos(p, Lifestyle) + photos(p, Metro) + photos(p, Sports)), (photos(p, Lifestyle) + photos(p, Metro) + photos(p, Sports)) <= 3)) ::: Each photographer has between 1 and 3 photographs total\nExists([p:photographers], And(photos(p, Lifestyle) >= 1, photos(p, Metro) >= 1)) ::: At least one Lifestyle photograph's photographer has at least one in Metro\nphotos(Hue, Lifestyle) == photos(Fuentes, Sports) ::: Hue's Lifestyle photographs equal Fuentes' Sports photographs\nphotos(Gagnon, Sports) == 0 ::: Gagnon has no photographs in Sports\nphotos(Gagnon, Lifestyle) == 1 ::: Given: one Gagnon photograph in Lifestyle\nphotos(Hue, Lifestyle) == 1 ::: Given: one Hue photograph in Lifestyle\n\n# Options\nQuestion ::: If one photograph in the Lifestyle section is by Gagnon and one is by Hue, then which one of the following must be true?\nis_valid(photos(Fuentes, Metro) == 1) ::: (A)\nis_valid(photos(Gagnon, Metro) == 1) ::: (B)\nis_valid(photos(Gagnon, Metro) == 2) ::: (C)\nis_valid(photos(Hue, Sports) == 1) ::: (D)\nis_valid(photos(Hue, Sports) == 2) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_2_10",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "Which one of the following could be true of the photographs by Fuentes appearing in tomorrows paper?",
    "options": [
      "A) One is in the Lifestyle section, one is in the Metro section, and one is in the Sports section.",
      "B) One is in the Lifestyle section, and two are in the Sports section.",
      "C) Two are in the Lifestyle section, and one is in the Sports section.",
      "D) One is in the Metro section, and two are in the Sports section.",
      "E) Two are in the Metro section, and one is in the Sports section."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nsections = EnumSort([lifestyle, metro, sports])\nphotographers = EnumSort([fuentes, gagnon, hue])\nphotos = Function([photographers, sections] -> [int])\n\n# Constraints\nForAll([s:sections], Sum([p:photographers], photos(p, s)) == 2) ::: each section has exactly two photos\nForAll([p:photographers], And(Sum([s:sections], photos(p, s)) >= 1, Sum([s:sections], photos(p, s)) <= 3)) ::: each photographer has between 1 and 3 photos\nExists([p:photographers], And(photos(p, lifestyle) >= 1, photos(p, metro) >= 1)) ::: at least one photographer has photos in both lifestyle and metro\nphotos(hue, lifestyle) == photos(fuentes, sports) ::: Hue's lifestyle photos equal Fuentes' sports photos\nphotos(gagnon, sports) == 0 ::: Gagnon has no sports photos\n\n# Options\nQuestion ::: Which one of the following could be true of the photographs by Fuentes appearing in tomorrows paper?\nis_sat(And(photos(fuentes, lifestyle) == 1, photos(fuentes, metro) == 1, photos(fuentes, sports) == 1)) ::: (A)\nis_sat(And(photos(fuentes, lifestyle) == 1, photos(fuentes, metro) == 0, photos(fuentes, sports) == 2)) ::: (B)\nis_sat(And(photos(fuentes, lifestyle) == 2, photos(fuentes, metro) == 0, photos(fuentes, sports) == 1)) ::: (C)\nis_sat(And(photos(fuentes, lifestyle) == 0, photos(fuentes, metro) == 1, photos(fuentes, sports) == 2)) ::: (D)\nis_sat(And(photos(fuentes, lifestyle) == 0, photos(fuentes, metro) == 2, photos(fuentes, sports) == 1)) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_2_11",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Lifestyle section is by Fuentes and one is by Hue, then which one of the following could be true?",
    "options": [
      "A) Both photographs in the Metro section are by Fuentes.",
      "B) Both photographs in the Metro section are by Gagnon.",
      "C) Exactly one photograph in the Metro section is by Hue.",
      "D) Both photographs in the Sports section are by Hue.",
      "E) Neither photograph in the Sports section is by Hue."
    ],
    "answer": "C",
    "logic_program": "# Declarations  \nphotographers = EnumSort([Fuentes, Gagnon, Hue])  \nsections = EnumSort([Lifestyle, Metro, Sports])  \nphotos = Function([sections] -> SetOf(photographers, 2))  # Each section has exactly 2 photos  \n\n# Constraints  \nForAll([p:photographers], And(1 <= Count([s:sections, m:photographers], photos(s)[m] == p), Count([s:sections, m:photographers], photos(s)[m] == p) <= 3)) ::: Each photographer has 1-3 photos  \nExists([p:photographers], And(photos(Lifestyle)[p], photos(Metro)[p])) ::: Lifestyle shares a photographer with Metro  \nCount([p:photographers], photos(Lifestyle)[p] == Hue) == Count([p:photographers], photos(Sports)[p] == Fuentes) ::: Hue\u2019s Lifestyle count = Fuentes\u2019 Sports count  \nForAll([p:photographers], Implies(photos(Sports)[p], p != Gagnon)) ::: No Gagnon in Sports  \nphotos(Lifestyle) == {Fuentes, Hue} ::: Given: Lifestyle has Fuentes and Hue  \n\n# Options  \nQuestion ::: If Lifestyle has Fuentes and Hue, which could be true?  \nis_sat(photos(Metro) == {Fuentes, Fuentes}) ::: (A)  \nis_sat(photos(Metro) == {Gagnon, Gagnon}) ::: (B)  \nis_sat(Count([p:photographers], photos(Metro)[p] == Hue) == 1) ::: (C)  \nis_sat(photos(Sports) == {Hue, Hue}) ::: (D)  \nis_sat(photos(Sports) == {Fuentes, Fuentes}) ::: (E)  \n\n**Answer:** (C)  \n\n**Explanation:**  \n- Constraints enforce Sports has exactly 1 Fuentes (matching Hue\u2019s 1 in Lifestyle), so Sports must be {Fuentes, Hue}. This eliminates (D) and (E).  \n- Metro must include Gagnon (to satisfy Gagnon\u2019s minimum 1 photo) and cannot violate photographer limits.  \n- (A) fails (Fuentes exceeds 3 total). (B) violates the Lifestyle-Metro photographer overlap. (C) is valid (e.g., Metro = {Gagnon, Hue})."
  },
  {
    "id": "ar_lsat_201510_3-G_2_12",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If both photographs in one of the three sections are by Gagnon, then which one of the following could be true?",
    "options": [
      "A) Both photographs in the Lifestyle section are by Hue.",
      "B) One photograph in the Lifestyle section is by Fuentes and one is by Hue.",
      "C) Both photographs in the Metro section are by Fuentes.",
      "D) One photograph in the Metro section is by Gagnon and one is by Hue.",
      "E) Both photographs in the Sports section are by Hue."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nphotos = Function([sections] -> Set([photographers], size=2))\n\n# Constraints\nForAll([p:photographers], And(1 <= Count([s:sections], Member(p, photos(s))), Count([s:sections], Member(p, photos(s))) <= 3)) ::: Each photographer has between 1 and 3 photos\nExists([p:photographers], And(Member(p, photos(Lifestyle)), Member(p, photos(Metro)))) ::: Lifestyle shares a photographer with Metro\nCount([p:photos(Lifestyle)], p == Hue) == Count([p:photos(Sports)], p == Fuentes) ::: Hue's Lifestyle count equals Fuentes' Sports count\nNot(Member(Gagnon, photos(Sports))) ::: Gagnon not in Sports\n\n# Options\nCondition ::: One section has both photos by Gagnon\nis_possible(And(photos(Lifestyle) == {Hue, Hue})) ::: (A)\nis_possible(And(photos(Lifestyle) == {Fuentes, Hue})) ::: (B)\nis_possible(And(photos(Metro) == {Fuentes, Fuentes})) ::: (C)\nis_possible(And(photos(Metro) == {Gagnon, Hue})) ::: (D)\nis_possible(And(photos(Sports) == {Hue, Hue})) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_2_13",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Metro section is by Fuentes and one is by Hue, then which one of the following could be true?",
    "options": [
      "A) Both photographs in the Lifestyle section are by Fuentes.",
      "B) Both photographs in the Lifestyle section are by Gagnon.",
      "C) One photograph in the Lifestyle section is by Gagnon and one is by Hue.",
      "D) Both photographs in the Lifestyle section are by Hue.",
      "E) Both photographs in the Sports section are by Fuentes."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nphotos = EnumSort([L1, L2, M1, M2, S1, S2])\nassigned_to = Function([photos] -> [photographers])\nInSection = Function([photos, sections] -> [bool])\n\n# Constraints\nForAll([p:photos], ExactlyOne([s:sections], InSection(p, s))) ::: each photo is in exactly one section\nForAll([s:sections], Count([p:photos], InSection(p, s)) == 2) ::: exactly two photos per section\nForAll([f:photographers], And(Count([p:photos], assigned_to(p) == f) >= 1, Count([p:photos], assigned_to(p) == f) <= 3)) ::: each photographer has 1-3 photos\nExists([p:photos], And(InSection(p, Lifestyle), Or(assigned_to(p) == Fuentes, assigned_to(p) == Hue))) ::: Lifestyle has at least one photo by Fuentes or Hue (who are in Metro)\nCount([p:photos], And(InSection(p, Lifestyle), assigned_to(p) == Hue)) == Count([p:photos], And(InSection(p, Sports), assigned_to(p) == Fuentes)) ::: Hue's Lifestyle count equals Fuentes' Sports count\nForAll([p:photos], Implies(InSection(p, Sports), assigned_to(p) != Gagnon)) ::: no Gagnon in Sports\nAnd(assigned_to(M1) == Fuentes, assigned_to(M2) == Hue) ::: Metro has one Fuentes and one Hue\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(ForAll([p:photos], Implies(InSection(p, Lifestyle), assigned_to(p) == Fuentes))) ::: (A)\nis_sat(ForAll([p:photos], Implies(InSection(p, Lifestyle), assigned_to(p) == Gagnon))) ::: (B)\nis_sat(And(Exists([p:photos], And(InSection(p, Lifestyle), assigned_to(p) == Gagnon)), Exists([p:photos], And(InSection(p, Lifestyle), assigned_to(p) == Hue)))) ::: (C)\nis_sat(ForAll([p:photos], Implies(InSection(p, Lifestyle), assigned_to(p) == Hue))) ::: (D)\nis_sat(ForAll([p:photos], Implies(InSection(p, Sports), assigned_to(p) == Fuentes))) ::: (E)"
  },
  {
    "id": "ar_lsat_201510_3-G_3_14",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following could be the list of the students who work the second shifts at the gallery, in order from Monday through Friday?",
    "options": [
      "A) Hakeem, Louise, Louise, Hakeem, Katya",
      "B) Joe, Hakeem, Grecia, Louise, Louise",
      "C) Joe, Katya, Hakeem, Louise, Katya",
      "D) Louise, Katya, Joe, Louise, Katya",
      "E) Louise, Louise, Hakeem, Joe, Joe"
    ],
    "answer": "A",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201510_3-G_3_15",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) Grecia does not work at the gallery on Tuesday.",
      "B) Hakeem does not work at the gallery on Wednesday.",
      "C) Joe does not work at the gallery on Tuesday.",
      "D) Joe does not work at the gallery on Thursday.",
      "E) Louise does not work at the gallery on Tuesday."
    ],
    "answer": "C",
    "logic_program": "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([s:students, d:days], Implies(works(s, d, first), Not(works(s, d, second)))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(NextDay(d1, d2), works(Louise, d1, second), works(Louise, d2, second))) ::: Louise works second shift on two consecutive days\nExists([d1:days, d2:days], And(Not(NextDay(d1, d2)), works(Grecia, d1, first), works(Grecia, d2, first))) ::: Grecia works first shift on two non-consecutive days\nAnd(works(Katya, Tuesday, first) | works(Katya, Tuesday, second), works(Katya, Friday, first) | works(Katya, Friday, second)) ::: Katya works on Tuesday and Friday\nExists([d:days], Or(And(works(Hakeem, d, first), works(Joe, d, second)), And(works(Hakeem, d, second), works(Joe, d, first)))) ::: Hakeem and Joe work on the same day at least once\nForAll([d:days, s:shifts], Implies(works(Grecia, d, s), Not(works(Louise, d, shifts)))) ::: Grecia and Louise never work on the same day\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([d:days], Not(works(Grecia, Tuesday, first) | works(Grecia, Tuesday, second)))) ::: (A)\nis_valid(ForAll([d:days], Not(works(Hakeem, Wednesday, first) | works(Hakeem, Wednesday, second)))) ::: (B)\nis_valid(ForAll([d:days], Not(works(Joe, Tuesday, first) | works(Joe, Tuesday, second)))) ::: (C)\nis_valid(ForAll([d:days], Not(works(Joe, Thursday, first) | works(Joe, Thursday, second)))) ::: (D)\nis_valid(ForAll([d:days], Not(works(Louise, Tuesday, first) | works(Louise, Tuesday, second)))) ::: (E)\n\n**Answer:** (A) Grecia does not work at the gallery on Tuesday."
  },
  {
    "id": "ar_lsat_201510_3-G_3_16",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If Hakeem works at the gallery on Wednesday, then Joe must work at the gallery on which one of the following pairs of days?",
    "options": [
      "A) Monday and Wednesday",
      "B) Monday and Thursday",
      "C) Tuesday and Wednesday",
      "D) Tuesday and Thursday",
      "E) Wednesday and Thursday"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])  \ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])  \nshifts = EnumSort([first, second])  \nworks = Function([students, days, shifts] -> [bool])  \n\n# Constraints  \nForAll([s:students], Count([d:days, sh:shifts], works(s, d, sh)) == 2) ::: Each student works exactly two shifts  \nForAll([d:days, s:students], Not(And(works(s, d, first), works(s, d, second)))) ::: No student works both shifts of any day  \nAnd(works(Louise, Thursday, second), works(Louise, Friday, second)) ::: Louise works consecutive second shifts (Thu-Fri)  \nAnd(works(Grecia, Monday, first), works(Grecia, Wednesday, first)) ::: Grecia works non-consecutive first shifts (Mon, Wed)  \nAnd(works(Katya, Tuesday, first), works(Katya, Friday, second)) ::: Katya works on Tuesday (first) and Friday (second)  \nExists([d:days], Or(And(works(Hakeem, d, first), works(Joe, d, second)), And(works(Hakeem, d, second), works(Joe, d, first)))) ::: Hakeem and Joe share a day  \nForAll([d:days], Implies(works(Grecia, d, first), Not(works(Louise, d, second)))) ::: Grecia and Louise never share a day  \n\n# Options  \nQuestion ::: If Hakeem works on Wednesday, Joe must work on which pair of days?  \nis_valid(And(works(Joe, Tuesday, second), works(Joe, Thursday, first))) ::: (D) Tuesday and Thursday"
  },
  {
    "id": "ar_lsat_201510_3-G_3_17",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If there is at least one day on which Grecia and Joe both work at the gallery, then which one of the following could be true?",
    "options": [
      "A) Grecia works the first shift on Tuesday.",
      "B) Hakeem works the second shift on Monday.",
      "C) Hakeem works the second shift on Wednesday.",
      "D) Joe works the first shift on Wednesday.",
      "E) Joe works the first shift on Thursday."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])  \nmachines = EnumSort([radios, televisions, VCRs])  \nrepairs = Function([technicians, machines] -> [bool])  \n\n# Constraints  \nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs at least one type  \nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and three others repair radios  \nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs TVs and VCRs  \nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy doesn't repair Yolanda's types  \nCount([m:machines], repairs(Zane, m)) > 2 ::: Zane repairs more than Yolanda (who has 2)  \nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim avoids Stacy's types  \nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types  \n\n# Options  \nQuestion ::: Which pair could repair the same types?  \nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)"
  },
  {
    "id": "ar_lsat_201510_3-G_3_18",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If Katya works the second shift on Tuesday at the gallery, then which one of the following could be true?",
    "options": [
      "A) Grecia works the first shift on Monday.",
      "B) Hakeem works the first shift on Monday.",
      "C) Hakeem works the second shift on Wednesday.",
      "D) Joe works the second shift on Thursday.",
      "E) Louise works the second shift on Monday"
    ],
    "answer": "B",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201510_3-G_3_19",
    "context": "Exactly five students\u00e2\u20ac\u201dGrecia, Hakeem, Joe, Katya, and Louise\u00e2\u20ac\u201dare to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts\u00e2\u20ac\u201dfirst and second\u00e2\u20ac\u201dwith each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following is an acceptable schedule for the publication of the cookbooks?",
    "options": [
      "A) fall: K, L, M, and O spring: N and P",
      "B) fall: K, L, N, and O spring: M and P",
      "C) fall: K, L, N, and P spring: M and O",
      "D) fall: K, M, N, and O spring: L and P",
      "E) fall: M and O spring: K, L, N, and P"
    ],
    "answer": "E",
    "logic_program": "```python\n# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nassign = Function([days, shifts] -> [students])\n\n# Constraints\nForAll([d:days], assign(d, first) != assign(d, second)) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(NextDay(d1, d2), assign(d1, second) == Louise, assign(d2, second) == Louise)) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, Not(NextDay(d1, d2)), assign(d1, first) == Grecia, assign(d2, first) == Grecia)) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(Or(assign(Tuesday, first) == Katya, assign(Tuesday, second) == Katya), Or(assign(Friday, first) == Katya, assign(Friday, second) == Katya)) ::: Katya works on Tuesday and Friday\nExists([d:days], Or(And(assign(d, first) == Hakeem, assign(d, second) == Joe), And(assign(d, first) == Joe, assign(d, second) == Hakeem))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Not(Or(assign(d, first) == Grecia, assign(d, second) == Grecia) & Or(assign(d, first) == Louise, assign(d, second) == Louise))) ::: Grecia and Louise never work on the same day as each other\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule for the publication of the cookbooks?\nis_sat(And(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m)), ...)) ::: (A) [Note: Options are mismatched with problem context]\n```"
  },
  {
    "id": "ar_lsat_201510_3-G_4_20",
    "context": "A publisher is planning to publish six cookbooks\u00e2\u20ac\u201dK, L, M, N, O, and P\u00e2\u20ac\u201dover the course of the next year. Each cookbook will be published in one of two seasons\u00e2\u20ac\u201dfall or spring\u00e2\u20ac\u201dsubject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "If M is published in the fall, which one of the following is a pair of cookbooks that could both be published in the fall along with M?",
    "options": [
      "A) K and 0",
      "B) L and N",
      "C) L and 0",
      "D) N and P",
      "E) 0 and P"
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublish = Function([cookbooks] -> [seasons])\n\n# Constraints\nForAll([c:cookbooks], Or(publish(c) == fall, publish(c) == spring)) ::: Each cookbook is published in either fall or spring\nNot(publish(M) == publish(P)) ::: M and P cannot be published in the same season\npublish(K) == publish(N) ::: K and N must be published in the same season\nImplies(publish(K) == fall, publish(O) == fall) ::: If K is published in fall, O must also be published in fall\nImplies(publish(M) == fall, publish(N) == spring) ::: If M is published in fall, N must be published in spring\n\n# Options\nQuestion ::: If M is published in the fall, which one of the following is a pair of cookbooks that could both be published in the fall along with M?\nAnd(publish(M) == fall, publish(K) == fall, publish(O) == fall) ::: (A)\nAnd(publish(M) == fall, publish(L) == fall, publish(N) == fall) ::: (B)\nAnd(publish(M) == fall, publish(L) == fall, publish(O) == fall) ::: (C)\nAnd(publish(M) == fall, publish(N) == fall, publish(P) == fall) ::: (D)\nAnd(publish(M) == fall, publish(O) == fall, publish(P) == fall) ::: (E)\n\nis_sat(And(publish(M) == fall, publish(L) == fall, publish(O) == fall)) ::: (C)"
  },
  {
    "id": "ar_lsat_201510_3-G_4_21",
    "context": "A publisher is planning to publish six cookbooks\u00e2\u20ac\u201dK, L, M, N, O, and P\u00e2\u20ac\u201dover the course of the next year. Each cookbook will be published in one of two seasons\u00e2\u20ac\u201dfall or spring\u00e2\u20ac\u201dsubject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "If N is published in the fall, which one of the following could be true",
    "options": [
      "A) K is published in the spring.",
      "B) L is published in the fall.",
      "C) M is published in the fall.",
      "D) 0 is published in the spring.",
      "E) P is published in the spring."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublish = Function([cookbooks] -> [seasons])\n\n# Constraints\nForAll([c:cookbooks], Or(publish(c) == fall, publish(c) == spring)) ::: Each cookbook published in fall or spring\npublish(M) != publish(P) ::: M and P cannot be in the same season\npublish(K) == publish(N) ::: K and N must be in the same season\nImplies(publish(K) == fall, publish(O) == fall) ::: If K is in fall, O must be in fall\nImplies(publish(M) == fall, publish(N) == spring) ::: If M is in fall, N must be in spring\n\n# Additional constraint for the question scenario\npublish(N) == fall ::: N is published in fall (given condition for the question)\n\n# Options\nQuestion ::: If N is published in the fall, which one of the following could be true?\nis_sat(publish(K) == spring) ::: (A)\nis_sat(publish(L) == fall) ::: (B)\nis_sat(publish(M) == fall) ::: (C)\nis_sat(publish(O) == spring) ::: (D)\nis_sat(publish(P) == spring) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201510_3-G_4_22",
    "context": "A publisher is planning to publish six cookbooks\u00e2\u20ac\u201dK, L, M, N, O, and P\u00e2\u20ac\u201dover the course of the next year. Each cookbook will be published in one of two seasons\u00e2\u20ac\u201dfall or spring\u00e2\u20ac\u201dsubject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "The schedule for the publication of the cookbooks is fully determined if which one of the following is true?",
    "options": [
      "A) K is published in the fall and L is published in the spring.",
      "B) 0 is published in the fall and P is published in the spring.",
      "C) P is published in the fall and L is published in the spring.",
      "D) Both K and L are published in the spring.",
      "E) Both M and L are published in the fall."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \ncookbooks = EnumSort([K, L, M, N, O, P])  \nseasons = EnumSort([fall, spring])  \npublish = Function([cookbooks] -> [seasons])  \n\n# Constraints  \nForAll([c: cookbooks], Or(publish(c) == fall, publish(c) == spring)) ::: Each cookbook published in fall or spring  \nNot(publish(M) == publish(P)) ::: M and P cannot be in the same season  \npublish(K) == publish(N) ::: K and N must be in the same season  \nImplies(publish(K) == fall, publish(O) == fall) ::: If K is in fall, O must be in fall  \nImplies(publish(M) == fall, publish(N) == spring) ::: If M is in fall, N must be in spring  \n\n# Options  \nQuestion ::: The schedule is fully determined if which one of the following is true?  \nis_valid(And(publish(K) == fall, publish(L) == spring)) ::: (A)  \nis_valid(And(publish(O) == fall, publish(P) == spring)) ::: (B)  \nis_valid(And(publish(P) == fall, publish(L) == spring)) ::: (C)  \nis_valid(And(publish(K) == spring, publish(L) == spring)) ::: (D)  \nis_valid(And(publish(M) == fall, publish(L) == fall)) ::: (E)  \n\n**Answer:** (A)  \n\n**Explanation:**  \nAdding constraint (A) forces K=fall and L=spring. This uniquely determines all assignments:  \n- K=fall \u21d2 N=fall (same season as K)  \n- K=fall \u21d2 O=fall (constraint 3)  \n- M must be spring (if M=fall, N would need to be spring, conflicting with N=fall)  \n- P=fall (since M=spring and M\u2260P)  \n- L=spring (given)  \nResulting in fall: K, N, O, P; spring: M, L. No ambiguity remains. Other options leave at least one cookbook's season undetermined."
  },
  {
    "id": "ar_lsat_201510_3-G_4_23",
    "context": "A publisher is planning to publish six cookbooks\u00e2\u20ac\u201dK, L, M, N, O, and P\u00e2\u20ac\u201dover the course of the next year. Each cookbook will be published in one of two seasons\u00e2\u20ac\u201dfall or spring\u00e2\u20ac\u201dsubject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "Which one of the following, if substituted for the condition that if M is published in the fall, N must be published in the spring, would have the same effect in determining the schedule for the publication of the cookbooks?",
    "options": [
      "A) If L is published in the fall, M must be published in the spring.",
      "B) If N is published in the fall, P must also be published in the fall.",
      "C) If M is published in the spring, P must be published in the fall.",
      "D) If N is published in the spring, M must also be published in the spring.",
      "E) If 0 is published in the spring, N must also be published in the spring."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\nseason = Function([cookbooks] -> [seasons])\n\n# Constraints\nseason(M) != season(P) ::: M and P cannot be published in the same season as each other\nseason(K) == season(N) ::: K and N must be published in the same season as each other\nImplies(season(K) == fall, season(O) == fall) ::: If K is published in the fall, O must also be published in the fall\n# Original condition replaced by option analysis\n# Implies(season(M) == fall, season(N) == spring) ::: If M is published in the fall, N must be published in the spring\n\n# Options\nQuestion ::: Which substitution has the same effect as the original M-fall\u2192N-spring condition?\nis_equivalent(Implies(season(N) == fall, season(P) == fall)) ::: (B)"
  },
  {
    "id": "ar_lsat_201606_2-G_1_1",
    "context": "Seven workers\u00e2\u20ac\u201dQuinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue\u00e2\u20ac\u201dare being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "Which one of the following is an acceptable selection for the project?",
    "options": [
      "A) Ruiz (leader), Taylor, Wells",
      "B) Verma (leader), Quinn, Taylor",
      "C) Verma (leader), Smith, Taylor",
      "D) Verma (leader), Smith, Xue",
      "E) Xue (leader), Verma, Wells"
    ],
    "answer": "C",
    "logic_program": "# Declarations  \nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])  \nselected = Function([workers] -> [bool])  \nleader = Function([workers] -> [bool])  \n\n# Constraints  \nCount([w:workers], selected(w)) == 3 ::: Exactly three of the workers will be selected  \nCount([w:workers], leader(w)) == 1 ::: Exactly one of these project members will be the project leader  \nForAll([w:workers], Implies(leader(w), selected(w))) ::: The leader must be selected  \nForAll([w:workers], Implies(Or(w == Quinn, w == Ruiz), Implies(selected(w), leader(w)))) ::: Quinn or Ruiz can be a project member only if leading the project  \nImplies(selected(Smith), selected(Taylor)) ::: If Smith is a project member, Taylor must also be  \nImplies(selected(Wells), And(Not(selected(Ruiz)), Not(selected(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be  \n\n# Options  \nQuestion ::: Which one of the following is an acceptable selection for the project?  \nis_sat(  \n    And(  \n        leader(Ruiz),  \n        selected(Ruiz),  \n        selected(Taylor),  \n        selected(Wells),  \n        ForAll([w:workers], selected(w) == Or(w == Ruiz, w == Taylor, w == Wells))  \n    )  \n) ::: (A)  \nis_sat(  \n    And(  \n        leader(Verma),  \n        selected(Verma),  \n        selected(Quinn),  \n        selected(Taylor),  \n        ForAll([w:workers], selected(w) == Or(w == Verma, w == Quinn, w == Taylor))  \n    )  \n) ::: (B)  \nis_sat(  \n    And(  \n        leader(Verma),  \n        selected(Verma),  \n        selected(Smith),  \n        selected(Taylor),  \n        ForAll([w:workers], selected(w) == Or(w == Verma, w == Smith, w == Taylor))  \n    )  \n) ::: (C)  \nis_sat(  \n    And(  \n        leader(Verma),  \n        selected(Verma),  \n        selected(Smith),  \n        selected(Xue),  \n        ForAll([w:workers], selected(w) == Or(w == Verma, w == Smith, w == Xue))  \n    )  \n) ::: (D)  \nis_sat(  \n    And(  \n        leader(Xue),  \n        selected(Xue),  \n        selected(Verma),  \n        selected(Wells),  \n        ForAll([w:workers], selected(w) == Or(w == Xue, w == Verma, w == Wells))  \n    )  \n) ::: (E)  \n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_201606_2-G_1_2",
    "context": "Seven workers\u00e2\u20ac\u201dQuinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue\u00e2\u20ac\u201dare being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "If Taylor is the project leader and Wells is a project member, then the third project member must be either",
    "options": [
      "A) Quinn or Smith",
      "B) Quinn or Xue",
      "C) Ruiz or Verma",
      "D) Smith or Xue",
      "E) Verma or Xue"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: exactly one of these project members will be the project leader\nForAll([w:workers], Implies(project_leader(w), project_member(w))) ::: project leader must be a member\nForAll([w:workers], Implies(Or(w == Quinn, w == Ruiz), Implies(project_member(w), project_leader(w)))) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), And(Not(project_member(Ruiz)), Not(project_member(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be\n\n# Scenario Constraints (given in the question)\nproject_leader(Taylor) ::: Taylor is the project leader\nproject_member(Wells) ::: Wells is a project member\n\n# Options\nQuestion ::: If Taylor is the project leader and Wells is a project member, then the third project member must be either\nis_valid(Or(project_member(Quinn), project_member(Smith))) ::: (A)\nis_valid(Or(project_member(Quinn), project_member(Xue))) ::: (B)\nis_valid(Or(project_member(Ruiz), project_member(Verma))) ::: (C)\nis_valid(Or(project_member(Smith), project_member(Xue))) ::: (D)\nis_valid(Or(project_member(Verma), project_member(Xue))) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_1_3",
    "context": "Seven workers\u00e2\u20ac\u201dQuinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue\u00e2\u20ac\u201dare being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "Verma could be the project leader if which one of the following is true?",
    "options": [
      "A) Neither Quinn nor Smith is selected.",
      "B) Neither Ruiz nor Taylor is selected.",
      "C) Neither Smith nor Taylor is selected.",
      "D) Neither Smith nor Xue is selected.",
      "E) Neither Taylor nor Wells is selected."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nselected = Function([workers] -> [bool])\nleader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], selected(w)) == 3 ::: exactly three workers will be selected\nCount([w:workers], leader(w)) == 1 ::: exactly one project leader\nForAll([w:workers], Implies(leader(w), selected(w))) ::: leader must be selected\nForAll([w:workers], Implies(Or(w == Quinn, w == Ruiz), Implies(selected(w), leader(w)))) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(selected(Smith), selected(Taylor)) ::: If Smith is selected, Taylor must also be selected\nImplies(selected(Wells), And(Not(selected(Ruiz)), Not(selected(Verma)))) ::: If Wells is selected, neither Ruiz nor Verma can be\n\n# Options\nQuestion ::: Verma could be the project leader if which one of the following is true?\nis_sat(And(leader(Verma), Not(selected(Quinn)), Not(selected(Smith)))) ::: (A)\nis_sat(And(leader(Verma), Not(selected(Ruiz)), Not(selected(Taylor)))) ::: (B)\nis_sat(And(leader(Verma), Not(selected(Smith)), Not(selected(Taylor)))) ::: (C)\nis_sat(And(leader(Verma), Not(selected(Smith)), Not(selected(Xue)))) ::: (D)\nis_sat(And(leader(Verma), Not(selected(Taylor)), Not(selected(Wells)))) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_201606_2-G_1_4",
    "context": "Seven workers\u00e2\u20ac\u201dQuinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue\u00e2\u20ac\u201dare being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "If Taylor is not a project member, which one of the following workers must be a project member?",
    "options": [
      "A) Quinn",
      "B) Ruiz",
      "C) Verma",
      "D) Wells",
      "E) Xue"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nExactlyThree([w:workers], project_member(w)) ::: exactly three of the workers will be selected to be project members\nExactlyOne([w:workers], project_leader(w)) ::: exactly one of these project members will be the project leader\nForAll([w:workers], Implies(Or(w == Quinn, w == Ruiz), Implies(project_member(w), project_leader(w)))) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), And(Not(project_member(Ruiz)), Not(project_member(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be\n\n# Options\nQuestion ::: If Taylor is not a project member, which one of the following workers must be a project member?\nNot(project_member(Taylor)) ::: Taylor is not a project member\nis_valid(project_member(Quinn)) ::: (A)\nis_valid(project_member(Ruiz)) ::: (B)\nis_valid(project_member(Verma)) ::: (C)\nis_valid(project_member(Wells)) ::: (D)\nis_valid(project_member(Xue)) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_1_5",
    "context": "Seven workers\u00e2\u20ac\u201dQuinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue\u00e2\u20ac\u201dare being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "The selection for the project is completely determined if which one of the following is true?",
    "options": [
      "A) Neither Quinn nor Smith is selected.",
      "B) Neither Quinn nor Taylor is selected.",
      "C) Neither Quinn nor Xue is selected.",
      "D) Neither Ruiz nor Wells is selected.",
      "E) Neither Ruiz nor Verma is selected."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nselected = Function([technicians] -> [bool])\nleader = Function([technicians] -> [bool])\n\n# Constraints\nCount([t:technicians], selected(t)) == 3 ::: exactly three selected\nCount([t:technicians], leader(t)) == 1 ::: exactly one leader\nForAll([t:technicians], Implies(Or(t == Quinn, t == Ruiz), Implies(selected(t), leader(t)))) ::: Quinn/Ruiz can be members only if leading\nImplies(selected(Smith), selected(Taylor)) ::: Smith selected implies Taylor selected\nForAll([t:technicians], Implies(selected(Wells), Not(Or(selected(Ruiz), selected(Verma))))) ::: Wells selected excludes Ruiz and Verma\n\n# Options\nQuestion ::: The selection is completely determined if which one of the following is true?\nis_unique_selection(ForAll([t:technicians], Not(Or(selected(Quinn), selected(Smith))))) ::: (A)\nis_unique_selection(ForAll([t:technicians], Not(Or(selected(Quinn), selected(Taylor))))) ::: (B)\nis_unique_selection(ForAll([t:technicians], Not(Or(selected(Quinn), selected(Xue))))) ::: (C)\nis_unique_selection(ForAll([t:technicians], Not(Or(selected(Ruiz), selected(Wells))))) ::: (D)\nis_unique_selection(ForAll([t:technicians], Not(Or(selected(Ruiz), selected(Verma))))) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_2_6",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Which one of the following could be an accurate assignment of students, in order from the earliest year to the latest?",
    "options": [
      "A) Louis, Onyx, Ryan, Yoshio",
      "B) Mollie, Yoshio, Tiffany, Onyx",
      "C) Onyx, Ryan, Louis, Tiffany",
      "D) Tiffany, Onyx, Louis, Ryan",
      "E) Yoshio, Onyx, Louis, Mollie"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([y1921, y1922, y1923, y1924])\nassigned = Function([years] -> [students])\n\n# Constraints\nDistinct([y:years], assigned(y)) ::: Each of the four years will have exactly one student assigned to it\nOr(assigned(y1923) == Louis, assigned(y1923) == Tiffany) ::: Only Louis or Tiffany can be assigned to 1923\nForAll([y:years], Implies(assigned(y) == Mollie, Or(y == y1921, y == y1922))) ::: If Mollie is assigned, she must be in 1921 or 1922\nImplies(Exists([y:years], assigned(y) == Tiffany), Exists([y:years], assigned(y) == Ryan)) ::: If Tiffany is assigned, Ryan must be assigned\nForAll([y:years], Implies(assigned(y) == Ryan, And(y != y1921, assigned(Prev(y)) == Onyx))) ::: If Ryan is assigned, Onyx must be in the year immediately prior\n\n# Options\nQuestion ::: Which one of the following could be an accurate assignment of students, in order from the earliest year to the latest?\nis_sat(And(\n    assigned(y1921) == Onyx,\n    assigned(y1922) == Ryan,\n    assigned(y1923) == Louis,\n    assigned(y1924) == Tiffany\n)) ::: (C)"
  },
  {
    "id": "ar_lsat_201606_2-G_2_7",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Mollie must be assigned to 1922 if which one of the following is true?",
    "options": [
      "A) Louis is assigned to 1924.",
      "B) Onyx is assigned to 1921.",
      "C) Onyx is assigned to 1924.",
      "D) Tiffany is assigned to 1923.",
      "E) Yoshio is assigned to 1921."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([y1921, y1922, y1923, y1924])\nassigned = Function([students, years] -> [bool])\n\n# Constraints\nForAll([y:years], ExactlyOne([s:students], assigned(s, y))) ::: Each year has exactly one student\nForAll([s:students], AtMostOne([y:years], assigned(s, y))) ::: Each student is assigned to at most one year\nForAll([s:students], Implies(Or(s == Louis, s == Tiffany), assigned(s, y1923))) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(Exists([y:years], assigned(Mollie, y)), Or(assigned(Mollie, y1921), assigned(Mollie, y1922))) ::: If Mollie is assigned, she must be in 1921 or 1922\nImplies(Exists([y:years], assigned(Tiffany, y)), Exists([y:years], assigned(Ryan, y))) ::: If Tiffany is assigned, Ryan must be assigned\nForAll([y:years], Implies(assigned(Ryan, y), Exists([y_prev:years], And(y_prev == y - 1, assigned(Onyx, y_prev))))) ::: If Ryan is assigned, Onyx must be in the prior year\n\n# Options\nQuestion ::: Mollie must be assigned to 1922 if which one of the following is true?\nis_valid(Implies(assigned(Louis, y1924), assigned(Mollie, y1922))) ::: (A)\nis_valid(Implies(assigned(Onyx, y1921), assigned(Mollie, y1922))) ::: (B)\nis_valid(Implies(assigned(Onyx, y1924), assigned(Mollie, y1922))) ::: (C)\nis_valid(Implies(assigned(Tiffany, y1923), assigned(Mollie, y1922))) ::: (D)\nis_valid(Implies(assigned(Yoshio, y1921), assigned(Mollie, y1922))) ::: (E)\n\n**Answer:** (E) Yoshio is assigned to 1921."
  },
  {
    "id": "ar_lsat_201606_2-G_2_8",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "If both Ryan and Yoshio are assigned to the project, which one of the following could be true?",
    "options": [
      "A) Louis is assigned to 1923.",
      "B) Mollie is assigned to 1921.",
      "C) Onyx is assigned to 1922.",
      "D) Tiffany is assigned to 1924.",
      "E) Yoshio is assigned to 1922."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([y1921, y1922, y1923, y1924])\nassigned = Function([students] -> [bool])\nyear_of = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], And(assigned(s), year_of(s) == y))) ::: Each year has exactly one student assigned\nForAll([s:students], Implies(assigned(s), Count([y:years], year_of(s) == y) == 1)) ::: Each assigned student has exactly one year\nForAll([s:students], Implies(assigned(s), If(s == Louis || s == Tiffany, year_of(s) == y1923, True))) ::: Only Louis or Tiffany can be assigned to 1923\nForAll([s:students], Implies(And(assigned(s), s == Mollie), Or(year_of(s) == y1921, year_of(s) == y1922))) ::: If Mollie is assigned, she must be in 1921 or 1922\nImplies(assigned(Tiffany), assigned(Ryan)) ::: If Tiffany is assigned, Ryan must be assigned\nForAll([s:students], Implies(And(assigned(s), s == Ryan), Exists([s2:students], And(assigned(s2), s2 == Onyx, year_of(s2) == Predecessor(year_of(s)))))) ::: If Ryan is assigned, Onyx must be in the prior year\nassigned(Ryan) ::: Ryan is assigned (given)\nassigned(Yoshio) ::: Yoshio is assigned (given)\n\n# Options\nQuestion ::: If both Ryan and Yoshio are assigned to the project, which one of the following could be true?\nis_sat(And(assigned(Louis), year_of(Louis) == y1923)) ::: (A)\nis_sat(And(assigned(Mollie), year_of(Mollie) == y1921)) ::: (B)\nis_sat(And(assigned(Onyx), year_of(Onyx) == y1922)) ::: (C)\nis_sat(And(assigned(Tiffany), year_of(Tiffany) == y1924)) ::: (D)\nis_sat(And(assigned(Yoshio), year_of(Yoshio) == y1922)) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_2_9",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "How many of the students are there who could be the one assigned to 1921?",
    "options": [
      "A) six",
      "B) five",
      "C) four",
      "D) three",
      "E) two"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([y1921, y1922, y1923, y1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([s:students], Implies(Exists([y:years], assigned(s) == y), Count([s2:students], assigned(s2) == y) == 1)) ::: Each year has exactly one student\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each year is assigned to exactly one student\nForAll([s:students], Implies(assigned(s) == y1923, Or(s == Louis, s == Tiffany))) ::: Only Louis or Tiffany can be assigned to 1923\nForAll([s:students], Implies(s == Mollie, Or(assigned(Mollie) == y1921, assigned(Mollie) == y1922))) ::: If Mollie is assigned, she must be in 1921 or 1922\nForAll([s:students], Implies(s == Tiffany, Exists([r:students], r == Ryan))) ::: If Tiffany is assigned, Ryan must be assigned\nForAll([s:students], Implies(s == Ryan, Exists([o:students], o == Onyx And assigned(o) == Prior(assigned(Ryan))))) ::: If Ryan is assigned, Onyx must be in the prior year\n\n# Options\nQuestion ::: How many of the students are there who could be the one assigned to 1921?\npossible_1921 = Count([s:students], is_sat(assigned(s) == y1921))\nis_valid(possible_1921 == 6) ::: (A)\nis_valid(possible_1921 == 5) ::: (B)\nis_valid(possible_1921 == 4) ::: (C)\nis_valid(possible_1921 == 3) ::: (D)\nis_valid(possible_1921 == 2) ::: (E)\n\n**Answer:** (D) three"
  },
  {
    "id": "ar_lsat_201606_2-G_2_10",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "If Yoshio is not assigned to the project, which one of the following could be true?",
    "options": [
      "A) Louis is not assigned to the project.",
      "B) Ryan is not assigned to the project.",
      "C) Tiffany is not assigned to the project.",
      "D) Onyx is assigned to 1922.",
      "E) Louis is assigned to 1924."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])  \nyears = EnumSort([y1921, y1922, y1923, y1924])  \nassigned = Function([students] -> [years])  \nis_assigned = Function([students] -> [bool])  \n\n# Constraints  \nForAll([s:students], Implies(is_assigned(s), Exists([y:years], assigned(s) == y))) ::: Each assigned student has a year  \nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each year has exactly one student  \nForAll([s1:students, s2:students], Implies(And(s1 != s2, is_assigned(s1), is_assigned(s2)), assigned(s1) != assigned(s2))) ::: No two students assigned to the same year  \nOr(assigned(Louis) == y1923, assigned(Tiffany) == y1923) ::: Only Louis or Tiffany can be assigned to 1923  \nForAll([s:students], Implies(And(is_assigned(Mollie), s == Mollie), Or(assigned(s) == y1921, assigned(s) == y1922))) ::: If Mollie is assigned, she must be in 1921 or 1922  \nImplies(is_assigned(Tiffany), is_assigned(Ryan)) ::: If Tiffany is assigned, Ryan must be assigned  \nForAll([y:years], Implies(And(is_assigned(Ryan), assigned(Ryan) == y), Exists([yp:years], And(yp == y - 1, is_assigned(Onyx), assigned(Onyx) == yp)))) ::: If Ryan is assigned, Onyx must be in the prior year  \nNot(is_assigned(Yoshio)) ::: Yoshio is not assigned  \n\n# Options  \nQuestion ::: If Yoshio is not assigned, which one of the following could be true?  \nis_sat(Not(is_assigned(Louis))) ::: (A)  \nis_sat(Not(is_assigned(Ryan))) ::: (B)  \nis_sat(Not(is_assigned(Tiffany))) ::: (C)  \nis_sat(And(is_assigned(Onyx), assigned(Onyx) == y1922)) ::: (D)  \nis_sat(And(is_assigned(Louis), assigned(Louis) == y1924)) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_2_11",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students\u00e2\u20ac\u201dLouis, Mollie, Onyx, Ryan, Tiffany, and Yoshio\u00e2\u20ac\u201dare available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Which one of the following students CANNOT be assigned to 1922?",
    "options": [
      "A) Louis",
      "B) Mollie",
      "C) Onyx",
      "D) Ryan",
      "E) Yoshio"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([y1921, y1922, y1923, y1924])\nassigned = Function([students] -> [years])\nassigned_to = Function([years] -> [students])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each year has exactly one student assigned\nForAll([s:students], Implies(assigned(s) != null, ForAll([y:years], Implies(assigned(s) == y, assigned_to(y) == s)))) ::: Each student is assigned to at most one year\nForAll([y:years], Or(assigned_to(y) == Louis, assigned_to(y) == Tiffany)) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(Exists([s:students], assigned(s) == Mollie), Or(assigned(Mollie) == y1921, assigned(Mollie) == y1922)) ::: If Mollie is assigned, she must be in 1921 or 1922\nImplies(assigned(Tiffany) != null, assigned(Ryan) != null) ::: If Tiffany is assigned, Ryan must be assigned\nImplies(assigned(Ryan) != null, And(assigned(Onyx) != null, assigned(Onyx) == prev_year(assigned(Ryan)))) ::: If Ryan is assigned, Onyx must be in the year immediately prior\n\n# Options\nQuestion ::: Which one of the following students CANNOT be assigned to 1922?\nis_invalid(assigned_to(y1922) == Louis) ::: (A)\nis_invalid(assigned_to(y1922) == Mollie) ::: (B)\nis_invalid(assigned_to(y1922) == Onyx) ::: (C)\nis_invalid(assigned_to(y1922) == Ryan) ::: (D)\nis_invalid(assigned_to(y1922) == Yoshio) ::: (E)\n\n**Answer:** (A) Louis"
  },
  {
    "id": "ar_lsat_201606_2-G_3_12",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be an accurate list of the six antiques, in the order in which they are auctioned, from June 1st through June 6th?",
    "options": [
      "A) harmonica, table, sundial, lamp, vase, mirror",
      "B) lamp, harmonica, sundial, mirror, vase, table",
      "C) harmonica, sundial, table, mirror, lamp, vase",
      "D) sundial, mirror, harmonica, table, vase, lamp",
      "E) vase, sundial, lamp, harmonica, table, mirror"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([d1, d2, d3, d4, d5, d6])\nauction = Function([antiques] -> [days])\n\n# Constraints\nForAll([a:antiques], 1 <= auction(a) <= 6) ::: each antique is auctioned on a day from June 1st to 6th\nDistinct([a:antiques], auction(a)) ::: each antique is auctioned exactly once\nauction(sundial) != 1 ::: The sundial is not auctioned on June 1st\nImplies(auction(harmonica) < auction(lamp), auction(mirror) < auction(lamp)) ::: If harmonica is before lamp, then mirror is before lamp\nAnd(auction(sundial) < auction(mirror), auction(sundial) < auction(vase)) ::: Sundial is before mirror and vase\nXor(auction(table) < auction(harmonica), auction(table) < auction(vase)) ::: Table is before harmonica or vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be an accurate list of the six antiques, in the order in which they are auctioned, from June 1st through June 6th?\nis_sat(And(\n    auction(harmonica) == 1,\n    auction(table) == 2,\n    auction(sundial) == 3,\n    auction(lamp) == 4,\n    auction(vase) == 5,\n    auction(mirror) == 6\n)) ::: (A)\nis_sat(And(\n    auction(lamp) == 1,\n    auction(harmonica) == 2,\n    auction(sundial) == 3,\n    auction(mirror) == 4,\n    auction(vase) == 5,\n    auction(table) == 6\n)) ::: (B)\nis_sat(And(\n    auction(harmonica) == 1,\n    auction(sundial) == 2,\n    auction(table) == 3,\n    auction(mirror) == 4,\n    auction(lamp) == 5,\n    auction(vase) == 6\n)) ::: (C)\nis_sat(And(\n    auction(sundial) == 1,\n    auction(mirror) == 2,\n    auction(harmonica) == 3,\n    auction(table) == 4,\n    auction(vase) == 5,\n    auction(lamp) == 6\n)) ::: (D)\nis_sat(And(\n    auction(vase) == 1,\n    auction(sundial) == 2,\n    auction(lamp) == 3,\n    auction(harmonica) == 4,\n    auction(table) == 5,\n    auction(mirror) == 6\n)) ::: (E)\n\n**Answer**\n(C)"
  },
  {
    "id": "ar_lsat_201606_2-G_3_13",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) The table is auctioned on June 2nd and the lamp is auctioned on June 3rd.",
      "B) The sundial is auctioned on June 2nd and the vase is auctioned on June 3rd.",
      "C) The mirror is auctioned on June 3rd and the sundial is auctioned on June 4th.",
      "D) The vase is auctioned on June 4th and the sundial is auctioned on June 5th.",
      "E) The sundial is auctioned on June 4th and the table is auctioned on June 5th."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([d1, d2, d3, d4, d5, d6])  # Representing June 1st to 6th\nauction_day = Function([antiques] -> [days])\n\n# Constraints\nDistinct([a:antiques], auction_day(a)) ::: Each antique is auctioned on a distinct day\nauction_day(sundial) != d1 ::: The sundial is not auctioned on June 1st\nImplies(auction_day(harmonica) < auction_day(lamp), auction_day(mirror) < auction_day(lamp)) ::: If harmonica is before lamp, mirror is before lamp\nAnd(auction_day(sundial) < auction_day(mirror), auction_day(sundial) < auction_day(vase)) ::: Sundial is earlier than mirror and vase\nXor(And(auction_day(table) < auction_day(harmonica), Not(auction_day(table) < auction_day(vase))), \n    And(auction_day(table) < auction_day(vase), Not(auction_day(table) < auction_day(harmonica)))) ::: Table is earlier than exactly one of harmonica or vase\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(auction_day(table) == d2, auction_day(lamp) == d3)) ::: (A)\nis_sat(And(auction_day(sundial) == d2, auction_day(vase) == d3)) ::: (B)\nis_sat(And(auction_day(mirror) == d3, auction_day(sundial) == d4)) ::: (C)\nis_sat(And(auction_day(vase) == d4, auction_day(sundial) == d5)) ::: (D)\nis_sat(And(auction_day(sundial) == d4, auction_day(table) == d5)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201606_2-G_3_14",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "If the table is auctioned on a date that is later than both the date on which the mirror is auctioned and the date on which the vase is auctioned, then which one of the following could be true?",
    "options": [
      "A) The harmonica is auctioned on an earlier date than the table.",
      "B) The table is auctioned on an earlier date than the lamp.",
      "C) The table is auctioned on an earlier date than the sundial.",
      "D) The mirror is auctioned on an earlier date than the vase.",
      "E) The sundial is auctioned on an earlier date than the lamp."
    ],
    "answer": "D",
    "logic_program": "# Declarations  \nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])  \ndays = EnumSort([d1, d2, d3, d4, d5, d6])  \nauction_day = Function([antiques] -> [days])  \n\n# Constraints  \nDistinct([a:antiques], auction_day(a)) ::: each antique auctioned exactly once  \nauction_day(sundial) != d1 ::: The sundial is not auctioned on June 1st  \nImplies(auction_day(harmonica) < auction_day(lamp), auction_day(mirror) < auction_day(lamp)) ::: If harmonica is before lamp, then mirror is before lamp  \nAnd(auction_day(sundial) < auction_day(mirror), auction_day(sundial) < auction_day(vase)) ::: Sundial is before mirror and vase  \nOr(And(auction_day(table) < auction_day(harmonica), auction_day(table) >= auction_day(vase)),  \n   And(auction_day(table) < auction_day(vase), auction_day(table) >= auction_day(harmonica))) ::: Table before harmonica or vase but not both  \n\n# Additional Condition for Question  \nAnd(auction_day(table) > auction_day(mirror), auction_day(table) > auction_day(vase)) ::: Table is after both mirror and vase  \n\n# Options  \nQuestion ::: If the table is auctioned after both mirror and vase, which could be true?  \nis_sat(auction_day(harmonica) < auction_day(table)) ::: (A)  \nis_sat(auction_day(table) < auction_day(lamp)) ::: (B)  \nis_sat(auction_day(table) < auction_day(sundial)) ::: (C)  \nis_sat(auction_day(mirror) < auction_day(vase)) ::: (D)  \nis_sat(auction_day(sundial) < auction_day(lamp)) ::: (E)  \n\n**Answer:** (D) The mirror is auctioned on an earlier date than the vase.  \n\n**Explanation:**  \nUnder the condition that the table is after both mirror and vase, the constraints allow scenarios where the mirror precedes the vase (e.g., sundial \u2192 mirror \u2192 vase \u2192 table \u2192 harmonica/lamp). This makes option D possible. Other options violate temporal constraints imposed by the problem's rules."
  },
  {
    "id": "ar_lsat_201606_2-G_3_15",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following CANNOT be the antique auctioned on the day immediately preceding the day on which the vase is auctioned?",
    "options": [
      "A) the harmonica",
      "B) the lamp",
      "C) the mirror",
      "D) the sundial",
      "E) the table"
    ],
    "answer": "A",
    "logic_program": "# Declarations\ndays = EnumSort([d1, d2, d3, d4, d5, d6])\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\nauction_day = Function([antiques] -> [days])\n\n# Constraints\nDistinct([a:antiques], auction_day(a)) ::: each antique is auctioned on exactly one day\nauction_day(sundial) != d1 ::: The sundial is not auctioned on June 1st\nImplies(auction_day(harmonica) < auction_day(lamp), auction_day(mirror) < auction_day(lamp)) ::: If harmonica is before lamp, then mirror is before lamp\nAnd(auction_day(sundial) < auction_day(mirror), auction_day(sundial) < auction_day(vase)) ::: Sundial is before mirror and vase\nXor(auction_day(table) < auction_day(harmonica), auction_day(table) < auction_day(vase)) ::: Table is before harmonica or vase but not both\n\n# Options\nQuestion ::: Which one of the following CANNOT be the antique auctioned on the day immediately preceding the day on which the vase is auctioned?\nis_exception(Exists([d:days], And(auction_day(vase) == d, auction_day(harmonica) == d-1))) ::: (A)\nis_exception(Exists([d:days], And(auction_day(vase) == d, auction_day(lamp) == d-1))) ::: (B)\nis_exception(Exists([d:days], And(auction_day(vase) == d, auction_day(mirror) == d-1))) ::: (C)\nis_exception(Exists([d:days], And(auction_day(vase) == d, auction_day(sundial) == d-1))) ::: (D)\nis_exception(Exists([d:days], And(auction_day(vase) == d, auction_day(table) == d-1))) ::: (E)\n\n**Answer:** (A) the harmonica"
  },
  {
    "id": "ar_lsat_201606_2-G_3_16",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) The mirror is auctioned on June 2nd.",
      "B) The lamp is auctioned on June 2nd.",
      "C) The vase is auctioned on. June 2nd.",
      "D) The lamp is auctioned on June 3rd.",
      "E) The mirror is auctioned on June 5th."
    ],
    "answer": "E",
    "logic_program": "# Declarations  \nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])  \ndays = EnumSort([d1, d2, d3, d4, d5, d6])  \nauction = Function([antiques] -> [days])  \n\n# Constraints  \nDistinct([a:antiques], auction(a)) ::: each antique is auctioned on a different day  \nauction(sundial) != d1 ::: The sundial is not auctioned on June 1st  \nImplies(auction(harmonica) < auction(lamp), auction(mirror) < auction(lamp)) ::: If harmonica is before lamp, mirror is also before lamp  \nAnd(auction(sundial) < auction(mirror), auction(sundial) < auction(vase)) ::: Sundial is before mirror and vase  \nXor(auction(table) < auction(harmonica), auction(table) < auction(vase)) ::: Table is before harmonica or vase, but not both  \n\n# Options  \nQuestion ::: Which one of the following could be true?  \nis_sat(auction(mirror) == d2) ::: (A)  \nis_sat(auction(lamp) == d2) ::: (B)  \nis_sat(auction(vase) == d2) ::: (C)  \nis_sat(auction(lamp) == d3) ::: (D)  \nis_sat(auction(mirror) == d5) ::: (E)  \n\n**Answer**  \nThe correct answer is (E). The constraints allow a valid schedule where the mirror is auctioned on June 5th, as demonstrated in the analysis. Other options violate constraints when tested."
  },
  {
    "id": "ar_lsat_201606_2-G_3_17",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days\u00e2\u20ac\u201dJune 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) The sundial is auctioned on June 5th.",
      "B) The sundial is auctioned on June 4th.",
      "C) The lamp is auctioned on June 5th and the mirror is auctioned on June 6th.",
      "D) The table is auctioned on June 3rd and the lamp is auctioned on June 4th.",
      "E) The harmonica is auctioned on June 2nd and the vase is auctioned on June 3rd."
    ],
    "answer": "B",
    "logic_program": "# Declarations\ndays = EnumSort([d1, d2, d3, d4, d5, d6])\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\nauction_day = Function([antiques] -> [days])\n\n# Constraints\nDistinct([a:antiques], auction_day(a)) ::: each antique is auctioned exactly once\nauction_day(sundial) != d1 ::: The sundial is not auctioned on June 1st\nImplies(auction_day(harmonica) < auction_day(lamp), auction_day(mirror) < auction_day(lamp)) ::: If harmonica is before lamp, then mirror is before lamp\nAnd(auction_day(sundial) < auction_day(mirror), auction_day(sundial) < auction_day(vase)) ::: Sundial is before mirror and vase\nXor(auction_day(table) < auction_day(harmonica), auction_day(table) < auction_day(vase)) ::: Table is before harmonica or vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(auction_day(sundial) == d5) ::: (A)\nis_sat(auction_day(sundial) == d4) ::: (B)\nis_sat(And(auction_day(lamp) == d5, auction_day(mirror) == d6)) ::: (C)\nis_sat(And(auction_day(table) == d3, auction_day(lamp) == d4)) ::: (D)\nis_sat(And(auction_day(harmonica) == d2, auction_day(vase) == d3)) ::: (E)\n\n**Answer:** (B)"
  },
  {
    "id": "ar_lsat_201606_2-G_4_18",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following could be the order of the auditions, from first to last?",
    "options": [
      "A) Kammer, Trillo, Zinn, Waite, Lugo, Yoshida",
      "B) Waite, Kammer, Yoshida, Zinn, Lugo, Trillo",
      "C) Waite, Lugo, Kammer, Trillo, Zinn, Yoshida",
      "D) Waite, Zinn, Kammer, Trillo, Lugo, Yoshida",
      "E) Zinn, Yoshida, Waite, Lugo, Kammer, Trillo"
    ],
    "answer": "D",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\nposition = Function([singers] -> [int])\nrecorded = {Kammer, Lugo}\n\n# Constraints\nForAll([s:singers], And(1 <= position(s), position(s) <= 6)) ::: auditions are scheduled from first to sixth\nDistinct([s:singers], position(s)) ::: each singer has a unique position\nForAll([s:singers], Implies(s != Kammer, s != Lugo, Not(recorded(s)))) ::: only Kammer and Lugo are recorded\nposition(Kammer) < position(Trillo) ::: Kammer before Trillo\nposition(Zinn) < position(Yoshida) ::: Zinn before Yoshida\nposition(Waite) < position(Kammer) ::: Waite before Kammer\nposition(Waite) < position(Lugo) ::: Waite before Lugo\nposition.fourth != Kammer ::: fourth not recorded (Kammer is recorded)\nposition.fourth != Lugo ::: fourth not recorded (Lugo is recorded)\nposition.fifth == Kammer | position.fifth == Lugo ::: fifth must be recorded\n\n# Options\nQuestion ::: Which one of the following could be the order of the auditions, from first to last?\nis_valid(And(\n    position(Kammer) == 1,\n    position(Trillo) == 2,\n    position(Zinn) == 3,\n    position(Waite) == 4,\n    position(Lugo) == 5,\n    position(Yoshida) == 6\n)) ::: (A)\nis_valid(And(\n    position(Waite) == 1,\n    position(Kammer) == 2,\n    position(Yoshida) == 3,\n    position(Zinn) == 4,\n    position(Lugo) == 5,\n    position(Trillo) == 6\n)) ::: (B)\nis_valid(And(\n    position(Waite) == 1,\n    position(Lugo) == 2,\n    position(Kammer) == 3,\n    position(Trillo) == 4,\n    position(Zinn) == 5,\n    position(Yoshida) == 6\n)) ::: (C)\nis_valid(And(\n    position(Waite) == 1,\n    position(Zinn) == 2,\n    position(Kammer) == 3,\n    position(Trillo) == 4,\n    position(Lugo) == 5,\n    position(Yoshida) == 6\n)) ::: (D)\nis_valid(And(\n    position(Zinn) == 1,\n    position(Yoshida) == 2,\n    position(Waite) == 3,\n    position(Lugo) == 4,\n    position(Kammer) == 5,\n    position(Trillo) == 6\n)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_201606_2-G_4_19",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following CANNOT be the second audition?",
    "options": [
      "A) Kammer's audition",
      "B) Lugo's audition",
      "C) Trillo's audition",
      "D) Waite's audition",
      "E) Zinn's audition"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\nrecorded = [Kammer, Lugo]\npositions = 1..6\naudition_order = Function([singers] -> [positions])\n\n# Constraints\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6)) ::: auditions are in positions 1-6\nDistinct([s:singers], audition_order(s)) ::: each singer has unique position\naudition_order(Kammer) < audition_order(Trillo) ::: Kammer before Trillo\naudition_order(Zinn) < audition_order(Yoshida) ::: Zinn before Yoshida\nForAll([s:singers], Implies(s != Kammer, s != Lugo, audition_order(s) != 4)) ::: 4th audition not recorded\naudition_order(Lugo) == 5 | audition_order(Kammer) == 5 ::: 5th audition must be recorded\naudition_order(Waite) < audition_order(Kammer) ::: Waite before both recorded\naudition_order(Waite) < audition_order(Lugo) ::: Waite before both recorded\n\n# Options\nQuestion ::: Which one of the following CANNOT be the second audition?\nis_exception(is_sat(audition_order(Kammer) == 2)) ::: (A)\nis_exception(is_sat(audition_order(Lugo) == 2)) ::: (B)\nis_exception(is_sat(audition_order(Trillo) == 2)) ::: (C)\nis_exception(is_sat(audition_order(Waite) == 2)) ::: (D)\nis_exception(is_sat(audition_order(Zinn) == 2)) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_4_20",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following could be the sixth audition?",
    "options": [
      "A) Kammer's audition",
      "B) Lugo's audition",
      "C) Trillo's audition",
      "D) Waite's audition",
      "E) Zinn's audition"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\nposition = Function([singers] -> [int])\nrecorded = Function([singers] -> [bool])\n\n# Constraints\nForAll([s:singers], And(1 <= position(s), position(s) <= 6)) ::: each singer auditions exactly once\nDistinct([s:singers], position(s)) ::: no two singers audition at the same time\nAnd(recorded(Kammer), recorded(Lugo)) ::: Kammer and Lugo are recorded\nForAll([s:singers], Implies(Not(Or(s == Kammer, s == Lugo)), Not(recorded(s)))) ::: only Kammer and Lugo are recorded\nNot(recorded(Trillo)) ::: Trillo is not recorded\nNot(recorded(Waite)) ::: Waite is not recorded\nNot(recorded(Yoshida)) ::: Yoshida is not recorded\nNot(recorded(Zinn)) ::: Zinn is not recorded\nImplies(recorded(s), Or(s == Kammer, s == Lugo)) ::: only Kammer and Lugo are recorded\nposition(Waite) < position(Kammer) ::: Waite's audition is before Kammer's\nposition(Waite) < position(Lugo) ::: Waite's audition is before Lugo's\nposition(Kammer) < position(Trillo) ::: Kammer before Trillo\nposition(Zinn) < position(Yoshida) ::: Zinn before Yoshida\nImplies(position(s) == 4, Not(recorded(s))) ::: fourth audition not recorded\nExists([s:singers], And(recorded(s), position(s) == 5)) ::: fifth audition is recorded\n\n# Options\nQuestion ::: Which one of the following could be the sixth audition?\nis_sat(position(Trillo) == 6) ::: (C)"
  },
  {
    "id": "ar_lsat_201606_2-G_4_21",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "If Kammer's audition is immediately before Yoshida's, which one of the following could be true?",
    "options": [
      "A) Kammer's audition is second.",
      "B) Trillo's audition is fourth.",
      "C) Waite's audition is third.",
      "D) Yoshida's audition is sixth.",
      "E) Zinn's audition is second."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\npositions = EnumSort([1, 2, 3, 4, 5, 6])\naudition_order = Function([singers] -> [positions])\n\n# Constraints\nDistinct([s:singers], audition_order(s)) ::: Each singer has a unique position\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6)) ::: Positions are between 1 and 6\nImplies(Or(s == Kammer, s == Lugo), Or(audition_order(s) == 5, audition_order(s) != 4)) ::: Fourth cannot be recorded, fifth must be recorded (adjusted for function syntax)\naudition_order(Waite) < audition_order(Kammer) ::: Waite before Kammer\naudition_order(Waite) < audition_order(Lugo) ::: Waite before Lugo\naudition_order(Kammer) < audition_order(Trillo) ::: Kammer before Trillo\naudition_order(Zinn) < audition_order(Yoshida) ::: Zinn before Yoshida\naudition_order(Kammer) + 1 == audition_order(Yoshida) ::: Kammer immediately before Yoshida\n\n# Options\nQuestion ::: If Kammer's audition is immediately before Yoshida's, which one of the following could be true?\nis_sat(audition_order(Kammer) == 2) ::: (A)\nis_sat(audition_order(Trillo) == 4) ::: (B)\nis_sat(audition_order(Waite) == 3) ::: (C)\nis_sat(audition_order(Yoshida) == 6) ::: (D)\nis_sat(audition_order(Zinn) == 2) ::: (E)"
  },
  {
    "id": "ar_lsat_201606_2-G_4_22",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Yoshida's audition could be",
    "options": [
      "A) fifth",
      "B) fourth",
      "C) third",
      "D) second",
      "E) first"
    ],
    "answer": "B",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\npositions = [1, 2, 3, 4, 5, 6]\nrecorded = {Kammer, Lugo}\naudition = Function([singers] -> [int])\n\n# Constraints\nForAll([s:singers], And(1 <= audition(s), audition(s) <= 6)) ::: auditions are in positions 1-6\nDistinct([s:singers], audition(s)) ::: each valve is opened exactly once\nForAll([s:singers], Implies(Not(s == Kammer) & Not(s == Lugo), audition(s) != 5)) ::: fifth audition must be recorded (only Kammer/Lugo)\naudition(Kammer) != 4 ::: fourth audition cannot be recorded (Kammer/Lugo excluded)\naudition(Lugo) != 4 ::: fourth audition cannot be recorded\naudition(Waite) < audition(Kammer) ::: Waite earlier than Kammer\naudition(Waite) < audition(Lugo) ::: Waite earlier than Lugo\naudition(Kammer) < audition(Trillo) ::: Kammer before Trillo\naudition(Zinn) < audition(Yoshida) ::: Zinn before Yoshida\n\n# Options\nQuestion ::: Yoshida's audition could be\nis_sat(audition(Yoshida) == 5) ::: (A)\nis_sat(audition(Yoshida) == 4) ::: (B)\nis_sat(audition(Yoshida) == 3) ::: (C)\nis_sat(audition(Yoshida) == 2) ::: (D)\nis_sat(audition(Yoshida) == 1) ::: (E)\n\n**Answer:** (B) fourth\n\n**Step-by-Step Explanation:**\n1. **Recorded Auditions Constraint:** The fifth position must be Kammer or Lugo (recorded), eliminating Yoshida from position 5 (A invalid).\n2. **Waite's Placement:** Waite must be before both Kammer and Lugo. This forces Kammer/Lugo into later positions, creating available earlier slots for others.\n3. **Kammer Before Trillo:** Kammer must precede Trillo, limiting Trillo to positions after Kammer.\n4. **Zinn Before Yoshida:** Zinn must be earlier than Yoshida, restricting Yoshida to positions 2-6 but considering other constraints.\n5. **Fourth Position Analysis:** Through scenario testing, Yoshida can occupy position 4 without violating constraints (e.g., Kammer in 2, Lugo in 5, Waite in 1, Zinn in 3, Yoshida in 4, Trillo in 6).\n6. **Impossible Positions:** Yoshida cannot be in 1 (Zinn conflict), 2 (insufficient prior slots), 3 (overlap with Kammer/Lugo placement), or 5 (recorded slot). Only position 4 remains valid."
  },
  {
    "id": "ar_lsat_201606_2-G_4_23",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following, if substituted for the condition that Waite's audition must take place earlier than the two recorded auditions, would have the same effect in determining the order of the auditions?",
    "options": [
      "A) Zinn's audition is the only one that can take place earlier than Waite's.",
      "B) Waite's audition must take place either immediately before or immediately after Zinn's.",
      "C) Waite's audition must take place earlier than Lugo's.",
      "D) Waite's audition must be either first or second.",
      "E) The first audition cannot be recorded."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\nposition = Domain(1, 6)\nrecorded = Function([singers] -> [bool])\norder = Function([singers] -> [position])\n\n# Constraints\nDistinct([s:singers], order(s)) ::: each valve is opened exactly once\nAnd(recorded(Kammer), recorded(Lugo)) ::: Kammer's and Lugo's auditions are recorded\nForAll([s:singers], Implies(Not(Or(s == Kammer, s == Lugo)), Not(recorded(s)))) ::: other four are not recorded\norder(Kammer) < order(Trillo) ::: Kammer's audition must take place earlier than Trillo's\norder(Zinn) < order(Yoshida) ::: Zinn's audition must take place earlier than Yoshida's\norder(Waite) < order(Kammer) ::: Original condition: Waite's audition must take place earlier than the two recorded auditions\norder(Waite) < order(Lugo) ::: Original condition: Waite's audition must take place earlier than the two recorded auditions\norder(4) != Kammer ::: The fourth audition cannot be recorded (since Kammer and Lugo are the only recorded)\norder(4) != Lugo ::: The fourth audition cannot be recorded\norder(5) == Kammer | order(5) == Lugo ::: The fifth audition must be recorded\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that Waite's audition must take place earlier than the two recorded auditions, would have the same effect in determining the order of the auditions?\noption_D = And(order(Waite) == 1 | order(Waite) == 2) ::: (D) Waite's audition must be either first or second\nis_equivalent(option_D) ::: (D)"
  },
  {
    "id": "ar_lsat_201612_3-G_1_1",
    "context": "A teacher will assign each of five students\u00e2\u20ac\u201dJuana, Kelly, Lateefah, Mei, and Olga\u00e2\u20ac\u201dto exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following could be an accurate listing of the members and facilitators of the two research teams?",
    "options": [
      "A) green team: Juana, Lateefah, Olga (facilitator) red team: Kelly, Mei (facilitator)",
      "B) green team: Kelly, Lateefah (facilitator), Olga red team: Juana, Mei (facilitator)",
      "C) green team: Kelly, Lateefah, Olga (facilitator) red team: Juana (facilitator), Mei",
      "D) green team: Kelly, Mei, Olga (facilitator) red team: Juana (facilitator), Lateefah",
      "E) green team: Lateefah, Olga (facilitator) red team: Juana, Kelly (facilitator), Mei"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nroles = Function([students] -> [bool])  # True if facilitator\n\n# Constraints\nOr(Count([s:students], team(s) == green) == 2, Count([s:students], team(s) == green) == 3) ::: One team has two members, the other three\nForAll([t:teams], Count([s:students], And(team(s) == t, roles(s))) == 1) ::: Each team has exactly one facilitator\nteam(Juana) != team(Olga) ::: Juana and Olga are on different teams\nteam(Lateefah) == green ::: Lateefah is on green team\nNot(roles(Kelly)) ::: Kelly is not a facilitator\nroles(Olga) ::: Olga is a facilitator\n\n# Options\nQuestion ::: Which one of the following could be an accurate listing of the members and facilitators of the two research teams?\nis_sat(\n    And(\n        team(Juana) == red, team(Kelly) == green, team(Lateefah) == green, team(Mei) == red, team(Olga) == green,\n        roles(Olga), roles(Mei)\n    )\n) ::: (A)\nis_sat(\n    And(\n        team(Juana) == red, team(Kelly) == green, team(Lateefah) == green, team(Mei) == red, team(Olga) == green,\n        roles(Lateefah), roles(Mei)\n    )\n) ::: (B)\nis_sat(\n    And(\n        team(Juana) == red, team(Kelly) == green, team(Lateefah) == green, team(Mei) == red, team(Olga) == green,\n        roles(Olga), roles(Juana)\n    )\n) ::: (C)\nis_sat(\n    And(\n        team(Juana) == red, team(Kelly) == green, team(Lateefah) == red, team(Mei) == green, team(Olga) == green,\n        roles(Olga), roles(Juana)\n    )\n) ::: (D)\nis_sat(\n    And(\n        team(Juana) == red, team(Kelly) == red, team(Lateefah) == green, team(Mei) == red, team(Olga) == green,\n        roles(Olga), roles(Kelly)\n    )\n) ::: (E)\n\n**Answer:** (C)"
  },
  {
    "id": "ar_lsat_201612_3-G_1_2",
    "context": "A teacher will assign each of five students\u00e2\u20ac\u201dJuana, Kelly, Lateefah, Mei, and Olga\u00e2\u20ac\u201dto exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following must be true?",
    "options": [
      "A) Juana is assigned to the red team.",
      "B) Lateefah is a facilitator.",
      "C) Olga is assigned to the green team.",
      "D) Juana and Mei are not both facilitators.",
      "E) Neither Juana nor Kelly is a facilitator."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nroles = Function([students] -> [bool])  # True if facilitator\n\n# Constraints\nAnd(Count([s:students], Or(team(s) == green, team(s) == red)) == 5) ::: Each student is assigned to a team\nAnd(Count([s:students], team(s) == green) == 3, Count([s:students], team(s) == red) == 2) ::: One team has three members, the other two\nteam(Juana) != team(Olga) ::: Juana and Olga are on different teams\nteam(Lateefah) == green ::: Lateefah is on the green team\nNot(roles(Kelly)) ::: Kelly is not a facilitator\nroles(Olga) ::: Olga is a facilitator\nForAll([t:teams], Count([s:students], And(team(s) == t, roles(s))) == 1) ::: Each team has exactly one facilitator\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(team(Juana) == red) ::: (A)\nis_valid(roles(Lateefah)) ::: (B)\nis_valid(team(Olga) == green) ::: (C)\nis_valid(Not(And(roles(Juana), roles(Mei)))) ::: (D)\nis_valid(And(Not(roles(Juana)), Not(roles(Kelly)))) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_1_3",
    "context": "A teacher will assign each of five students\u00e2\u20ac\u201dJuana, Kelly, Lateefah, Mei, and Olga\u00e2\u20ac\u201dto exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following must be false?",
    "options": [
      "A) Lateefah is a facilitator, and she is assigned to the same team as Kelly is.",
      "B) Mei is a facilitator, and she is assigned to the same team as Kelly is.",
      "C) Olga is a facilitator, and she is assigned to the same team as Mei is.",
      "D) Lateefah is a facilitator, and she is assigned to a different team than Juana is.",
      "E) Mei is a facilitator, and she is assigned to a different team than Olga is."
    ],
    "answer": "B",
    "logic_program": "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nteam_of = Function([students] -> teams)\nis_facilitator = Function([students] -> bool)\n\n# Constraints\nteam_of(Juana) != team_of(Olga) ::: Juana is assigned to a different team than Olga\nteam_of(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(is_facilitator(Kelly)) ::: Kelly is not a facilitator\nis_facilitator(Olga) ::: Olga is a facilitator\nForAll([t:teams], Count([s:students], And(team_of(s) == t, is_facilitator(s))) == 1) ::: Each team has exactly one facilitator\nOr(\n    Count([s:students], team_of(s) == green) == 2,\n    Count([s:students], team_of(s) == green) == 3\n) ::: One team has two members, the other three\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_unsat(And(is_facilitator(Lateefah), team_of(Lateefah) == team_of(Kelly))) ::: (A)\nis_unsat(And(is_facilitator(Mei), team_of(Mei) == team_of(Kelly))) ::: (B)\nis_unsat(And(is_facilitator(Olga), team_of(Olga) == team_of(Mei))) ::: (C)\nis_unsat(And(is_facilitator(Lateefah), team_of(Lateefah) != team_of(Juana))) ::: (D)\nis_unsat(And(is_facilitator(Mei), team_of(Mei) != team_of(Olga))) ::: (E)\n\n**Answer**\n(D)"
  },
  {
    "id": "ar_lsat_201612_3-G_1_4",
    "context": "A teacher will assign each of five students\u00e2\u20ac\u201dJuana, Kelly, Lateefah, Mei, and Olga\u00e2\u20ac\u201dto exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "If Lateefah is a facilitator, then which one of the following could be true?",
    "options": [
      "A) Juana and Kelly are both assigned to the red team.",
      "B) Juana and Mei are both assigned to the red team.",
      "C) Lateefah and Olga are both assigned to the green team.",
      "D) Mei and Olga are both assigned to the green team.",
      "E) Mei and Olga are both assigned to the red team."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nroles = Function([students] -> [bool])  # True if facilitator\n\n# Constraints\nOr(Count([s:students], team(s) == green) == 2, Count([s:students], team(s) == green) == 3) ::: One team has two members, the other three\nForAll([t:teams], Count([s:students], And(team(s) == t, roles(s))) == 1) ::: Each team has exactly one facilitator\nteam(Juana) != team(Olga) ::: Juana is assigned to a different team than Olga\nteam(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(roles(Kelly)) ::: Kelly is not a facilitator\nroles(Olga) ::: Olga is a facilitator\nroles(Lateefah) ::: Lateefah is a facilitator (given in the question's condition)\n\n# Options\nQuestion ::: If Lateefah is a facilitator, then which one of the following could be true?\nis_sat(And(team(Juana) == red, team(Kelly) == red)) ::: (A)\nis_sat(And(team(Juana) == red, team(Mei) == red)) ::: (B)\nis_sat(And(team(Lateefah) == green, team(Olga) == green)) ::: (C)\nis_sat(And(team(Mei) == green, team(Olga) == green)) ::: (D)\nis_sat(And(team(Mei) == red, team(Olga) == red)) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_1_5",
    "context": "A teacher will assign each of five students\u00e2\u20ac\u201dJuana, Kelly, Lateefah, Mei, and Olga\u00e2\u20ac\u201dto exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "If Mei is assigned to the green team, then which one of the following must be true?",
    "options": [
      "A) Juana is assigned to the green team.",
      "B) Kelly is assigned to the red team.",
      "C) Olga is assigned to the green team.",
      "D) Lateefah is a facilitator.",
      "E) Mei is a facilitator."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nteam_assignment = Function([students] -> [teams])\nfacilitator = Function([teams] -> [students])\n\n# Constraints\nteam_assignment(Juana) != team_assignment(Olga) ::: Juana is assigned to a different team than Olga\nteam_assignment(Lateefah) == green ::: Lateefah is assigned to the green team\nForAll([t:teams], facilitator(t) != Kelly) ::: Kelly is not a facilitator\nfacilitator(team_assignment(Olga)) == Olga ::: Olga is a facilitator\nCount([s:students], team_assignment(s) == green) + Count([s:students], team_assignment(s) == red) == 5 ::: Each student is assigned to exactly one team\nOr(\n    And(Count([s:students], team_assignment(s) == green) == 3, Count([s:students], team_assignment(s) == red) == 2),\n    And(Count([s:students], team_assignment(s) == green) == 2, Count([s:students], team_assignment(s) == red) == 3)\n) ::: One team has two members, the other three\nForAll([t:teams], Count([s:students], facilitator(t) == s) == 1) ::: Each team has exactly one facilitator\n\n# Additional Constraint for the Question\nteam_assignment(Mei) == green ::: If Mei is assigned to the green team\n\n# Options\nQuestion ::: If Mei is assigned to the green team, then which one of the following must be true?\nis_valid(team_assignment(Juana) == green) ::: (A)\nis_valid(team_assignment(Kelly) == red) ::: (B)\nis_valid(team_assignment(Olga) == green) ::: (C)\nis_valid(facilitator(green) == Lateefah) ::: (D)\nis_valid(facilitator(green) == Mei) ::: (E)\n\n**Answer:** (B) Kelly is assigned to the red team."
  },
  {
    "id": "ar_lsat_201612_3-G_2_6",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following could be the order in which the clues are mentioned, from the first chapter through the seventh?",
    "options": [
      "A) S, T, Z, X, U, W, R",
      "B) T, X, U, W, S, R, Z",
      "C) U, S, X, T, Z, R, W",
      "D) X, U, T, Z, R, W, S",
      "E) Z, R, T, U, X, W, S"
    ],
    "answer": "C",
    "logic_program": "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmention = Function([clues] -> [chapters])\nForAll([c:clues], And(1 <= mention(c), mention(c) <= 7))\n\n# Constraints\nDistinct([c:clues], mention(c)) ::: Each clue is mentioned exactly once\nmention(T) != 1 ::: T cannot be mentioned in chapter 1\nAnd(mention(T) < mention(W), mention(W) == mention(T) + 3) ::: T must be before W with exactly two chapters separating them\nForAll([c1:chapters, c2:chapters], Implies(Or(c1 == c2 + 1, c1 == c2 - 1), Not(And(mention(S) == c1, mention(Z) == c2)))) ::: S and Z cannot be adjacent\nForAll([c1:chapters, c2:chapters], Implies(Or(c1 == c2 + 1, c1 == c2 - 1), Not(And(mention(W) == c1, mention(X) == c2)))) ::: W and X cannot be adjacent\nExists([c:chapters], Or(mention(U) == c + 1, mention(U) == c - 1) And (mention(X) == c)) ::: U and X must be adjacent\n\n# Options\nQuestion ::: Which one of the following could be the order?\nis_sat(And(\n    mention(S) == 1, mention(T) == 2, mention(Z) == 3, mention(X) == 4, mention(U) == 5, mention(W) == 6, mention(R) == 7\n)) ::: (A)\nis_sat(And(\n    mention(T) == 1, mention(X) == 2, mention(U) == 3, mention(W) == 4, mention(S) == 5, mention(R) == 6, mention(Z) == 7\n)) ::: (B)\nis_sat(And(\n    mention(U) == 1, mention(S) == 2, mention(X) == 3, mention(T) == 4, mention(Z) == 5, mention(R) == 6, mention(W) == 7\n)) ::: (C)\nis_sat(And(\n    mention(X) == 1, mention(U) == 2, mention(T) == 3, mention(Z) == 4, mention(R) == 5, mention(W) == 6, mention(S) == 7\n)) ::: (D)\nis_sat(And(\n    mention(Z) == 1, mention(R) == 2, mention(T) == 3, mention(U) == 4, mention(X) == 5, mention(W) == 6, mention(S) == 7\n)) ::: (E)\n\n**Answer:** (D)"
  },
  {
    "id": "ar_lsat_201612_3-G_2_7",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If X is mentioned in chapter 1, which one of the following could be true?",
    "options": [
      "A) R is mentioned in chapter 3.",
      "B) R is mentioned in chapter 7.",
      "C) S is mentioned in chapter 2.",
      "D) W is mentioned in chapter 5.",
      "E) Z is mentioned in chapter 3."
    ],
    "answer": "E",
    "logic_program": "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmention = Function([chapters] -> [clues])\n\n# Constraints\nForAll([c:clues], Count([ch:chapters], mention(ch) == c) == 1) ::: Each clue is mentioned exactly once\nmention(1) == X ::: X is mentioned in chapter 1\nmention(2) == U ::: U and X must be adjacent (X in 1, U in 2)\nNot(mention(1) == T) ::: T cannot be mentioned in chapter 1\nExists([ch1:chapters, ch2:chapters], And(ch1 < ch2, mention(ch1) == T, mention(ch2) == W, ch2 == ch1 + 3)) ::: T before W with exactly two chapters separating them\nForAll([ch:chapters], Implies(Or(mention(ch) == S, mention(ch) == Z), ForAll([ch_adj:chapters], Or(abs(ch - ch_adj) != 1, Not(Or(mention(ch_adj) == S, mention(ch_adj) == Z)))))) ::: S and Z not adjacent\nForAll([ch:chapters], Implies(mention(ch) == W, ForAll([ch_adj:chapters], abs(ch - ch_adj) != 1 Or Not(mention(ch_adj) == X)))) ::: W and X not adjacent\n\n# Options\nQuestion ::: If X is mentioned in chapter 1, which one of the following could be true?\nis_sat(mention(3) == R) ::: (A)\nis_sat(mention(7) == R) ::: (B)\nis_sat(mention(2) == S) ::: (C)\nis_sat(mention(5) == W) ::: (D)\nis_sat(mention(3) == Z) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_2_8",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If U is mentioned in chapter 3, which one of the following could be true?",
    "options": [
      "A) R is mentioned in chapter 1.",
      "B) R is mentioned in chapter 5.",
      "C) S is mentioned in chapter 7.",
      "D) W is mentioned in chapter 6.",
      "E) X is mentioned in chapter 4."
    ],
    "answer": "A",
    "logic_program": "# Declarations  \nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nclues = EnumSort([R, S, T, U, W, X, Z])  \nmention = Function([clues] -> [chapters])  \n\n# Constraints  \nDistinct([c:clues], mention(c)) ::: Each clue is mentioned exactly once  \nmention(T) != 1 ::: T cannot be mentioned in chapter 1  \nAnd(mention(T) < mention(W), mention(W) == mention(T) + 3) ::: T must be before W with exactly two chapters separating them  \nForAll([c1:chapters, c2:chapters], Implies(Or(c2 == c1 + 1, c2 == c1 - 1), Not(And(mention(S) == c1, mention(Z) == c2)))) ::: S and Z cannot be adjacent  \nForAll([c1:chapters, c2:chapters], Implies(Or(c2 == c1 + 1, c2 == c1 - 1), Not(And(mention(W) == c1, mention(X) == c2)))) ::: W and X cannot be adjacent  \nExists([c:chapters], Or(And(mention(U) == c, mention(X) == c + 1), And(mention(X) == c, mention(U) == c + 1))) ::: U and X must be adjacent  \nmention(U) == 3 ::: U is mentioned in chapter 3  \n\n# Options  \nQuestion ::: If U is mentioned in chapter 3, which one of the following could be true?  \nis_sat(mention(R) == 1) ::: (A)  \nis_sat(mention(R) == 5) ::: (B)  \nis_sat(mention(S) == 7) ::: (C)  \nis_sat(mention(W) == 6) ::: (D)  \nis_sat(mention(X) == 4) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_2_9",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If Z is mentioned in chapter 7, which one of the following could be true?",
    "options": [
      "A) R is mentioned in chapter 3.",
      "B) S is mentioned in chapter 3.",
      "C) T is mentioned in chapter 4.",
      "D) U is mentioned in chapter 1.",
      "E) X is mentioned in chapter 5."
    ],
    "answer": "D",
    "logic_program": "# Declarations  \nchapters = Domain(1,7)  \nclues = EnumSort([R, S, T, U, W, X, Z])  \nassign = Function([chapters] -> [clues])  \n\n# Constraints  \nDistinct([ch:chapters], assign(ch)) ::: Each clue is mentioned exactly once  \nassign(1) != T ::: T cannot be mentioned in chapter 1  \nExists([ch:chapters], And(assign(ch) == T, assign(ch +3) == W)) ::: T must be mentioned before W with exactly two chapters separating them  \nForAll([ch:chapters], Implies(And(ch <7, assign(ch) == S), assign(ch+1) != Z)) ::: S and Z cannot be mentioned in adjacent chapters  \nForAll([ch:chapters], Implies(And(ch <7, assign(ch) == Z), assign(ch+1) != S)) ::: S and Z cannot be mentioned in adjacent chapters  \nForAll([ch:chapters], Implies(And(ch <7, assign(ch) == W), assign(ch+1) != X)) ::: W and X cannot be mentioned in adjacent chapters  \nForAll([ch:chapters], Implies(And(ch <7, assign(ch) == X), assign(ch+1) != W)) ::: W and X cannot be mentioned in adjacent chapters  \nExists([ch:chapters], Or(And(assign(ch) == U, assign(ch+1) == X), And(assign(ch) == X, assign(ch+1) == U))) ::: U and X must be mentioned in adjacent chapters  \nassign(7) == Z ::: Z is mentioned in chapter 7  \n\n# Options  \nQuestion ::: If Z is mentioned in chapter 7, which one of the following could be true?  \nis_sat(assign(3) == R) ::: (A)  \nis_sat(assign(3) == S) ::: (B)  \nis_sat(assign(4) == T) ::: (C)  \nis_sat(assign(1) == U) ::: (D)  \nis_sat(assign(5) == X) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_2_10",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) R is mentioned in chapter 7.",
      "B) T is mentioned in chapter 5.",
      "C) U is mentioned in chapter 7.",
      "D) W is mentioned in chapter 3.",
      "E) X is mentioned in chapter 6."
    ],
    "answer": "A",
    "logic_program": "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmention = Function([chapters] -> [clues])\n\n# Constraints\nForAll([c:chapters], Distinct([d:chapters], mention(c) == mention(d))) ::: Each clue is mentioned exactly once\nmention(1) != T ::: T cannot be mentioned in chapter 1\nExists([t_chap:chapters, w_chap:chapters], And(t_chap < w_chap, w_chap == t_chap + 3, mention(t_chap) == T, mention(w_chap) == W)) ::: T must be before W with exactly two chapters separating them\nForAll([c:chapters], Implies(Or(mention(c) == S, mention(c) == Z), Not(Or(mention(c+1) == S, mention(c+1) == Z)))) ::: S and Z cannot be adjacent\nForAll([c:chapters], Implies(Or(mention(c) == W, mention(c) == X), Not(Or(mention(c+1) == W, mention(c+1) == X)))) ::: W and X cannot be adjacent\nExists([c:chapters], Or(And(mention(c) == U, mention(c+1) == X), And(mention(c) == X, mention(c+1) == U))) ::: U and X must be adjacent\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(mention(7) == R) ::: (A)\nis_sat(mention(5) == T) ::: (B)\nis_sat(mention(7) == U) ::: (C)\nis_sat(mention(3) == W) ::: (D)\nis_sat(mention(6) == X) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_2_11",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues\u00e2\u20ac\u201dR, S, T, U, W, X, and Z\u00e2\u20ac\u201dis to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following, if substituted for the constraint that T cannot be mentioned in chapter 1, would have the same effect in determining the order in which the clues are mentioned?",
    "options": [
      "A) U cannot be mentioned in chapter 2.",
      "B) W cannot be mentioned in chapter 4.",
      "C) X cannot be mentioned in chapter 6.",
      "D) U must be mentioned in an earlier chapter than T.",
      "E) X must be mentioned in an earlier chapter than W,"
    ],
    "answer": "B",
    "logic_program": "# Declarations  \nclues = EnumSort([R, S, T, U, W, X, Z])  \nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])  \nmention = Function([clues] -> [chapters])  \n\n# Constraints  \nForAll([c:clues], 1 <= mention(c) <= 7) ::: Each clue is mentioned in a chapter  \nDistinct([c:clues], mention(c)) ::: Each clue is mentioned exactly once  \nmention(T) != 1 ::: T cannot be mentioned in chapter 1  \nAnd(mention(T) < mention(W), mention(W) == mention(T) + 3) ::: T must be before W with exactly two chapters separating them  \nForAll([c1:clues, c2:clues], Implies(Or(And(c1 == S, c2 == Z), And(c1 == Z, c2 == S)), Abs(mention(c1) - mention(c2)) != 1)) ::: S and Z not adjacent  \nForAll([c1:clues, c2:clues], Implies(Or(And(c1 == W, c2 == X), And(c1 == X, c2 == W)), Abs(mention(c1) - mention(c2)) != 1)) ::: W and X not adjacent  \nForAll([c1:clues, c2:clues], Implies(Or(And(c1 == U, c2 == X), And(c1 == X, c2 == U)), Abs(mention(c1) - mention(c2)) == 1)) ::: U and X must be adjacent  \n\n# Options  \nQuestion ::: Which substitute constraint has the same effect as T \u2260 1?  \nis_equivalent(ForAll([c:clues], mention(W) != 4)) ::: (B)"
  },
  {
    "id": "ar_lsat_201612_3-G_3_12",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following could be an accurate list of the paintings displayed in the lower position on walls 1 through 4, listed in that order?",
    "options": [
      "A) Franz's oil, Franz's watercolor, Greene's oil, Isaacs's oil",
      "B) Franz's oil, Hidalgo's watercolor, Isaacs's watercolor, Isaacs's oil",
      "C) Greene's oil, Franz's oil, Isaacs's oil, Hidalgo's oil",
      "D) Hidalgo's oil, Greene's oil, Greene's watercolor, Isaacs's oil",
      "E) Hidalgo's watercolor, Franz's oil, Greene's oil, Isaacs's oil"
    ],
    "answer": "C",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201612_3-G_3_13",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Isaacs's watercolor is displayed on wall 2 and Franz's oil is displayed on wall 3, which one of the following must be displayed on wall 1?",
    "options": [
      "A) Franz's watercolor",
      "B) Greene's oil",
      "C) Greene's watercolor",
      "D) Hidalgo's oil",
      "E) Hidalgo's watercolor"
    ],
    "answer": "A",
    "logic_program": "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplay = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([s:students, p:paintings], Exists([w:walls, pos:positions], display(s, p, w, pos))) ::: Each student displays exactly two paintings (oil and watercolor)\nForAll([w:walls], Count([s:students, p:paintings, pos:positions], display(s, p, w, pos)) == 2) ::: Exactly two paintings per wall\nForAll([w:walls], Exists([s:students, p:paintings], display(s, oil, w, upper) | display(s, oil, w, lower))) ::: No wall has only watercolors\nForAll([w:walls], Count([s:students], Exists([p:paintings, pos:positions], display(s, p, w, pos))) >= 2) ::: No wall has only one student's work\nForAll([w:walls], Implies(Exists([pos:positions], display(Franz, _, w, pos)), Not(Exists([pos:positions], display(Isaacs, _, w, pos))))) ::: No wall has both Franz and Isaacs\ndisplay(Greene, watercolor, 3, upper) ::: Greene's watercolor is in upper position of wall 3 (where Franz's oil is)\ndisplay(Isaacs, oil, 4, lower) ::: Isaacs's oil is in lower position of wall 4\ndisplay(Isaacs, watercolor, 2, _) ::: Isaacs's watercolor is on wall 2\ndisplay(Franz, oil, 3, lower) ::: Franz's oil is on wall 3\n\n# Options\nQuestion ::: Which one of the following must be displayed on wall 1?\nis_valid(display(Franz, watercolor, 1, _)) ::: (A)\nis_valid(display(Greene, oil, 1, _)) ::: (B)\nis_valid(display(Greene, watercolor, 1, _)) ::: (C)\nis_valid(display(Hidalgo, oil, 1, _)) ::: (D)\nis_valid(display(Hidalgo, watercolor, 1, _)) ::: (E)\n\n**Answer:** (A) Franz's watercolor must be on wall 1."
  },
  {
    "id": "ar_lsat_201612_3-G_3_14",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Hidalgo's oil is displayed on wall 2, which one of the following could also be displayed on wall 2?",
    "options": [
      "A) Franz's oil",
      "B) Greene's watercolor",
      "C) Greene's oil",
      "D) Hidalgo's watercolor",
      "E) Isaacs's watercolor"
    ],
    "answer": "E",
    "logic_program": "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\npaintings = Function([students, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s:students, p:positions], paintings(s, w, p) & (s != Isaacs))) ::: No wall has only watercolors (at least one oil)\nForAll([w:walls], Exists([s1:students, s2:students], s1 != s2 & paintings(s1, w, upper) & paintings(s2, w, lower))) ::: No wall has only one student's work\nForAll([w:walls, s1:students, s2:students], Implies(paintings(s1, w, upper) & paintings(s2, w, lower), s1 != s2)) ::: Different students per wall\nForAll([w:walls, s:students], Implies(paintings(Franz, w, lower), paintings(Greene, w, upper))) ::: Greene's watercolor is upper where Franz's oil is\npaintings(Isaacs, 4, lower) ::: Isaacs's oil is in lower of wall 4\nForAll([w:walls], Implies(paintings(Franz, w, upper) | paintings(Franz, w, lower), Not(paintings(Isaacs, w, upper) | paintings(Isaacs, w, lower)))) ::: No wall with both Franz and Isaacs\n\n# Options\nQuestion ::: If Hidalgo's oil is displayed on wall 2, which one of the following could also be displayed on wall 2?\nis_sat(paintings(Franz, 2, lower)) ::: (A)\nis_sat(paintings(Greene, 2, upper)) ::: (B)\nis_sat(paintings(Greene, 2, lower)) ::: (C)\nis_sat(paintings(Hidalgo, 2, lower)) ::: (D)\nis_sat(paintings(Isaacs, 2, lower)) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_3_15",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Greene's oil is displayed on the same wall as Franz's watercolor, which one of the following must be true?",
    "options": [
      "A) Greene's oil is displayed in an upper position.",
      "B) Hidalgo's watercolor is displayed on the same wall as Isaacs's watercolor.",
      "C) Hidalgo's oil is displayed in an upper position.",
      "D) Hidalgo's oil is displayed on the same wall as Isaacs's watercolor.",
      "E) Isaacs's watercolor is displayed in a lower position."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([wall1, wall2, wall3, wall4])\npositions = EnumSort([upper, lower])\ndisplay = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s:students, p:paintings], display(s, p, w, upper) & (p == oil)) | Exists([s:students, p:paintings], display(s, p, w, lower) & (p == oil))) ::: No wall has only watercolors\nForAll([w:walls], Exists([s1:students, s2:students], s1 != s2 & Exists([p1:paintings, p2:paintings, pos1:positions, pos2:positions], display(s1, p1, w, pos1) & display(s2, p2, w, pos2)))) ::: No wall has only one student's work\nForAll([w:walls], Not(Exists([pos1:positions, pos2:positions], display(Franz, oil, w, pos1) & display(Isaacs, oil, w, pos2))) & Not(Exists([pos1:positions, pos2:positions], display(Franz, watercolor, w, pos1) & display(Isaacs, watercolor, w, pos2)))) ::: No wall has both Franz and Isaacs\nExists([w:walls, pos:positions display display(Greene, watercolor, w, upper) & display(Franz, oil, w, lower)) ::: Greene's watercolor is upper on Franz's oil wall\ndisplay(Isaacs, oil, wall4, lower) ::: Isaacs's oil in lower of wall4\nExists([w:walls], display(Greene, oil, w, pos1) & display(Franz, watercolor, w, pos2)) ::: Greene's oil and Franz's watercolor on same wall\n\n# Options\nQuestion ::: If Greene's oil is displayed on the same wall as Franz's watercolor, which one must be true?\nis_valid(ForAll([w:walls, pos:positions], Implies(display(Hidalgo, oil, w, pos), display(Isaacs, watercolor, w, pos)))) ::: (D)"
  },
  {
    "id": "ar_lsat_201612_3-G_3_16",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Franz's oil is displayed on wall 1, which one of the following could be true?",
    "options": [
      "A) Franz's watercolor is displayed on wall 4.",
      "B) Greene's oil is displayed on wall 2.",
      "C) Greene's watercolor is displayed on wall 2.",
      "D) Hidalgo's watercolor is displayed on wall 3.",
      "E) Isaacs's oil is displayed on wall 1."
    ],
    "answer": "B",
    "logic_program": ""
  },
  {
    "id": "ar_lsat_201612_3-G_3_17",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following could be true?",
    "options": [
      "A) Both of Franz's paintings and both of Greene's paintings are displayed in lower positions.",
      "B) Both of Franz's paintings and both of Greene's paintings are displayed in upper positions.",
      "C) Both of Franz's paintings and both of Hidalgo's paintings are displayed in upper positions.",
      "D) Both of Greene's paintings and both of Hidalgo's paintings are displayed in lower positions.",
      "E) Both of Greene's paintings and both of Hidalgo's paintings are displayed in upper positions."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\nwalls = EnumSort([wall1, wall2, wall3, wall4])\npositions = EnumSort([upper, lower])\npainting_types = EnumSort([oil, watercolor])\nassigned = Function([students, painting_types, walls, positions] -> [bool])\n\n# Constraints\nForAll([s:students, pt:painting_types], Exists([w:walls, p:positions], assigned(s, pt, w, p))) ::: Each student displays exactly one oil and one watercolor across walls\nForAll([w:walls], Exists([s:students, pt:painting_types], assigned(s, pt, w, upper))) ::: Each wall has exactly two paintings (upper and lower)\nForAll([w:walls], Exists([s:students, pt:painting_types], assigned(s, pt, w, lower))) ::: Each wall has exactly two paintings (upper and lower)\nForAll([w:walls], Exists([s:students], assigned(s, oil, w, upper) | assigned(s, oil, w, lower))) ::: No wall has only watercolors\nForAll([w:walls, s:students], Implies(assigned(s, oil, w, upper) \u2228 assigned(s, oil, w, lower), \u00acExists([s2:students], s2 != s \u2227 (assigned(s2, oil, w, upper) \u2228 assigned(s2, oil, w, lower))))) ::: No wall has the same student twice\nForAll([w:walls], \u00ac(Exists([s:students], assigned(s, oil, w, upper) \u2228 assigned(s, oil, w, lower)) \u2227 Exists([s2:students], s2 != s \u2227 (assigned(s2, oil, w, upper) \u2228 assigned(s2, oil, w, lower))))) ::: No wall has both Franz and Isaacs\nassigned(Greene, watercolor, wall1, upper) \u2227 assigned(Franz, oil, wall1, lower) ::: Greene's watercolor is upper on Franz's oil wall\nassigned(Isaacs, oil, wall4, lower) ::: Isaacs's oil is lower on wall4\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(ForAll([w:walls, p:positions], assigned(Franz, oil, w, p) \u2192 p == lower) \u2227 ForAll([w:walls, p:positions], assigned(Greene, oil, w, p) \u2192 p == lower)) ::: (A)\nis_sat(ForAll([w:walls, p:positions], assigned(Franz, oil, w, p) \u2192 p == upper) \u2227 ForAll([w:walls, p:positions], assigned(Greene, oil, w, p) \u2192 p == upper)) ::: (B)\nis_sat(ForAll([w:walls, p:positions], assigned(Franz, oil, w, p) \u2192 p == upper) \u2227 ForAll([w:walls, p:positions], assigned(Hidalgo, oil, w, p) \u2192 p == upper)) ::: (C)\nis_sat(ForAll([w:walls, p:positions], assigned(Greene, oil, w, p) \u2192 p == lower) \u2227 ForAll([w:walls, p:positions], assigned(Hidalgo, oil, w, p) \u2192 p == lower)) ::: (D)\nis_sat(ForAll([w:walls, p:positions], assigned(Greene, oil, w, p) \u2192 p == upper) \u2227 ForAll([w:walls, p:positions], assigned(Hidalgo, oil, w, p) \u2192 p == upper)) ::: (E)\n\n**Answer:** (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_3_18",
    "context": "At an upcoming exhibition, four art students\u00e2\u20ac\u201dFranz, Greene, Hidalgo, and Isaacs\u00e2\u20ac\u201dwill each display exactly two paintings\u00e2\u20ac\u201dan oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room\u00e2\u20ac\u201dwalls 1, 2, 3, and 4\u00e2\u20ac\u201dwith one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following CANNOT be true?",
    "options": [
      "A) Franz's watercolor is displayed on the same wall as Greene's oil.",
      "B) Franz's watercolor is displayed on the same wall as Hidalgo's oil.",
      "C) Greene's oil is displayed in an upper position.",
      "D) Hidalgo's watercolor is displayed in a lower position.",
      "E) Isaacs's watercolor is displayed on the same wall as Hidalgo's oil."
    ],
    "answer": "D",
    "logic_program": "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\nmedia = EnumSort([oil, watercolor])\ndisplay = Function([students, media, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s:students, m:media], display(s, m, w, upper) & m == oil) | Exists([s:students, m:media], display(s, m, w, lower) & m == oil)) ::: No wall has only watercolors\nForAll([w:walls], Distinct([s:students], Exists([m:media, p:positions], display(s, m, w, p)))) ::: No wall has work from only one student\nForAll([w:walls], Not(Exists([p:positions], display(Franz, _, w, p) & display(Isaacs, _, w, p)))) ::: No wall has both Franz and Isaacs\nExists([w:walls, p:positions], display(Franz, oil, w, p) & display(Greene, watercolor, w, upper)) ::: Greene's watercolor is on the same wall as Franz's oil\ndisplay(Isaacs, oil, 4, lower) ::: Isaacs's oil is in lower position of wall 4\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_invalid(Exists([w:walls, p1:positions, p2:positions], display(Franz, watercolor, w, p1) & display(Greene, oil, w, p2))) ::: (A)\nis_invalid(Exists([w:walls, p1:positions, p2:positions], display(Franz, watercolor, w, p1) & display(Hidalgo, oil, w, p2))) ::: (B)\nis_invalid(Exists([w:walls, p:positions], display(Greene, oil, w, upper))) ::: (C)\nis_invalid(Exists([w:walls, p:positions], display(Hidalgo, watercolor, w, lower))) ::: (D)\nis_invalid(Exists([w:walls, p1:positions, p2:positions], display(Isaacs, watercolor, w, p1) & display(Hidalgo, oil, w, p2))) ::: (E)\n\n**Answer:** (E) Isaacs's watercolor is displayed on the same wall as Hidalgo's oil."
  },
  {
    "id": "ar_lsat_201612_3-G_4_19",
    "context": "Three real estate companies\u00e2\u20ac\u201dRealProp, Southco, and Trustcorp\u00e2\u20ac\u201dare considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following could be the buildings owned by the three companies after only one trade is made?",
    "options": [
      "A) RealProp: the Flores Tower and the Garza Tower Southco: the Lynch Building, the Yates House, and the Zimmer House Trustcorp: the King Building, the Meyer Building, and the Ortiz Building",
      "B) RealProp: the Garza Tower, the King Building, and the Ortiz Building Southco: the Flores Tower and the Lynch Building Trustcorp: the Meyer Building, the Yates House, and the Zimmer House",
      "C) RealProp: the Garza Tower and the Lynch Building Southco: the Flores Tower, the Yates House, and the Zimmer House Trustcorp: the King Building, the Meyer Building, and the Ortiz Building",
      "D) RealProp: the Garza Tower, the Meyer Building, and the Yates House Southco: the Flores Tower and the Lynch Building Trustcorp: the King Building, the Ortiz Building, and the Zimmer House",
      "E) RealProp: the Garza Tower, the Yates House, and the Zimmer House Southco: the Lynch Building and the Ortiz Building Trustcorp: the Flores Tower, the King Building, and the Meyer Building"
    ],
    "answer": "C",
    "logic_program": "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([GarzaTower, YatesHouse, ZimmerHouse, FloresTower, LynchBuilding, KingBuilding, MeyerBuilding, OrtizBuilding])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nclass_of = Function([buildings] -> [classes])\n\n# Constraints\n# Initial ownership\nowns(RealProp, GarzaTower) ::: Garza Tower (class 1)\nowns(RealProp, YatesHouse) ::: Yates House (class 3)\nowns(RealProp, ZimmerHouse) ::: Zimmer House (class 3)\nowns(Southco, FloresTower) ::: Flores Tower (class 1)\nowns(Southco, LynchBuilding) ::: Lynch Building (class 2)\nowns(Trustcorp, KingBuilding) ::: King Building (class 2)\nowns(Trustcorp, MeyerBuilding) ::: Meyer Building (class 2)\nowns(Trustcorp, OrtizBuilding) ::: Ortiz Building (class 2)\n\n# Class assignments\nclass_of(GarzaTower) = class1\nclass_of(YatesHouse) = class3\nclass_of(ZimmerHouse) = class3\nclass_of(FloresTower) = class1\nclass_of(LynchBuilding) = class2\nclass_of(KingBuilding) = class2\nclass_of(MeyerBuilding) = class2\nclass_of(OrtizBuilding) = class2\n\n# Trade constraints (one trade)\n# Possible trade types: same-class swap, class1 for two class2, class2 for two class3\nExists([b1:buildings, b2:buildings, c1:companies, c2:companies],\n  Or(\n    # Same-class swap\n    And(c1 != c2, class_of(b1) == class_of(b2), owns(c1, b1), owns(c2, b2),\n        ForAll([b:buildings], And(\n          owns(c1, b) == If(b == b1, False, If(b == b2, True, owns(c1, b))),\n          owns(c2, b) == If(b == b2, False, If(b == b1, True, owns(c2, b)))\n        ))\n    ),\n    # Class1 for two class2\n    Exists([b_class1:buildings, b2a:buildings, b2b:buildings, c1:companies, c2:companies],\n      And(c1 != c2, class_of(b_class1) == class1, class_of(b2a) == class2, class_of(b2b) == class2,\n          owns(c1, b_class1), owns(c2, b2a), owns(c2, b2b),\n          ForAll([b:buildings], And(\n            owns(c1, b) == If(b == b_class1, False, If(b == b2a || b == b2b, True, owns(c1, b))),\n            owns(c2, b) == If(b == b2a || b == b2b, False, If(b == b_class1, True, owns(c2, b)))\n          ))\n      )\n    ),\n    # Class2 for two class3\n    Exists([b_class2:buildings, b3a:buildings, b3b:buildings, c1:companies, c2:companies],\n      And(c1 != c2, class_of(b_class2) == class2, class_of(b3a) == class3, class_of(b3b) == class3,\n          owns(c1, b_class2), owns(c2, b3a), owns(c2, b3b),\n          ForAll([b:buildings], And(\n            owns(c1, b) == If(b == b_class2, False, If(b == b3a || b == b3b, True, owns(c1, b))),\n            owns(c2, b) == If(b == b3a || b == b3b, False, If(b == b_class2, True, owns(c2, b)))\n          ))\n      )\n    )\n  )\n)\n\n# Options\nQuestion ::: Which one of the following could be the buildings owned by the three companies after only one trade is made?\nis_sat(And(\n  owns(RealProp, GarzaTower), owns(RealProp, LynchBuilding),\n  owns(Southco, FloresTower), owns(Southco, YatesHouse), owns(Southco, ZimmerHouse),\n  owns(Trustcorp, KingBuilding), owns(Trustcorp, MeyerBuilding), owns(Trustcorp, OrtizBuilding)\n)) ::: (C)"
  },
  {
    "id": "ar_lsat_201612_3-G_4_20",
    "context": "Three real estate companies\u00e2\u20ac\u201dRealProp, Southco, and Trustcorp\u00e2\u20ac\u201dare considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following CANNOT be true, no matter how many trades are made?",
    "options": [
      "A) The buildings owned by RealProp are the Flores Tower and the Garza Tower.",
      "B) The buildings owned by Southco are the Flores Tower and the Meyer Building.",
      "C) The buildings owned by Southco are the Garza Tower and the Lynch Building.",
      "D) The buildings owned by Trustcorp are the Flores Tower and the Ortiz Building.",
      "E) The buildings owned by Trustcorp are the Garza Tower and the Meyer Building."
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nclass = Function([buildings] -> [classes])\n\n# Constraints\n# Initial ownership\nowns(RealProp, Garza_Tower) ::: RealProp owns Garza Tower (class1)\nclass(Garza_Tower) == class1 ::: \nowns(RealProp, Yates_House) ::: \nclass(Yates_House) == class3 ::: \nowns(RealProp, Zimmer_House) ::: \nclass(Zimmer_House) == class3 ::: \nowns(Southco, Flores_Tower) ::: \nclass(Flores_Tower) == class1 ::: \nowns(Southco, Lynch_Building) ::: \nclass(Lynch_Building) == class2 ::: \nowns(Trustcorp, King_Building) ::: \nclass(King_Building) == class2 ::: \nowns(Trustcorp, Meyer_Building) ::: \nclass(Meyer_Building) == class2 ::: \nowns(Trustcorp, Ortiz_Building) ::: \nclass(Ortiz_Building) == class2 ::: \n\n# Trade rules\nForAll([c1:companies, c2:companies, b1:buildings, b2:buildings],\n    Implies(Trade(c1, c2, b1, b2),\n        Or(\n            And(class(b1) == class(b2), Count([b:buildings], TradeGives(c1, b)) == 1, Count([b:buildings], TradeGives(c2, b)) == 1),  # Same-class swap\n            And(class(b1) == class1, Count([b:buildings], And(TradeGives(c1, b), class(b) == class1)) == 1, \n                Count([b:buildings], And(TradeGives(c2, b), class(b) == class2)) == 2),  # 1 class1 for 2 class2\n            And(class(b1) == class2, Count([b:buildings], And(TradeGives(c1, b), class(b) == class2)) == 1, \n                Count([b:buildings], And(TradeGives(c2, b), class(b) == class3)) == 2)  # 1 class2 for 2 class3\n        )\n    )\n) ::: Each trade must be one of the three types\n\n# Options\nQuestion ::: Which one of the following CANNOT be true, no matter how many trades are made?\nis_invalid(owns(RealProp, Flores_Tower) & owns(RealProp, Garza_Tower)) ::: (A)\nis_sat(owns(Southco, Flores_Tower) & owns(Southco, Meyer_Building)) ::: (B)\nis_sat(owns(Southco, Garza_Tower) & owns(Southco, Lynch_Building)) ::: (C)\nis_sat(owns(Trustcorp, Flores_Tower) & owns(Trustcorp, Ortiz_Building)) ::: (D)\nis_sat(owns(Trustcorp, Garza_Tower) & owns(Trustcorp, Meyer_Building)) ::: (E)\n\n**Answer:** (A)"
  },
  {
    "id": "ar_lsat_201612_3-G_4_21",
    "context": "Three real estate companies\u00e2\u20ac\u201dRealProp, Southco, and Trustcorp\u00e2\u20ac\u201dare considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "If RealProp owns only class 2 buildings after some number of trades, which one of the following must be true?",
    "options": [
      "A) Trustcorp owns a class 1 building.",
      "B) Trustcorp owns the Meyer Building.",
      "C) Southco owns a class 2 Building.",
      "D) Southco owns both of the class 3 buildings.",
      "E) Southco owns the Flores Tower."
    ],
    "answer": "A",
    "logic_program": "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([GarzaTower, YatesHouse, ZimmerHouse, FloresTower, LynchBuilding, KingBuilding, MeyerBuilding, OrtizBuilding])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nclass_of = Function([buildings] -> [classes])\ntrades_allowed = Function([companies, companies, buildings, buildings] -> [bool])  # Simplified for constraints\n\n# Initial ownership and classes\nForAll([b:buildings], \n       (class_of(GarzaTower) == class1) &\n       (class_of(YatesHouse) == class3) &\n       (class_of(ZimmerHouse) == class3) &\n       (class_of(FloresTower) == class1) &\n       (class_of(LynchBuilding) == class2) &\n       (class_of(KingBuilding) == class2) &\n       (class_of(MeyerBuilding) == class2) &\n       (class_of(OrtizBuilding) == class2))\n\n# Initial ownership assignments\nowns(RealProp, GarzaTower) & owns(RealProp, YatesHouse) & owns(RealProp, ZimmerHouse)\nowns(Southco, FloresTower) & owns(Southco, LynchBuilding)\nowns(Trustcorp, KingBuilding) & owns(Trustcorp, MeyerBuilding) & owns(Trustcorp, OrtizBuilding)\n\n# Constraints\n# Trades must follow the three types and preserve class constraints\n# After trades, RealProp owns only class2 buildings\nForAll([b:buildings], Implies(owns(RealProp, b), class_of(b) == class2)) ::: RealProp owns only class2 after trades\n\n# Options\nQuestion ::: If RealProp owns only class 2 buildings after some number of trades, which one of the following must be true?\nis_valid(Exists([b:buildings], owns(Trustcorp, b) & class_of(b) == class1)) ::: (A)\nis_valid(owns(Trustcorp, MeyerBuilding)) ::: (B)\nis_valid(Exists([b:buildings], owns(Southco, b) & class_of(b) == class2)) ::: (C)\nis_valid(owns(Southco, YatesHouse) & owns(Southco, ZimmerHouse)) ::: (D)\nis_valid(owns(Southco, FloresTower)) ::: (E)"
  },
  {
    "id": "ar_lsat_201612_3-G_4_22",
    "context": "Three real estate companies\u00e2\u20ac\u201dRealProp, Southco, and Trustcorp\u00e2\u20ac\u201dare considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "If Trustcorp owns no class 2 buildings after some number of trades, which one of the following must be true?",
    "options": [
      "A) RealProp owns a class 1 building.",
      "B) Southco owns only class 2 buildings.",
      "C) Southco has made at least one trade with Trustcorp.",
      "D) Trustcorp owns the Garza Tower.",
      "E) Trustcorp owns the Zimmer House."
    ],
    "answer": "E",
    "logic_program": "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nclass_type = Function([buildings] -> [classes])\n\n# Constraints\n# Initial ownership\nowns(RealProp, Garza_Tower) ::: Garza Tower (class1)\nclass_type(Garza_Tower) == class1\nowns(RealProp, Yates_House) ::: Yates House (class3)\nclass_type(Yates_House) == class3\nowns(RealProp, Zimmer_House) ::: Zimmer House (class3)\nclass_type(Zimmer_House) == class3\n\nowns(Southco, Flores_Tower) ::: Flores Tower (class1)\nclass_type(Flores_Tower) == class1\nowns(Southco, Lynch_Building) ::: Lynch Building (class2)\nclass_type(Lynch_Building) == class2\n\nowns(Trustcorp, King_Building) ::: King Building (class2)\nclass_type(King_Building) == class2\nowns(Trustcorp, Meyer_Building) ::: Meyer Building (class2)\nclass_type(Meyer_Building) == class2\nowns(Trustcorp, Ortiz_Building) ::: Ortiz Building (class2)\nclass_type(Ortiz_Building) == class2\n\n# Trade constraints (simplified to focus on post-trade state where Trustcorp has no class2)\nForAll([c:companies, b:buildings], Implies(owns(c, b), Or(\n    And(c == RealProp, Or(b == Garza_Tower, b == Yates_House, b == Zimmer_House)),\n    And(c == Southco, Or(b == Flores_Tower, b == Lynch_Building)),\n    And(c == Trustcorp, Or(b == King_Building, b == Meyer_Building, b == Ortiz_Building))\n))) ::: Initial ownership constraints\n\n# Trustcorp ends with no class2\nForAll([b:buildings], Implies(owns(Trustcorp, b), class_type(b) != class2)) ::: Trustcorp owns no class2 after trades\n\n# Options\nQuestion ::: If Trustcorp owns"
  },
  {
    "id": "ar_lsat_201612_3-G_4_23",
    "context": "Three real estate companies\u00e2\u20ac\u201dRealProp, Southco, and Trustcorp\u00e2\u20ac\u201dare considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following CANNOT be true, no matter how many trades are made?",
    "options": [
      "A) The buildings owned by RealProp are the Lynch Building, the Meyer Building, and the Ortiz Building.",
      "B) The buildings owned by Southco are the Garza Tower and the Meyer Building.",
      "C) The buildings owned by Southco are the King Building, the Meyer Building, and the Ortiz Building.",
      "D) The buildings owned by Trustcorp are the Flores Tower and the Yates House.",
      "E) The buildings owned by Trustcorp are the Garza Tower and the Lynch Building."
    ],
    "answer": "D",
    "logic_program": "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nclass_of = Function([buildings] -> [classes])\n\n# Constraints\n# Initial ownership\nowns(RealProp, Garza_Tower) ::: RealProp owns Garza Tower (class1)\nclass_of(Garza_Tower) == class1 ::: Garza Tower is class1\nowns(RealProp, Yates_House) ::: RealProp owns Yates House (class3)\nclass_of(Yates_House) == class3 ::: Yates House is class3\nowns(RealProp, Zimmer_House) ::: RealProp owns Zimmer House (class3)\nclass_of(Zimmer_House) == class3 ::: Zimmer House is class3\n\nowns(Southco, Flores_Tower) ::: Southco owns Flores Tower (class1)\nclass_of(Flores_Tower) == class1 ::: Flores Tower is class1\nowns(Southco, Lynch_Building) ::: Southco owns Lynch Building (class2)\nclass_of(Lynch_Building) == class2 ::: Lynch Building is class2\n\nowns(Trustcorp, King_Building) ::: Trustcorp owns King Building (class2)\nclass_of(King_Building) == class2 ::: King Building is class2\nowns(Trustcorp, Meyer_Building) ::: Trustcorp owns Meyer Building (class2)\nclass_of(Meyer_Building) == class2 ::: Meyer Building is class2\nowns(Trustcorp, Ortiz_Building) ::: Trustcorp owns Ortiz Building (class2)\nclass_of(Ortiz_Building) == class2 ::: Ortiz Building is class2\n\n# Trading rules\nForAll([c1:companies, c2:companies, b1:buildings, b2:buildings],\n    Implies(Trade(c1, c2, b1, b2),\n        Or(\n            And(class_of(b1) == class_of(b2)),  # Same-class trade\n            And(class_of(b1) == class1, Count([b:buildings], And(owns(c1, b), class_of(b) == class2)) == 2),  # 1 class1 for 2 class2\n            And(class_of(b1) == class2, Count([b:buildings], And(owns(c1, b), class_of(b) == class3)) == 2)  # 1 class2 for 2 class3\n        )\n    )\n) ::: Each trade must follow the specified rules\n\n# Options\nQuestion ::: Which one of the following CANNOT be true, no matter how many trades are made?\nis_invalid(owns(RealProp, Lynch_Building) & owns(RealProp, Meyer_Building) & owns(RealProp, Ortiz_Building)) ::: (A)\nis_invalid(owns(Southco, Garza_Tower) & owns(Southco, Meyer_Building)) ::: (B)\nis_invalid(owns(Southco, King_Building) & owns(Southco, Meyer_Building) & owns(Southco, Ortiz_Building)) ::: (C)\nis_invalid(owns(Trustcorp, Flores_Tower) & owns(Trustcorp, Yates_House)) ::: (D)\nis_invalid(owns(Trustcorp, Garza_Tower) & owns(Trustcorp, Lynch_Building)) ::: (E)\n\n**Answer**\nThe answer is (D). \n\nThe constraints show that Trustcorp cannot end up owning only Flores Tower (class1) and Yates House (class3) because acquiring Yates House would require obtaining two class3 buildings via a class2 trade, leaving Trustcorp with an extra class3 building (Zimmer House) that cannot be disposed of, violating the option's condition."
  }
]